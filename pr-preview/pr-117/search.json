[
  {
    "objectID": "modules/module5/slides/module5_13.html#module-learning-outcomes",
    "href": "modules/module5/slides/module5_13.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 5",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nManage feature-based development efficiently with Git in JupyterLab and in the terminal.\nInfer a repository‚Äôs current status and collaboration pattern by looking at visualizations of the project history in VS Code.\nDifferentiate when to use forking or branching as a collaboration strategy.\nRecognize the essential components of a pull request.\nDetermine whether directly merging changes is preferable to first opening a pull request.\nExplain when GitHub issues are helpful and how to use them.\n\n\nNow is time to work!"
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#lets-work-together",
    "href": "modules/module5/slides/module5_09.html#lets-work-together",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Let‚Äôs work together!",
    "text": "Let‚Äôs work together!\n\n\n\nArtwork by @allison_horst\n\nWe have already seen some ways in which Git and GitHub allow collaboration with others. Here we will dive more in depth into which collaborative workflows are the most effective when multiple people are contributing code to the same repository.\nArtwork by @allison_horst"
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#branching-and-forking",
    "href": "modules/module5/slides/module5_09.html#branching-and-forking",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Branching and forking",
    "text": "Branching and forking\nThere are two main strategies we can use to work with others:\n\nBranching\nForking\n\n\nThere are two major ways to work in a collaborative basis using Git and GitHub:\n\nWorking with colleagues in a repository where all of you are members with permission to push code. We call this strategy branching.\n\nIf you start a new repository with some coworkers and you add them as collaborators, you can all contribute to it using branching.\n\nContributing to a repository that you don‚Äôt have access to using a GitHub tool called forking.\n\nThe use of forks is common when collaborating on online repositories where you don‚Äôt have write access, such as open source projects led by someone else.\nAs an example imagine that you want to contribute to this multilingual glossary for computing and data science terms created by The Carpentries, an inclusive community willing to teach data and coding skills.\nIf you explore the GitHub repo of the project (https://github.com/carpentries/glosario) you will see a file called CONTRIBUTING.md where it is explained how someone can add new terms to the glossary.\nIn general, when you want to contribute to a public repository as this one, you will have to fork the repository first because you don‚Äôt have write access. Forking it allow you to create a copy in your GitHub account of the repository at that moment."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#collaborative-work",
    "href": "modules/module5/slides/module5_09.html#collaborative-work",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Collaborative work",
    "text": "Collaborative work\nThere are two main strategies we can use to work with others:\n\n Branching \nForking\n\n\nIn the next slide deck we will focus on forking, but let‚Äôs start by learning about the branching strategy first!\nBefore we dive in, remember that regardless of whether you are collaborating via branching or forking, the most common practice before accepting contributions to the main branch involves opening a pull request with the proposed changes and ask for a review before merging those changes."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project",
    "href": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Giving collaborators access to your project",
    "text": "Giving collaborators access to your project\nThe ‚ÄúInvite a collaborator‚Äù button on the GitHub web interface.\n\n\nWhen working with a branching workflow, all collaborators need to have ‚Äúwrite access‚Äù to the remote repository so that they can push up their branches to GitHub. As mentioned earlier, GitHub allows you to control who has access to your project. The default of both public and private projects are that only the creator of the GitHub repository has permissions to create, edit and delete files (write access). Go to the ‚ÄúSettings‚Äù tab if your repostiroy on GitHub and select ‚ÄúCollaborators‚Äù There, you must click the green ‚ÄúAdd people‚Äù button."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project-1",
    "href": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project-1",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Giving collaborators access to your project",
    "text": "Giving collaborators access to your project\n\n\n\nThen type in the collaborator‚Äôs GitHub username or email, and select their name when it appears.\nAfter this, you should see your newly added collaborator listed under the ‚ÄúManage access‚Äù tab. They should receive an email invitation to join the GitHub repository as a collaborator. They need to accept this invitation to enable write access."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#branch-protection-rules",
    "href": "modules/module5/slides/module5_09.html#branch-protection-rules",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Branch protection rules",
    "text": "Branch protection rules\nUnder ‚ÄúBranch name pattern‚Äù, type the branch name or pattern you want to protect.\n\n\n\nNow that everyone has access, they can clone the repository and create a branch using a meaningful name with the feature they are willing to work on. If some of the collaborators push to main without communicating it to the other team members first could it create merging problems. To reduce that risk, you can set up a branch protection rule in the repository, which requires a pull request before merging any code into the protected branch.\nüôå To add a branch protection rule you can go to Settings &gt; Code and Automation (sidebar) &gt; Branch protection rules and click ‚ÄúAdd rule‚Äù.\nüôå Under ‚ÄúBranch name pattern‚Äù, type the branch name or pattern you want to protect. Notice that you can create protect branches different to main but we will not cover those use cases in this tutorial."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#branch-protection-rules-1",
    "href": "modules/module5/slides/module5_09.html#branch-protection-rules-1",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Branch protection rules",
    "text": "Branch protection rules\n\n\n\nIf you think in the analogy of the house, protecting the main branch would be similar to avoid creating modifications in the foundation of the house meanwhile each member is working in different sections. This makes sense since any changes in the house‚Äôs foundation could give rise to problems when combining the parts, including the risk of collapsing the house.\nIn your repository, this means that you should be sure that code in main, also called the production branch, is high quality code without bugs or other run problems. Each time you accept merging a contribution of another team member in main be sure that the code is doing what is expected and it is well documented. This way you will always have stable and well build code that runs propoperly in your main branch. This ensures that you are producing code in an organized way.\nUsing branch protection rules is a team decision that could prevent the error of pushing to the main branch without notifying your colleagues. If you made only minor edits the team might let you merge these to main locally and then push up the updated main branch (or even let you not create a branch in the first place).\n‚ö†Ô∏è Remember to get the input from other team members before deciding to implement branch protection, so that everyone in your team is on the same page."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#how-pull-requests-look-like-after-you-protect-the-branch",
    "href": "modules/module5/slides/module5_09.html#how-pull-requests-look-like-after-you-protect-the-branch",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "How pull requests look like after you protect the branch",
    "text": "How pull requests look like after you protect the branch\n\n\n\nThis is how pull requests look like after you protect the branch. You will need the approval of a team member before you can merge the pull request."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#a-basic-branching-workflow",
    "href": "modules/module5/slides/module5_09.html#a-basic-branching-workflow",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "A basic branching workflow",
    "text": "A basic branching workflow\n\nClone the project - To work locally.\nCreate your branch - Create code or apply your changes.\nMake the desired modifications - Adding a new feature, fixing a bug, etc.\nPush your changes - This will upload your branch to GitHub\nCreate a pull request - So that your changes can be reviewed by another team member.\n\nRemember to pull the changes before starting to work in the repository\n\nGiving your collaborators access to your repository is mandatory to collaborate using branches. Protecting the main branch is considered good practice but experienced users that are very familiar with the workflow could opt to not use this strategy.\nThe workflow will be the same that we have learned before, cloning, adding to the staging area, committing the changes and pushing to the repo with the only difference being that you will have to create a pull request. Merge conflicts could happen and you can use the strategies you have learned in the past modules to resolve them.\nWe are ready to start collaborating!"
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#merging-branches",
    "href": "modules/module5/slides/module5_05.html#merging-branches",
    "title": "Merging branches",
    "section": "Merging branches",
    "text": "Merging branches\n\n\n\nOnce you have finished your modifications in the branch you are working on, it is time to merge your changes to the main branch!\nUpon merging, the changes you were working on in a particular branch are combined with the content of the main branch (or any other branch that you decide to merge your changes with).\nWhen you merge two branches you are creating a new commit with the combined changes. In the image, these commits are represented by yellow circles."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#merging-branches-jupyterlab",
    "href": "modules/module5/slides/module5_05.html#merging-branches-jupyterlab",
    "title": "Merging branches",
    "section": "Merging branches (JupyterLab)",
    "text": "Merging branches (JupyterLab)\n\n\n\nTo merge a branch using JupyterLab, you have to click on the tab Branches and then on the name of the branch you want to merge your current work into. For example, if you are working on the branch main, you can click next to the report branch in the side panel and select ‚ÄúMerge this branch into the current branch‚Äù.\nNotice that after doing this, the report branch is not deleted automatically, so you can still access it if you need to."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#merging-branches-terminal",
    "href": "modules/module5/slides/module5_05.html#merging-branches-terminal",
    "title": "Merging branches",
    "section": "Merging branches (Terminal)",
    "text": "Merging branches (Terminal)\n\ngit merge &lt;branch&gt;\n\n\n\nIf you want to use the terminal to merge the branches and you are currently working on the main branch, you can type git merge &lt;branch&gt; to merge the commits from the branch with the new feature into the main branch. In this slide, we merged in the changes of the branched named report into main by typing git merge report while having the main branch active."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#visualizing-merged-branches",
    "href": "modules/module5/slides/module5_05.html#visualizing-merged-branches",
    "title": "Merging branches",
    "section": "Visualizing merged branches",
    "text": "Visualizing merged branches\n\n\n\nLet‚Äôs see how VS Code‚Äôs graphical representation of the Git history changed when we merged the branches together. Remember that you can open VS Code from the terminal using the command code .. Then go to View &gt; Command Palette and start writing Git: View History (git log). A new tab will open with the Git History. If you want to display all the branches you will have to select them in one of the menus. In this view, we can see that the line for our branch has re-connected to the main branch with a merge commit."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#deleting-branches-jupyterlab",
    "href": "modules/module5/slides/module5_05.html#deleting-branches-jupyterlab",
    "title": "Merging branches",
    "section": "Deleting branches (JupyterLab)",
    "text": "Deleting branches (JupyterLab)\n\n\n\nYou will notice that merging the branch will not automatically delete it. If you are not going to be developing that feature anymore you can delete the branch after merging it by clicking on the small garbage bin icon in the Branches tab.\nYou can only delete a branch when you are not working on it (it is not highlighted in blue in the JupyterLab UI) and although it can be difficult to recover the information after it is deleted, you can safely do so after successfully merging the changes into another branch."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#deleting-branches-terminal",
    "href": "modules/module5/slides/module5_05.html#deleting-branches-terminal",
    "title": "Merging branches",
    "section": "Deleting branches (terminal)",
    "text": "Deleting branches (terminal)\n\ngit branch -d &lt;branch-name&gt;\n\n\n\nIf you want to delete the branches using the terminal you can use the command git branch -d &lt;branch-name&gt;. Be careful! You should use -d and NOT -D. If you write the flag with a capital -D it will force the deletion, even if the branch has not been merged yet, what could be dangerous. If you add the d flag, it will only delete the branch after it has been merged.\nNow that you have a better grip on how to read the Git history and how to merge branches, it will be easier to work with both branches and forks!"
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#what-is-a-branch",
    "href": "modules/module5/slides/module5_01.html#what-is-a-branch",
    "title": "The role of branches",
    "section": "What is a branch?",
    "text": "What is a branch?\n\n\nIn Git, a branch represents an isolated line of commits in a repository. By default, you will always start working on the so called main branch. Creating a new branch allows you to work on a series of commits in isolation from the main branch.\nThis is beneficial since you don‚Äôt want the repository‚Äôs default branch to be updated with every commit of a half-finished feature. Instead, new features are developed on separate branches that will be ‚Äúmerged‚Äù into the main branch once the development of that feature is finished. The separation of feature branches from the main branch facilitates parallel development where progress can be made on multiple independent features simultaneously.\nTo illustrate feature-based development with a practical example, we can use the construction of a house as you can see in this slide (each dot represent a commit). First, you need to build the foundation. Since everything depends on the foundation being built, this would be developed on the main branch. When the foundation is finished the construction of other parts of the house that don‚Äôt depend on each other could take place in parallel, e.g.¬†some contributors might start working on the walls and others on the floor. When either of these features is finished, it can be added back to the house (what would be similar to merged into main)."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#when-should-a-new-branch-be-opened",
    "href": "modules/module5/slides/module5_01.html#when-should-a-new-branch-be-opened",
    "title": "The role of branches",
    "section": "When should a new branch be opened?",
    "text": "When should a new branch be opened?\n\nWhen we initiate a repository by default we start working on the main branch, but we can be working in parallel in other features.\n\nIn the image we can see that two branches were created from main. The first one, feat-trained-model, is based on the state of the repository at the third commit to the main branch. The second branch is called fix-eda-plot and was initiated from the fourth commit of the main branch to fix one of the exploratory analysis plots. At the end we merge all these branches to main so the isolated modifications are included in the principal branch of our repository.\nWhen should a new branch be opened? Generally speaking, you can assume that every modification that has the potential to break the original code is suitable to be developed in its own feature branch to avoid the risk of it changing how the code in the main branch works.\nNote that the name main for the default branch is just a convention and in some old repositories the default branch could be called master instead of main."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab",
    "title": "The role of branches",
    "section": "How to create a branch? (JupyterLab)",
    "text": "How to create a branch? (JupyterLab)\n\n\n\nTo create a branch in JupyterLab you have to go to Branches &gt; New branch and then write the name of the branch there. If you want to create the new branch based on another branch than main you can click and select it in the menu. You can always switch easily between branches on the Branches tab in the side bar.\nIn this slide, the options available are to create a branch from main, from origin/HEAD and origin/main. We already know that main is the default branch, but what about origin and HEAD?\nThe material of this module is based on the book by Timbers, T., Campbell, T., & Lee, M. (2022). Data science: A first introduction. CRC Press and the course DSCI 521: Computing Platforms for Data Science from the UBC Master of Data Science."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab-1",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab-1",
    "title": "The role of branches",
    "section": "How to create a branch? (JupyterLab)",
    "text": "How to create a branch? (JupyterLab)\n\n\n\nIn the terminal, you can use git log --oneline to check the history of your project, and see which commits correspond to the names origin/HEAD, origin/main and main. You can also see that the currently active branch is shown in cyan at the end of the terminal prompt.\n\nmain is your default local branch.\nHEAD is pointing where you currently are (in this case, on the main branch)\norigin is a nickname for your remote repo on GitHub (instead of showing the full URL), so origin/main is the main branch of the version of the repo you pushed to GitHub.com.\n\nYou don‚Äôt need to care about origin/HEAD, it just point to the default remote branch, which will always be main unless you mess around with the settings on the GitHub webpage.\nIn JupyterLab you can see this information as labels under the tab Changes in the sidebar.\n‚ö†Ô∏è Here we added a new synonym for a GitHub repository. Previously, we were using remote as a way to refer to any GitHub repository. Here Git refers to the default remote in which we are working on with the nickname origin."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal",
    "title": "The role of branches",
    "section": "How to create a branch? (Terminal)",
    "text": "How to create a branch? (Terminal)\n\ngit switch -c &lt;branch-name&gt; &lt;commit-hash&gt;\n\n\n\nThe git switch command can be used to alternate between existing branches. If a branch does not yet exist, you can append the -c flag to create the branch as you switch to it. Let‚Äôs create a new branch! Type git switch -c &lt;branch-name&gt;, to create and switch to this branch. If you want to create a branch starting in a particular commit you should add the commit hash as another argument. In the example, the branch is created from the last commit, that is the default behaviour when a commit hash is not included.\nAfter creating the branch, you will switch to working on there. In the terminal, you‚Äôll notice that the name of the new branch, in this case report, appears now in parenthesis in the terminal. Also, the Current branch tab in JupyterLab is updated, and the new branch is now listed there.\nüôå\nTo practice working with branches, let‚Äôs try adding a commit to one of your example repositories and check what happens in JupyterLab (tab Changes) and with the command line (running the command git log --oneline):\n\nBefore and after doing a commit.\nBefore and after pushing to the remote."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal-1",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal-1",
    "title": "The role of branches",
    "section": "How to create a branch? (Terminal)",
    "text": "How to create a branch? (Terminal)\n\n\n\nLet‚Äôs see what happens when we make a commit locally.\n\nEdit your README to append one more line of your choice, then add it to the staging area and commit it.\nRun git log --oneline\n\nAs expected, only the reference to where we are currently (HEAD) and the report branch moved, because we have not pushed the changes to our GitHub remote (origin). If you push your changes, the GitHub main branch (origin/main) will also be updated with the latest commit. To confirm this, you can run git log --oneline after pushing the new commit to GitHub.\nBut how can we push a local branch to GitHub?"
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#pushing-a-new-branch",
    "href": "modules/module5/slides/module5_01.html#pushing-a-new-branch",
    "title": "The role of branches",
    "section": "Pushing a new branch",
    "text": "Pushing a new branch\n\ngit push --set-upstream origin &lt;new-branch-name&gt;\n\n\n\nPushing a new branch using JupyterLab is exactly the same as you are used to with the ‚Äúpush‚Äù button. However, there is a slight change in the command when you are pushing a branch you created locally with the terminal. Instead of git push you will have to write:\ngit push --set-upstream origin &lt;new-branch-name&gt;\nThis command decides what the new branch will be called on the remote GitHub repo. It is recommended that you use the same name as you use locally, and using a different name is rarely necessary. You don‚Äôt need to worry about remembering this command, because git will remind you in the case you forget to specify it as you can see in the image.\nAfter pushing the new branch report to the remote you will notice that the local branch report and the remote branch origin/report are placed in the same commit when you read the history of the project. This means that your remote repository is synchronized with your local repository."
  },
  {
    "objectID": "modules/module5/module5-13-what_did_we_just_learn.html",
    "href": "modules/module5/module5-13-what_did_we_just_learn.html",
    "title": "7. What Did We Just Learn?",
    "section": "",
    "text": "7. What Did We Just Learn?\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "7. What Did We Just Learn?"
    ]
  },
  {
    "objectID": "modules/module5/module5-11-collaborative_github_workflows:_forking.html",
    "href": "modules/module5/module5-11-collaborative_github_workflows:_forking.html",
    "title": "6. Collaborative GitHub workflows: Forking",
    "section": "",
    "text": "6. Collaborative GitHub workflows: Forking\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "6. Collaborative GitHub workflows: Forking"
    ]
  },
  {
    "objectID": "modules/module5/module5-09-collaborative_github_workflows:_branching.html",
    "href": "modules/module5/module5-09-collaborative_github_workflows:_branching.html",
    "title": "5. Collaborative GitHub workflows: Branching",
    "section": "",
    "text": "5. Collaborative GitHub workflows: Branching\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "5. Collaborative GitHub workflows: Branching"
    ]
  },
  {
    "objectID": "modules/module5/module5-07-when_merging_branches_goes_social:_opening_pull_requests.html",
    "href": "modules/module5/module5-07-when_merging_branches_goes_social:_opening_pull_requests.html",
    "title": "4. When merging branches goes social: opening pull requests",
    "section": "",
    "text": "4. When merging branches goes social: opening pull requests\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "4. When merging branches goes social: opening pull requests"
    ]
  },
  {
    "objectID": "modules/module5/module5-05-merging_branches.html",
    "href": "modules/module5/module5-05-merging_branches.html",
    "title": "3. Merging branches",
    "section": "",
    "text": "3. Merging branches\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "3. Merging branches"
    ]
  },
  {
    "objectID": "modules/module5/module5-03-how_branches_are_related.html",
    "href": "modules/module5/module5-03-how_branches_are_related.html",
    "title": "2. How branches are related?",
    "section": "",
    "text": "2. How branches are related?\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "2. How branches are related?"
    ]
  },
  {
    "objectID": "modules/module5/module5-01-the_role_of_branches.html",
    "href": "modules/module5/module5-01-the_role_of_branches.html",
    "title": "1. The role of branches",
    "section": "",
    "text": "1. The role of branches\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "1. The role of branches"
    ]
  },
  {
    "objectID": "modules/module4/slides/module4_13.html#module-learning-outcomes",
    "href": "modules/module4/slides/module4_13.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 4",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nExplore the Git history via git log in the terminal, and the equivalent functions in JupyterLab and GitHub.\nCompare commits using git diff in the terminal, and the equivalent functions in JupyterLab and GitHub.\nSolve merge conflicts at the command line and in VS Code.\nAvoid pushing certain local files by including a .gitignore file.\nDifferentiate between doing a revert and a hard reset of a commit when restoring an older version of a project.\n\n\nThe assignment will concentrate on the learning objectives as well as building knowledge on existing concepts."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise",
    "href": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise",
    "title": "Handling merge conflicts",
    "section": "When does a merge conflict arise?",
    "text": "When does a merge conflict arise?\n\n\n\nAs we mentioned a few slide decks ago, it is good practice to pull any changes at the start of every work session before you start working on your local copy. If you forget to do this you might end up in a situation where your collaborators have pushed some changes to the remote that you don‚Äôt have locally.\nThe solution to this situation is usually simple: you pull down the remote changes to your computer and let Git automatically merge the changes for you, which often works well even if you and your collaborators were working on different parts of the same file!\nHowever, if you and your collaborators made changes to the same line(s) of the same file(s), Git will not be able to automatically merge the changes since it doesn‚Äôt know whether to keep your version of the line(s), your collaborator‚Äôs version of the line(s), or some blend of the two. When this happens, Git will inform you that you have a ‚Äúmerge conflict‚Äù in certain file(s) and let you decide how to solve the issue."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise-1",
    "href": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise-1",
    "title": "Handling merge conflicts",
    "section": "When does a merge conflict arise?",
    "text": "When does a merge conflict arise?\n\n\n\nYou also can visualize the merge conflict as an error when you try to push your local changes to GitHub.\nImagine that at least one commit in the remote repository and one in your local repository are incompatible to combine without overwriting a portion of the work. This is why attempting to pull or push modifications will result in an error. Git is unable to merge the remote and the local version."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: Terminal",
    "text": "Handling merge conflicts: Terminal\ngit status\nOn branch main\nYour branch and 'origin/main' have diverged,\nand have 2 and 1 different commits each, respectively.\n  (use \"git pull\" to merge the remote branch into yours)\n\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add &lt;file&gt;...\" to mark resolution)\n        both modified:   README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nIf you are using the terminal, you can detect which files are affected in the merge conflict with the command git status.\nEvery file affected by a merge conflict will be listed in the ‚ÄúUnmerged paths‚Äù, in the example we can see that there is a merge conflict on the README.md file."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-1",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-1",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: Terminal",
    "text": "Handling merge conflicts: Terminal\n\n\n\nIn a merge conflict, Git will create marks in the affected files that indicate which areas it is unsure how to handle. To resolve a merge conflict, you need to open the indicated file in a plain text editor and edit the marked up content in a way so that Git knows which changes you want to keep.\nYou can click on the file and select the Option Open With Editor -&gt; Editor"
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-2",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-2",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: Terminal",
    "text": "Handling merge conflicts: Terminal\n\n\n\nOnce you open the file, you have to find the merge conflict. The beginning of the merge conflict is preceded by &lt;&lt;&lt;&lt;&lt;&lt;&lt; and the end of the merge conflict is marked by &gt;&gt;&gt;&gt;&gt;&gt;&gt;. Between these markings, Git also inserts a separator (=======). The version of the change before the separator is your change (marked with HEAD), and the version that follows the separator was the change that existed on GitHub (marked with the commit hash). In the image, you can see that in your local repository the README.md title is Canadian languages. It looks like your collaborator made an edit to that line too, but the name selected for the title is slightly different: Data Science project: Canadian languages !\nTo resolve the merge conflict, we can do anything we want:\n\nKeep the change made in the local repository,\nKeep the change made in the remote repository,\nWrite something new to replace both, or get rid of the change entirely.\n\nOnce you have decided which option you prefer, you must remove any separators and unwanted text/code from the file and leave only the information you want to include in the new version of the file. After you made your changes, the file must first be saved, then added to the staging area, and finally committed before you will be able to push your changes to GitHub."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: JupyterLab",
    "text": "Handling merge conflicts: JupyterLab\n\n\n\nJupyterLab makes it easier to detect and resolve merge conflicts. In the Git tab, a new section called Conflicted will appear below Changes.\nThere you can visualize all the files that have a merge conflict. In the example, the issue is only affecting the README.md file."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab-1",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab-1",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: JupyterLab",
    "text": "Handling merge conflicts: JupyterLab\n\n\n\nOnce you click the file with the merge conflict, you will be able to select to accept your current local change or the incoming changes from the remote. In this case, I accepted the current changes by clicking the arrow next to the change. After that, click Mark as resolved, stage the changes, and create a new commit to resolve the conflict.\nYou will now be able to push or pull changes without error!"
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks",
    "href": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks",
    "title": "Handling merge conflicts",
    "section": "Special case: Version control and Jupyter Notebooks",
    "text": "Special case: Version control and Jupyter Notebooks\nJSON format\n{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Canadian Languages\\n\",\n    \"\\n\",\n    \"This project aims to understand what languages Canadian residents speak, and where they speak them.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 3,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"import pandas as pd\\n\",\n    \"import altair as alt\"\n   ]\n  },\n\nFirst - a bit about what a Jupyter notebook are ‚Äúplain‚Äù text files, and we can view them in a plain text editor.\nHowever, the contents of the notebook are encoded in JSON format, which means that there are many brackets in the file, which can make it hard to read for humans (but easy for machines)."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-1",
    "href": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-1",
    "title": "Handling merge conflicts",
    "section": "Special case: Version control and Jupyter Notebooks",
    "text": "Special case: Version control and Jupyter Notebooks\n\n\n\nBecause the notebooks are stored as plain text, we can use them for version control, but this is not without issues, since the JSON format can make it difficult to interpret difference between files and to manually fix conflicts.\nIn this situation is better to use JupyterLab than any other editor. The same as we explained before, to solve the merge conflict you have to click in this case in the notebook eda.ipynb that show up in the section called Conflicted."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-2",
    "href": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-2",
    "title": "Handling merge conflicts",
    "section": "Special case: Version control and Jupyter Notebooks",
    "text": "Special case: Version control and Jupyter Notebooks\n\n\n\nA new tab will appear, displaying the current local changes and incoming remote changes that are incompatible. JupyterLab displays the .ipynb files as notebooks even during the merge conflicts and the conflicting lines are highlighted in red as you can see in the image. You can choose to keep the current changes, the incoming changes, or go back to the commit before the project‚Äôs history diverged. The last option is known as ‚ÄúCommon ancestor‚Äù In the example, I decided to keep the current changes, so you should click the small arrow next to the selected option. Finally, you should click the Mark as solved button. Remember that you need to stage and commit the changes after solving the conflict.\nWe recommend using JupyterLab rather than the terminal to resolve merge conflicts in Jupyter Notebooks."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal",
    "href": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal",
    "title": "Handling merge conflicts",
    "section": "Extra: Stashing local non-committed changes before pulling (Terminal)",
    "text": "Extra: Stashing local non-committed changes before pulling (Terminal)\nerror: Your local changes to the following files would be overwritten by merge:\n        README.md\nPlease commit your changes or stash them before you merge.\nAborting\n\nWe have learned that if there are changes in your remote repo on GitHub and you already have locally committed changes, you will need to pull before you can push. If the local and remote changes are in the same lines, you will have to resolve the resulting merge conflict, otherwise Git will merge automatically.\nBut what if you have just started to make changes to a file when you realize that you forgot to pull before you started to work? The first thing to do is to try to pull, if you‚Äôre lucky there are either no new changes or they are not in the same file you modified. If they are in the same file, you will get an error message like the one in the slide."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal-1",
    "href": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal-1",
    "title": "Handling merge conflicts",
    "section": "Extra: Stashing local non-committed changes before pulling (Terminal)",
    "text": "Extra: Stashing local non-committed changes before pulling (Terminal)\ngit stash\nSaved working directory and index state WIP on main: d59b6bb Add MIT license\n\nTo solve this error in the previous slide, we can use a command called git stash, which removes your local changes from the working area and saves them in another location (you can think of this as a secrete pocket which Git does not care about when pulling from the remote repo, and from which you can take out the changes again when you need them). You can then do git pull, and follow up with a git stash apply to bring your changes back from the stash to the working area, and then carry on working.\nThis workflow can save you from running into merge conflicts, as long as you have not already made modifications to the same lines as you are pulling down. If you have already modified the same file that was updated remotely, you will still run into a merge conflict when you do git stash apply.\nStashing is also great when you are working on one feature but realize that you should actually work on another unrelated feature first, you can stash your existing work (instead of manually saving it elsewhere) and finish working on the most urgent feature first."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#time-travelling",
    "href": "modules/module4/slides/module4_05.html#time-travelling",
    "title": "Reset your Git project to an earlier state",
    "section": "Time travelling",
    "text": "Time travelling\n\nWe are going to learn two ways to travel back in time to a previous commit:\n\n\nDoing a hard reset\nReverting previous changes\n\n\nIt‚Äôs not uncommon to realize that we made a mistake when viewing the history! Maybe we didn‚Äôt mean to delete an important file and we want to undo our latest commit. Don‚Äôt worry, we can now take advantage of tracking our files using version control to retrieve a previous state of a file and replace the current version.\nThere are two ways of traveling back in time to an earlier state of the repo:\n\nRemove commits from the Git history (a ‚Äúhard reset‚Äù).\nCreate a new commit to undo previous changes (a ‚Äúreversion‚Äù).\n\nIn this slide deck we will look into git reset and in the next one we will cover git revert."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab",
    "href": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (JupyterLab)",
    "text": "Hard reset (JupyterLab)\n\n\nA hard reset deletes your changes AND the history of your project by removing the commits from your current branch. To perform a hard reset in JupyterLab, you should click the clock icon next to the commit you would like to travel back to."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-1",
    "href": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-1",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (JupyterLab)",
    "text": "Hard reset (JupyterLab)\n\n\nBe careful! This action can‚Äôt be undone and JupyterLab will display a dialog box to confirm that you are sure that you want to discard your commits."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-2",
    "href": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-2",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (JupyterLab)",
    "text": "Hard reset (JupyterLab)\n\n\nAfter doing a hard reset on your local Git repository, you would need to push your changes to the remote repository for them to be visible online. However, because you have changed the Git history by removing some commits, this would lead to issues for your colleagues who still have these commits on their computers. Therefore, it is not recommended to use a hard reset when working with collaborators, unless there are extraordinary circumstances requiring it.\nIf you have performed a hard reset locally, but you change your mind you could use the backup on the remote repository to undo your local changes by pulling back the commits from the remote repository."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-terminal",
    "href": "modules/module4/slides/module4_05.html#hard-reset-terminal",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (Terminal)",
    "text": "Hard reset (Terminal)\ngit reset --hard &lt;commit hash&gt;\ngit push -f/--force\n\n\n\nIn the terminal, you can look at the git log output to find the commit hash we want to reset our project to. Then we can use the command git reset --hard &lt;commit hash&gt;.\nGit by default protects from unintentionally pushing after a hard reset. If you really want to delete the commits and remove them from GitHub, you must use the command git push -f to ‚Äúforce‚Äù the push in the terminal, regardless of whether you choose to execute the hard reset using the JupyterLab IDE or the terminal.\nAfter doing a hard reset, JupyterLab will offer you to pull the locally deleted commits from the remote. You shouldn‚Äôt pull if you want to preserve the deletion of commits you made with the hard reset!\nExtra\nIf we want to make a new commit with the changes since the reset point, we can perform a ‚Äúsoft‚Äù reset with git reset --soft. This command will not discard the information on the deleted commits as git reset --hard, if not will save all in the staging area in case you would like to create a new commit with those changes. This command is useful if you want to combine a series of local commits into one. Note that git reset --soft is only available in the terminal, and not via JupyterLab."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project",
    "title": "Viewing the history of your project",
    "section": "Viewing the history of a project",
    "text": "Viewing the history of a project\n\nThere are three ways you can view the Git history of a project:\n\nOn GitHub\n\nIn the GitHub web interface through the repo‚Äôs code commit view\n\nOn your computer\n\nIn Jupyter Lab, through the repo‚Äôs code commit view\nIn the terminal, using git log\n\n\nDo you remember the commit messages we learned about in module 3? When reviewing the history of our repository, the commit messages are useful since they help us remember what was modified in each commit. We will outline three alternative ways to look at the history of the entire project.\nLet‚Äôs look closer at each one in the next few slides.\n\nThe material of this chapter is based the course DSCI 521: Computing Platforms for Data Science from the UBC Master of Data Science program."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github",
    "title": "Viewing the history of your project",
    "section": "1. Viewing the history of a project: GitHub",
    "text": "1. Viewing the history of a project: GitHub\n\n\n\nFirst, we will view the history of our project on github.com. On the repository‚Äôs landing page on GitHub, you can click the ‚ÄúN commits‚Äù link marked in red in the slide (where N is the number of commits made on the repo)."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github-1",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github-1",
    "title": "Viewing the history of your project",
    "section": "1. Viewing the history of a project: GitHub",
    "text": "1. Viewing the history of a project: GitHub\n\n\n\nAfter clicking the ‚ÄúN commits‚Äù link, we can see that there are only three commits in this project. You can identify all parts of each commit, including the day it was made, its author, and hash. You can also go back to browse the state of the repository at the time of this commit by clicking the &lt;&gt; button."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-jupyter-lab",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-jupyter-lab",
    "title": "Viewing the history of your project",
    "section": "2. Viewing the history of a project: Jupyter Lab",
    "text": "2. Viewing the history of a project: Jupyter Lab\n\n\n\nIn JupyterLab, you can access the history of your project by looking in the ‚ÄúHistory‚Äù tab within the Git extension side panel (as we did in the previous module). In this view, we can see the same information as we could online: the time when the commit was made, its author, and hash."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal",
    "title": "Viewing the history of your project",
    "section": "3. Viewing the history of a project: the Terminal",
    "text": "3. Viewing the history of a project: the Terminal\n\n\n\nYou can use the command git log to view your project‚Äôs history in the terminal. In this slide, we‚Äôve indicated with a red line how the three commits in the git log output correspond to the information in Jupyter Lab‚Äôs ‚ÄúHistory‚Äù tab.\nIt is important to note that git log output shows the long version of the commit hash, not the 7-character version that is displayed by default in Jupyter Lab or GitHub. Except your project is extremely large, Git won‚Äôt require more than 7 characters to identify the commit. In consequence, if you need the commit hash and you are using the terminal, you can only copy and paste the first 7 hash characters of the commit."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal-1",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal-1",
    "title": "Viewing the history of your project",
    "section": "3. Viewing the history of a project: the Terminal",
    "text": "3. Viewing the history of a project: the Terminal\n\n\n\nAnother option is adding the flag --oneline to the command git log. The command git log --oneline will provide a more succinct version of the information in each commit. This is often more convenient as it is easier to digest and get an overview of the project history, but it can be tedious to type out each time. Here it would be good to create a shell alias, which we learned about in module 2! Executing alias gl=\"git log --oneline\" means that we can simply type gl each time we want to view the git log output. Refer to module 2 for more details around aliases and how to make them persist through reboots.\nThe terminal allows greater flexibility when it comes to displaying the history of the project. If you would like to know what other possibilities you have for using the git log command, you can access the help by typing the command git log --help (any operating system) or man git log (MacOS and Linux)."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-1",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-1",
    "title": "Viewing the history of your project",
    "section": "Viewing the history of a project",
    "text": "Viewing the history of a project\n\nOn GitHub\n\nOn GitHub through the repo‚Äôs code commit view ‚úîÔ∏è\n\nOn your computer\n\nIn Jupyter Lab through the repo‚Äôs code commit view ‚úîÔ∏è\nIn the terminal using git log ‚úîÔ∏è\n\n\nWe have covered three distinct methods for viewing your project‚Äôs history. Prior to starting the multiple choice questions below, give these commands a try yourself in an example Git repository!"
  },
  {
    "objectID": "modules/module4/module4-13-what_did_we_just_learn.html",
    "href": "modules/module4/module4-13-what_did_we_just_learn.html",
    "title": "7. What did we just learn?",
    "section": "",
    "text": "7. What did we just learn?\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "7. What did we just learn?"
    ]
  },
  {
    "objectID": "modules/module4/module4-11-.gitgnore.html",
    "href": "modules/module4/module4-11-.gitgnore.html",
    "title": "6. .gitgnore",
    "section": "",
    "text": "6. .gitgnore\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "6. .gitgnore"
    ]
  },
  {
    "objectID": "modules/module4/module4-09-deal_with_merge_conflicts.html",
    "href": "modules/module4/module4-09-deal_with_merge_conflicts.html",
    "title": "5. Deal with merge conflicts",
    "section": "",
    "text": "5. Deal with merge conflicts\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "5. Deal with merge conflicts"
    ]
  },
  {
    "objectID": "modules/module4/module4-07-revert_changes_made_to_your_git_project.html",
    "href": "modules/module4/module4-07-revert_changes_made_to_your_git_project.html",
    "title": "4. Revert changes made to your Git project",
    "section": "",
    "text": "4. Revert changes made to your Git project\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "4. Revert changes made to your Git project"
    ]
  },
  {
    "objectID": "modules/module4/module4-05-reset_your_git_project_to_an_earlier_state.html",
    "href": "modules/module4/module4-05-reset_your_git_project_to_an_earlier_state.html",
    "title": "3. Reset your Git project to an earlier state",
    "section": "",
    "text": "3. Reset your Git project to an earlier state\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "3. Reset your Git project to an earlier state"
    ]
  },
  {
    "objectID": "modules/module4/module4-03-comparing_commits.html",
    "href": "modules/module4/module4-03-comparing_commits.html",
    "title": "2. Comparing commits",
    "section": "",
    "text": "2. Comparing commits\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "2. Comparing commits"
    ]
  },
  {
    "objectID": "modules/module4/module4-01-viewieng_the_history_of_your_project.html",
    "href": "modules/module4/module4-01-viewieng_the_history_of_your_project.html",
    "title": "1. Viewieng the history of your project",
    "section": "",
    "text": "1. Viewieng the history of your project\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "1. Viewieng the history of your project"
    ]
  },
  {
    "objectID": "modules/module3/slides/module3_13.html#module-learning-outcomes",
    "href": "modules/module3/slides/module3_13.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 3",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nDifferentiate between the use of GitHub as a remote hosting service for version control and Git as a version control system.\nIdentify a Git repository.\nImplement Git‚Äôs clone, add, status, commit, pull, and push operations on the command line and their equivalent use in the JupyterLab IDE.\nUnderstand what it implies to use the staging area in a Git workflow.\nUse commits as the primary building block for storing project versions together with an attached message and a unique identifier.\n\n\nIt is now time to put into practice everything we have learned!"
  },
  {
    "objectID": "modules/module3/slides/module3_09.html#pushing-the-changes-to-github",
    "href": "modules/module3/slides/module3_09.html#pushing-the-changes-to-github",
    "title": "Pushing changes to a remote repository",
    "section": "Pushing the changes to GitHub",
    "text": "Pushing the changes to GitHub\n  \n\n\nOnce you have made one or more commits that you want to share with your collaborators, you need to push (i.e., send/upload) those commits back to GitHub. This updates the history in the remote repository (i.e., GitHub) to match what you have in your local repository. Now when collaborators interact with the remote repository, they will be able to see the changes you made. You can also take comfort in the fact that your work is now backed up in the cloud!"
  },
  {
    "objectID": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-jupyter-lab-ide",
    "href": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-jupyter-lab-ide",
    "title": "Pushing changes to a remote repository",
    "section": "Pushing the commits to GitHub (Jupyter Lab IDE)",
    "text": "Pushing the commits to GitHub (Jupyter Lab IDE)\n  \n\n\nüôå Practice\nClick the ‚ÄúPush‚Äù button\nTo push your staged and committed changes to GitHub, first open the Git extension in Jupyter Lab and press push button (click on the cloud icon with the up arrow on the Jupyter Git tab which is circled in red in this slide).\nIf everything went well, you will read a message on the screen informing you that the push was successful."
  },
  {
    "objectID": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-jupyter-lab-ide-1",
    "href": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-jupyter-lab-ide-1",
    "title": "Pushing changes to a remote repository",
    "section": "Pushing the commits to GitHub (Jupyter Lab IDE)",
    "text": "Pushing the commits to GitHub (Jupyter Lab IDE)\n\n\n\nüôå Practice\nYou can now navigate to the GitHub web interface to see that your changes have been uploaded. There you will see a preview of the commit message, and the time of the most recently pushed commit for each file."
  },
  {
    "objectID": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-terminal",
    "href": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-terminal",
    "title": "Pushing changes to a remote repository",
    "section": "Pushing the commits to GitHub (Terminal)",
    "text": "Pushing the commits to GitHub (Terminal)\n\n\n\nüôå Practice\nWe could also push from the terminal instead of from the Jupyter Lab Git extension. If you would like to push from the terminal you can execute the command git push."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#version-control-workflows",
    "href": "modules/module3/slides/module3_05.html#version-control-workflows",
    "title": "The staging area",
    "section": "Version control workflows",
    "text": "Version control workflows\n\n\nMake a commit of your own changes in the local repository.\nSend your new commits to the remote GitHub repository.\nRetrieve any new changes (that others made) from the remote GitHub repository.\n\n\nWhen you work in a local version-controlled repository, there are generally three additional steps you must take as part of your regular workflow. In addition to working on your files creating, editing, and deleting them as you normally would do, you must also tell Git when to:\n\nMake a commit of your own changes in the local repository.\nSend your new commits to the remote GitHub repository.\nRetrieve any new changes (that others made) from the remote GitHub repository.\n\nIn this section will discuss the first step.\nMaking a commit is at the same time a two step process where you first add the changes to the staging area and then commit them, which saves the differences between the current and previous version of the file together with your message describing what you did. These changes are saved in the hidden .git directory in the Git repository.\nLet‚Äôs learn step by step how to make a commit in your local repository"
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#local-repository-with-changes-to-files",
    "href": "modules/module3/slides/module3_05.html#local-repository-with-changes-to-files",
    "title": "The staging area",
    "section": "Local repository with changes to files",
    "text": "Local repository with changes to files\n\n\nWhen working on files in your local version control repository (e.g., using JupyterLab) and saving your work, these changes will only initially exist in the working directory of the local repository on your computer."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#committing-changes-to-a-local-repository",
    "href": "modules/module3/slides/module3_05.html#committing-changes-to-a-local-repository",
    "title": "The staging area",
    "section": "Committing changes to a local repository",
    "text": "Committing changes to a local repository\n \n\n\nOnce you reach a point that you want Git to keep a record of the current version of your work, you need to commit (i.e., snapshot) your changes. A prerequisite to this is telling Git which files should be included in that snapshot. We call this step adding the files to the staging area.\nNote that the staging area is not a meaningful location on your computer; it is instead a temporary placeholder for these files until they are committed. The benefit of the Git version control system using a staging area is that you can choose to commit changes in only certain files. For example, we could add only the two files that are important to the analysis project (analysis.ipynb and README.md) and not the changes we made to our personal scratch notes for the project (notes.txt)."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#open-git-jupyterlab-ide",
    "href": "modules/module3/slides/module3_05.html#open-git-jupyterlab-ide",
    "title": "The staging area",
    "section": "Open Git (JupyterLab IDE)",
    "text": "Open Git (JupyterLab IDE)\n  \n\n\nüôå Practice\nLet‚Äôs commit the files that are in the staging area\nStep 1. Click Jupyter Git extension icon (circled in red).\nAfter you have cloned the remote repository from GitHub to create a local repository, you can get to work editing, creating, and deleting files. For example, suppose you created a new file named eda.ipynb that you would like to commit to the project history. Our next step is to ‚Äúadd‚Äù this modified file to the staging area (i.e., flag that this is a file with changes we would like to commit). To do this first you have to click the Jupyter Git extension icon on the far left-hand side of JupyterLab."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#specifying-files-to-commit-jupyter-lab-ide",
    "href": "modules/module3/slides/module3_05.html#specifying-files-to-commit-jupyter-lab-ide",
    "title": "The staging area",
    "section": "Specifying files to commit (Jupyter Lab IDE)",
    "text": "Specifying files to commit (Jupyter Lab IDE)\n\n\n\nüôå Practice\nStep 2. Add the files you want to commit to the staging area.\nWe can use the small plus sign (+) to add changes we‚Äôve made to a file to the staging area via JupyterLab. In this screenshot, we are adding the notebook file eda.ipynb to our project‚Äôs staging area (‚Äúeda‚Äù stands for ‚ÄúExploratory Data Analysis‚Äù, and is something we often do at the beginning of our project in order to familiarize ourselves with our dataset).\nNote that if this was the first change we ever made to this file, it would have shown up under the Untracked heading in the side panel, indicating that Git is not yet keeping track of this file. However, in this example, we had already made a previous commit to eda.ipynb, which is why it showed up under the Changed heading in the side panel."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#specifying-files-to-commit-jupyter-lab-ide-1",
    "href": "modules/module3/slides/module3_05.html#specifying-files-to-commit-jupyter-lab-ide-1",
    "title": "The staging area",
    "section": "Specifying files to commit (Jupyter Lab IDE)",
    "text": "Specifying files to commit (Jupyter Lab IDE)\n\n\n\nüôå Practice\nClicking the plus sign (+) moves the file from the Changed heading to the Staged heading, so that Git knows you want a snapshot of its current state as a commit (see image). Now you are ready to commit the changes. When committing it is important to include a (clear and helpful!) message about what was changed so that your collaborators (and future you) know what happened in this commit, something we will learn more about in the next slide deck.\nYou will also notice a eda-checkpoint.ipynb file in the side panel under the Untracked heading. This is a temporary ‚Äúcheckpoint file‚Äù created by Jupyter when you work on eda.ipynb. You generally do not want to add auto-generated files like this one to Git repositories; only add the files you directly create and edit."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#specifying-files-to-commit-terminal",
    "href": "modules/module3/slides/module3_05.html#specifying-files-to-commit-terminal",
    "title": "The staging area",
    "section": "Specifying files to commit (Terminal)",
    "text": "Specifying files to commit (Terminal)\n\n\n\nTo check the status of the files using the terminal (Untracked / Changed / Staged) you can use the command git status.\n\nüôå Practice\nIf you would be using the terminal outside Jupyter Lab, you would not have access to the side panel that shows which files are Untracked, Changed, and Staged. To check the status of all files in your repository using the terminal you can instead use the command git status. In this slide you can see how the different parts of the output from git status corresponds to the Jupyter Lab side panel.\nAn advantage of using this command if you are working in the terminal is that it gives you information on which commands to use to continue your workflow. For example, for files that are under the Changes not staged for commit area, it is suggesred to use the command git add &lt;file&gt; to include them into the staging area.\nChanges not staged for commit:\n   (use \"git add &lt;file&gt;...\" to update what will be committed)\nWe recommend using git status to check the staging area before each commit to ensure you are committing what you think you are."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#specifying-files-to-commit-terminal-1",
    "href": "modules/module3/slides/module3_05.html#specifying-files-to-commit-terminal-1",
    "title": "The staging area",
    "section": "Specifying files to commit (Terminal)",
    "text": "Specifying files to commit (Terminal)\n\n\n\nYou can add multiple files to the staging area with the command git add\n\nüôå Practice\nWhen working in the terminal, you can add multiple files at once by listing them after git add.\nAnother command to use in the terminal is git add -p. This allows you to interactively choose which part of each file to add by answering either y (yes) or n (no) to the messages that prompts you about which parts you want to add to the staging area. This way you can add just some changes in a file, which is helpful when trying to include only the relevant changes in each commit and ensuring that you can describe all your changes in a short commit message."
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-you-use-it",
    "href": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-you-use-it",
    "title": "What is version control, and why should you use it?",
    "section": "What is version control, and why should you use it?",
    "text": "What is version control, and why should you use it?\n\nimage source: ‚ÄúPiled Higher and Deeper‚Äù by Jorge Cham\n\nData analysis projects often require iteration and revision to move from an initial idea to a finished product ready for the intended audience. Without deliberate and conscious effort towards tracking changes made to the analysis, projects tend to become messy.\nThis mess can have serious, negative repercussions on an analysis project, including losing interesting results files that your code cannot reproduce, temporary files with snippets of ideas that are forgotten or not easy to find, mind-boggling file names that make it unclear which is the current working version of the file (e.g., document_final.txt, to_hand_in_final_v2.txt, etc.), and more.\nBeing able to record and view the history of a data analysis project is important for understanding how and why decisions to use one method or another were made, among other things."
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it",
    "href": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it",
    "title": "What is version control, and why should you use it?",
    "section": "What is version control, and why should I use it?",
    "text": "What is version control, and why should I use it?\n\n\n\nWhat does exactly mean to ‚Äúrecord the history of a project‚Äù?\nInstead of creating a new copy for each version of a file with an unwieldy name (as in the image), version control allows you to have a single file and records the changes between the versions.\nMany of you might already have used version control software if you work with Google Docs, Dropbox, or TimeMachine on macOS. These programs, all automatically create versions of your documents and you can then browse through the history."
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it-1",
    "href": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it-1",
    "title": "What is version control, and why should you use it?",
    "section": "What is version control, and why should I use it?",
    "text": "What is version control, and why should I use it?\n\nThis image was created by Scriberia for The Turing Way community and is used under a CC-BY licence.\n\nAdditionally, data analyses are typically completed by teams. This means that files need to be shared across multiple computers, and multiple people often end up editing the project simultaneously. In such a situation, determining who has the latest version of the project and how to resolve conflicting edits‚Äîcan be a real challenge.\nVersion control also facilitates collaboration via tools to share edits with others and resolve conflicting edits. But even if you‚Äôre working on a project alone, you should still use version control. It helps you keep track of what you‚Äôve done, when you did it, and what you‚Äôre planning to do next!"
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it-2",
    "href": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it-2",
    "title": "What is version control, and why should you use it?",
    "section": "What is version control, and why should I use it?",
    "text": "What is version control, and why should I use it?\n  \n\nWe can define version control as the process of keeping a record of changes to documents, including when the changes were made and who made them, throughout the history of their development. It also provides the means both to view earlier versions of the project and to revert changes.\n\n\nWe can define version control as the process of keeping a record of changes to documents, including when the changes were made and who made them, throughout the history of their development. It also provides the means both to view earlier versions of the project and to revert changes.\nThe material of this module is based on the book by Timbers, T., Campbell, T., & Lee, M. (2022). Data science: A first introduction. CRC Press and the course DSCI 521: Computing Platforms for Data Science from the UBC Master of Data Science program"
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#git-and-github",
    "href": "modules/module3/slides/module3_01.html#git-and-github",
    "title": "What is version control, and why should you use it?",
    "section": "Git and GitHub",
    "text": "Git and GitHub\n\n\nGit - Version control system\n\n\n\n\n\n\n\nGitHub - Repository hosting service\n\n\n\n\n\n\n\nTo version control a project, you generally need two things: (1) a version control system and (2) a repository hosting service.\nThe version control system is the software responsible for tracking changes, sharing changes you make with others, obtaining changes from others, and resolving conflicting edits.\nThe repository hosting service is responsible for storing a copy of the version-controlled project online (a repository), where you and your collaborators can access it remotely, discuss issues and bugs, and distribute your final product. For both of these items, there is a wide variety of choices.\nIn this course, we‚Äôll use Git for version control, and GitHub for repository hosting, because both are currently the most widely used platforms."
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#when-should-you-use-a-repository-hosting-service",
    "href": "modules/module3/slides/module3_01.html#when-should-you-use-a-repository-hosting-service",
    "title": "What is version control, and why should you use it?",
    "section": "When should you use a repository hosting service?",
    "text": "When should you use a repository hosting service?\n\n\nGitHub - Repository hosting service\n\n\n\nTechnically you don‚Äôt have to use a repository hosting service. You can, for example, version control a project that is stored only in a folder on your computer‚Äî never sharing it on a repository hosting service.\nBut using a repository hosting service provides a few big benefits, including managing collaborator access permissions, tools to discuss and track bugs, and the ability to have external collaborators contribute work, not to mention the safety of having your work backed up in the cloud.\nSince most repository hosting services now offer free accounts, there are not many situations in which you wouldn‚Äôt want to use one for your project."
  },
  {
    "objectID": "modules/module3/module3-13-what_did_we_just_learn.html",
    "href": "modules/module3/module3-13-what_did_we_just_learn.html",
    "title": "7. What did we just learn?",
    "section": "",
    "text": "7. What did we just learn?\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "7. What did we just learn?"
    ]
  },
  {
    "objectID": "modules/module3/module3-11-pulling_changes_from_a_remote_repository.html",
    "href": "modules/module3/module3-11-pulling_changes_from_a_remote_repository.html",
    "title": "6. PULLing changes from a remote repository",
    "section": "",
    "text": "6. PULLing changes from a remote repository\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "6. PULLing changes from a remote repository"
    ]
  },
  {
    "objectID": "modules/module3/module3-09-pushing_changes_to_a_remote_repository.html",
    "href": "modules/module3/module3-09-pushing_changes_to_a_remote_repository.html",
    "title": "5. PUSHing changes to a remote repository",
    "section": "",
    "text": "5. PUSHing changes to a remote repository\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "5. PUSHing changes to a remote repository"
    ]
  },
  {
    "objectID": "modules/module3/module3-07-committing_changes_to_a_local_repository.html",
    "href": "modules/module3/module3-07-committing_changes_to_a_local_repository.html",
    "title": "4. Committing changes to a local repository",
    "section": "",
    "text": "4. Committing changes to a local repository\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "4. Committing changes to a local repository"
    ]
  },
  {
    "objectID": "modules/module3/module3-05-the_staging_area.html",
    "href": "modules/module3/module3-05-the_staging_area.html",
    "title": "3. The staging area",
    "section": "",
    "text": "3. The staging area\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "3. The staging area"
    ]
  },
  {
    "objectID": "modules/module3/module3-03-version_control_repositories.html",
    "href": "modules/module3/module3-03-version_control_repositories.html",
    "title": "2. Version control repositories",
    "section": "",
    "text": "2. Version control repositories\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "2. Version control repositories"
    ]
  },
  {
    "objectID": "modules/module3/module3-01-what_is_version_control_and_why_should_you_use_it.html",
    "href": "modules/module3/module3-01-what_is_version_control_and_why_should_you_use_it.html",
    "title": "1. What is version control, and why should you use it?",
    "section": "",
    "text": "1. What is version control, and why should you use it?\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "1. What is version control, and why should you use it?"
    ]
  },
  {
    "objectID": "modules/module2/slides/module2_09.html#module-learning-outcomes",
    "href": "modules/module2/slides/module2_09.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 2",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nUse the shell to navigate the computer‚Äôs filesystem\nCreate new files and directories\nMove, copy, and delete files and directories\nUse ‚Äúwildcards‚Äù\nDefine and distinguish between absolute file paths and relative file paths\nRead the shell‚Äôs built-in manual\nCombine commands with pipes\n\n\nThe assignment will concentrate on the learning objectives as well as building knowledge on existing concepts."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#creating-a-directory",
    "href": "modules/module2/slides/module2_05.html#creating-a-directory",
    "title": "Working with files and directories",
    "section": "Creating a directory",
    "text": "Creating a directory\nCreate a directory called ‚Äúnotes‚Äù.\ncd ~/Documents\nmkdir notes\nNaming guidelines\n\nDon‚Äôt use spaces\nDon‚Äôt begin the name with a - (hyphen)\nStick to digits and letters (preferably lower case)\n\n\nLet‚Äôs go back to the ~/Documents directory and create a subfolder called notes. For this we first use the ~ home directory shortcut, and then the mkdir command (MaKe DIRectory).\nWe will talk more about useful naming conventions in Module 6. For now it is enough if you remember these three guidelines.\n\nDon‚Äôt use spaces\nDon‚Äôt begin the name with a - (hyphen)\nStick to digits and letters (preferably lower case)"
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#creating-a-file",
    "href": "modules/module2/slides/module2_05.html#creating-a-file",
    "title": "Working with files and directories",
    "section": "Creating a file",
    "text": "Creating a file\nls -F notes\n \n(The output is empty because there are no files in the newly created directory)\n\ncd notes\ncode my-first-note.md\n\nSince we just created the notes directory, ls doesn‚Äôt display anything when we ask for a listing of its contents.\nLet‚Äôs change our working directory to notes, then use the VS Code editor to create a file called my-first-note.md. The command to invoke VS Code from the command line is code, and if we pass it a filename as an argument, the file will be created in the current directory. Now try launching it yourself!\nThe .md syntax means that we want to create a markdown file. File extensions like .md and .py don‚Äôt change anything about the content of the file, but they are an indicator to other program such as VS Code what type of content we are going to put inside the file. These program can then activate special functions for certain files, such as using the appropriate colors to highlight headings and functions.\nLet‚Äôs move on to the next slide to see how it looks when we are editing file in VS Code."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#editing-a-file-in-vs-code",
    "href": "modules/module2/slides/module2_05.html#editing-a-file-in-vs-code",
    "title": "Working with files and directories",
    "section": "Editing a file in VS Code",
    "text": "Editing a file in VS Code\n\n\nThis is what it looks like to edit a text file in VS Code. You will see that there is a small white circle next to the file name. This is an indication that the file is not saved yet.\nWhen we are done adding our edits, we can hit Ctrl + s to save the file, which will make the white circle disappear. After saving the file, you can optionally close VS Code before returning to the terminal.\nWe are only using VS Code as a simple text editor here, but it is worth knowing that you can use use it as a powerful editor for code as well."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#viewing-the-content-of-a-file-in-the-terminal",
    "href": "modules/module2/slides/module2_05.html#viewing-the-content-of-a-file-in-the-terminal",
    "title": "Working with files and directories",
    "section": "Viewing the content of a file in the terminal",
    "text": "Viewing the content of a file in the terminal\nls\nmy-first-note.md\n\nhead my-first-note.md\nThese are the first\nfew lines of content\nin the file.\n\nIf we now type ls we will see the name of the file we just created in VS Code. To see the content of the file, we can use the head command. head show the first few lines of a file (just as when we use df.head() in pandas), and optionally takes an argument for how many lines to show: head -n 10 (the default is five).\nhead works with all plain text files, such as code and markdown files, but not with binary files such as word documents, spreadsheets, or images. To see the last few lines, you can use tail instead of head."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#moving-files-and-directories",
    "href": "modules/module2/slides/module2_05.html#moving-files-and-directories",
    "title": "Working with files and directories",
    "section": "Moving files and directories",
    "text": "Moving files and directories\nmv my-first-note.md ..\nls ..\nDownloads/    Music/        my-first-note.md\nDocuments/    todo.txt\nPictures/     my_program*\n\nmv ../my-fist-note.md .\nls\nmy-fist-note.md\n\nTo move a file around, we can use the mv command. For example, to move the text file we just created to the parent directory, we would type mv my-first-note.md ... This moves it to the parent directory, and keeps the name the same as we can see if we do ls ..\nIf we want to move the file back to the current directory, we can use the . shortcut: mv ../my-fist-note.md ."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#renaming-a-file",
    "href": "modules/module2/slides/module2_05.html#renaming-a-file",
    "title": "Working with files and directories",
    "section": "Renaming a file",
    "text": "Renaming a file\nmv my-fist-note.md note_2022-06-20.md\nls\nnote_2022-06-20.md\n\nThe -v option prints the name of the moved file\nmv -v notte_2022-06-20.md note_2022-06-20.md\nrenamed 'notte_2022-06-20.md' -&gt; 'note_2022-06-20.md'\n\nRenaming a file can be thought of as moving it to a new filename either in the same or a different directory. This might initially seem a bit different from a graphical file browser, where renaming and moving are two distinct functions, but the underlying operation is actually the same.\nTo give our file a more descriptive name that includes the date we created this file, we would type mv my-fist-note.md notte_2022-06-20.md. We intentionally made a typo here, let‚Äôs fix it while showing off the functionality of the -v (verbose) option, which prints what was moved/renamed so that it is easier to keep track of renamed 'notte_2022-06-20.md' -&gt; 'note_2022-06-20.md'.\nWe must be careful when specifying the destination because mv will overwrite existing files without warning. The option -i (‚Äúinteractive‚Äù) makes mv ask us for confirmation before overwriting,. mv also works on directories where it renames the directory without changing its contents."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#copying-files-and-directories",
    "href": "modules/module2/slides/module2_05.html#copying-files-and-directories",
    "title": "Working with files and directories",
    "section": "Copying files and directories",
    "text": "Copying files and directories\nCopy the file to the parent directory:\ncp note_2022-06-20.md ..\n\nCreate a backup copy in the same directory:\ncp note_2022-06-20.md note_2022-06-20.md.bkp\nls\nnote_2022-06-20.md\nnote_2022-06-20.md.bkp\n\nThe cp command create a CoPy of a file. Just as with mv, we optionally rename the file as we are copying it.\nHere we first copy the note we created to the parent directory and then show how we could use cp to create a backup of our file in the same directory. Remember that the file extension does not change the content of the file, so this is just a visual indicator to us for what type of file this is.\nIf we ever wanted to copy a directory, we would have to specify the -r flag, which indicates that we want to copy the directory recursively, i.e.¬†also making a copy of all the directory contents."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#deleting-files-and-directories",
    "href": "modules/module2/slides/module2_05.html#deleting-files-and-directories",
    "title": "Working with files and directories",
    "section": "Deleting files and directories",
    "text": "Deleting files and directories\nrm note_2022-06-20.md.bkp\nls\nnote_2022-06-20.md\n\nrm -iv ../note_2022-06-20.md\nrm: remove regular file '../note_2022-06-20.md'? y\nremoved '../note_2022-06-20.md'\n\nLet‚Äôs clean things up by removing our backup copy that we just created. The rm commands allows us to ReMove files and folders. In this case we would type rm note_2022-06-20.md.bkp.\nDeleting is forever: unlike most graphical file browsers, the Unix shell doesn‚Äôt have a trash bin that we can recover deleted files from. Just as with mv, we can use the -v to make rm a bit more informative.\nWe can also use the -i flag to make it a bit more safe and ask for confirmation before moving the file. If we want to confirm we type y (for ‚Äúyes‚Äù) and then hit Enter. Let‚Äôs use these flags when removing the copy we placed in the parent directory rm -iv ../note_2022-06-20.md.\nAnd just as with cp, we would need to include the -r flag to recursively remove a directory and all its contents."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#wildcards",
    "href": "modules/module2/slides/module2_05.html#wildcards",
    "title": "Working with files and directories",
    "section": "Wildcards",
    "text": "Wildcards\ntouch note_2022-06-20.md.bkp note_2022-07-02.md note_2022-07-02.md.bkp\nls *.bkp\nnote_2022-06-20.md.bkp\nnote_2022-07-02.md.bkp\n\nls *07*\nnote_2022-07-02.md\nnote_2022-07-02.md.bkp\n\nWildcards (also called ‚Äúglobbing‚Äù) simplifies targeting multiple files with similar names in the same command. The most commonly used wildcard is * (a single asterisk). It matches zero or more characters, so typing ls *.md list all of the markdown files in the current directory.\nLet‚Äôs first create 3 empty files: note_2022-06-20.md.bkp, note_2022-07-02.md and note_2022-07-02.md.bkp using touch command. If we wanted to list all the files created in July (month 7), we would need to type ls ls *07*, which means that the filename can include anything before and after 07. If we would have left out the second * and type ls *07 we would not have seen any matches because there is not file that end in 07, they all have some characters after.\nUsing wildcards is helpful when we want to delete, move, or copy files with a predictable naming pattern."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#what-is-a-computer",
    "href": "modules/module2/slides/module2_01.html#what-is-a-computer",
    "title": "Introduction to the shell",
    "section": "What is a computer?",
    "text": "What is a computer?\nA few of the world‚Äôs most prominent programmers of the time computing ballistic trajectories on the ENIAC computer during the second world war:\n\nUnidentified U.S. Army photographer, Public domain, Mike Muuss‚Äô computer history archive\n\nEssentially, computing is about humans communicating with machines to modulate flows of current in the hardware. Early examples of human computer communication were quite primitive and included physically disconnecting a wire and connecting it again in a different spot.\nLuckily, we are not doing this anymore; instead we have graphical user interfaces with menus and buttons, which is what you are commonly using when interacting with a computer that runs an operating system such as MacOS, Linux, or Windows.\nThese graphical interface can be thought of as a layer (or a shell) around the internal components of your operating system. Shells exist as an intermediate between the human and the machine; they make it easy for us to express our commands, and for computers to interpret them."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#what-is-text-based-communication",
    "href": "modules/module2/slides/module2_01.html#what-is-text-based-communication",
    "title": "Introduction to the shell",
    "section": "What is text-based communication?",
    "text": "What is text-based communication?\nOpen a file from a graphical menu:\n\nOpening a file via a text-based interface:\n\nfile.open('filename.csv')\n\n\nIn this slide deck, we will learn how to communicate with a computer via a text-based shell, rather than a graphical one.\nUsing a text-based shell might at first seems counter-intuitive, since the reason for creating a shell in the first place was to facilitate user interaction with the computer. So now that we have these easy to use graphical user interfaces (GUIs), why would anyone in their right mind go back to using a text based interface?\nWell, this notion is partly a misconception; GUIs can be nice when you are new to something, but text-based interfaces are actually faster and easier to use when you become more experienced and know more precisely which commands you want the machine to execute.\nWe can compare this process to learning a language: in the beginning it‚Äôs nice to look things up in a dictionary (analogous to the menu on a computer), but once we know what we want to say, it is just easer to say or type it directly, instead of being forced to spend time on looking it up first.\nBy extension, it would be even faster to speak or even just think of what you want to do and have the appropriate commands executed by the computer. This is what speech-and brain-computer interfaces are concerned with, and once these becomes more refined and accessible they might take over as the main way for us to interact with computers."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#which-shell-will-we-be-using",
    "href": "modules/module2/slides/module2_01.html#which-shell-will-we-be-using",
    "title": "Introduction to the shell",
    "section": "Which shell will we be using?",
    "text": "Which shell will we be using?\nThe Bash logo:\n\n\nBash is the most commonly used text shell. You have it installed on your computer by default if you are using a Mac or Linux machine, and if you are on a Windows machine you downloaded Bash as part of the setup instructions.\nAs we mentioned in the introduction module, the abbreviation BASH stands for ‚ÄúBourne Again SHell‚Äù. Other shells existed before Bash, and one of the most successful early shells was invented by Stephen Bourne at Bell Labs in 1977, which he called the Bourne Shell. In 1989, the Free Software Foundation improved the Bourne Shell and as a pun named it the Bourne Again Shell, to symbolize it was now ‚Äúreborn‚Äù with new features.\nText-based shells are sometimes called command-line interfaces (CLI, or just ‚Äúthe command line‚Äù) and at the heart of every CLI is a read-evaluate-print loop (REPL). When we type a command and press Return (also called Enter) the CLI reads the command, evaluates it (i.e., executes it), prints the command‚Äôs output, and loops around to wait for another command.\nLet‚Äôs see how to do that next!"
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#how-do-we-open-bash-on-our-computer",
    "href": "modules/module2/slides/module2_01.html#how-do-we-open-bash-on-our-computer",
    "title": "Introduction to the shell",
    "section": "How do we open Bash on our computer?",
    "text": "How do we open Bash on our computer?\nExecuting the shell command jupyter lab:\n\n\nThe JupyterLab landing page:\n\n\nTo run a shell such a Bash, we need to use a Terminal Emulator, or just ‚ÄúTerminal‚Äù for short. Most operating systems have one built-in, on MacOS it is called Terminal.app, and on Linux it is usually just called Terminal. On Windows, you could use the terminal application that comes with Git Bash that you installed in Assignment 1, the ‚ÄúAnaconda Prompt‚Äù application, or the newer ‚ÄúWindows Terminal‚Äù application.\nOpen the respective terminal application for the operating system you are using by browsing your applications menu or searching for the name of the terminal application.\nOne common thing we can use the shell for is a launcher for other applications. The first thing we are going to do is to learn how to launch JupyterLab, which we will use for the rest of this course.\nTo launch JupyterLab, execute the jupyter lab command by typing it into your shell and pressing Enter. You will see some output similar to the screenshot at the top of this slide. After a few seconds, you should see a browser window open with the Jupyter Launcher page similar to the screenshot at the bottom of this slide."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#how-do-we-open-bash-from-jupyterlab",
    "href": "modules/module2/slides/module2_01.html#how-do-we-open-bash-from-jupyterlab",
    "title": "Introduction to the shell",
    "section": "How do we open Bash from JupyterLab",
    "text": "How do we open Bash from JupyterLab\nOpening a terminal from JupyterLab:\n\n\nAn open JupyterLab terminal with black background:\n\n\nSince there is a default terminal application on each operating system, we will be showing how to use Bash via the JupyterLab terminal in this course. Using the terminal application within JupyterLab gives us access to the same shell commands as if we would run the default terminal application on our operating system. The JupyterLab terminal also ensures that the experience is similar across all three operating systems, but you are free to use any terminal to follow along.\nTo open the JupyterLab terminal, go to File -&gt; New -&gt; Terminal as in the screenshot in this slide.\nThe JupyterLab terminal that opens will look slightly different depending on which operating system you are using and what its default terminal settings are. If you want to switch between dark and light backgrounds, you can go to Settings -&gt; Theme and chose either JupyterLab Light or JupyterLab Dark."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#your-first-words-in-bash",
    "href": "modules/module2/slides/module2_01.html#your-first-words-in-bash",
    "title": "Introduction to the shell",
    "section": "Your first words in Bash",
    "text": "Your first words in Bash\nThe default prompt character:\nusername@computer $\n\nTyping in the whoami command for showing your username and pressing enter to run it:\nwhoami\nusername\n\nNow that we know how to open the terminal and JupyterLab, let‚Äôs explore some commands in the Bash shell! Our first shell commands will let us explore our folders and files, and will also introduce us to several conventions that most command line tools follow.\nTo start, you will have noticed that when the Terminal with Bash launches it presents us with a blinking line or block. This is called the ‚Äúprompt‚Äù because the blinking is prompting us to enter a command.\nThe default character that is used to represent the prompt is a dollar sign ($). However, different shells may use a different symbol: in particular, the zsh shell, which is the default on newer versions of MacOS, uses %.\nBefore the dollar sign, we can see our username and computer name printed, but this might look different for you depending on your operating systems and settings.\nLet‚Äôs run our first command! By typing in whoami and pressing Enter, the computer will tell us who we are by displaying our username.\nNext, let‚Äôs move on to something more useful and find out which directory we are in!"
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#where-are-we",
    "href": "modules/module2/slides/module2_01.html#where-are-we",
    "title": "Introduction to the shell",
    "section": "Where are we?",
    "text": "Where are we?\nThe pwd command stands for Print Working Directory.\npwd\n# Linux\n/home/username\n\n# MacOS\n/Users/username\n\n# Windows\n/c/Users/username\n\nThe shell is like a file browser in the sense that we are always inside a directory. When we launch the shell, it puts us inside our home directory by default. Each user on the computer has a separate home directory and the function and location of this directory differs a little bit between operating systems.\nTo view which directory we are currently in we can execute the command pwd (Print Working Directory). Since the home directory differs between operating system, what the shell return when we type pwd inside our home directory will depend on which operating system we are using.\nOn Linux the home directory is usually /home/username, on MacOS it is /Users/username, and on Windows it will show up as /c/Users/username (if you have Git Bash installed). Our examples in this module shows the Linux directory structure, but you will see that some of the other modules show what we would see on MacOS or Windows.\nIn general it is enough to be familiar with the directory structure on your machine, but if you ever work on a shared cloud computer to get access to more computing resources, it is important to also be familiar with the Linux directory structure since most cloud computers run Linux."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#exploring-the-filesystem",
    "href": "modules/module2/slides/module2_01.html#exploring-the-filesystem",
    "title": "Introduction to the shell",
    "section": "Exploring the filesystem",
    "text": "Exploring the filesystem\nls\nDownloads     Music\nDocuments     todo.txt\nPictures      my_program\n\nNow that we know where we are, let‚Äôs see what this directory contains by using the command ls (short for ‚Äúlisting‚Äù), which prints the names of the files and directories in the current directory. Again, our results may be different depending on our operating system and what files or directories we have created previously.\nIn our example in the slide, we have one file with a txt extension which indicates that this files contains text, and we have five files without an extension (some of these appear to be directories, but we can‚Äôt know for sure from this output)."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#using-commands-with-options",
    "href": "modules/module2/slides/module2_01.html#using-commands-with-options",
    "title": "Introduction to the shell",
    "section": "Using commands with options",
    "text": "Using commands with options\nls -F\nDownloads/    Music/\nDocuments/    todo.txt\nPictures/     my_program*\n\nWe can make the output of ls more informative by using the -F option (a command option is sometimes called a ‚Äúswitch‚Äù or a ‚Äúflag‚Äù). Options modify the behavior of the command.\nIn this case, -F tells ls to decorate the printed output to indicate what type of file each entry is. A trailing / (‚Äúslash‚Äù) indicates a directory, while a trailing * (‚Äúasterisk‚Äù) tells us that the file is a runnable program. Depending on our setup, the shell might also use colors to indicate what type of file or directory each entry is."
  },
  {
    "objectID": "modules/module2/module2-09-what_did_we_just_learn.html",
    "href": "modules/module2/module2-09-what_did_we_just_learn.html",
    "title": "5. What did we just learn?",
    "section": "",
    "text": "5. What did we just learn?\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "5. What did we just learn?"
    ]
  },
  {
    "objectID": "modules/module2/module2-07-intermediate_shell_topics.html",
    "href": "modules/module2/module2-07-intermediate_shell_topics.html",
    "title": "4. Intermediate shell topics",
    "section": "",
    "text": "4. Intermediate shell topics\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "4. Intermediate shell topics"
    ]
  },
  {
    "objectID": "modules/module2/module2-05-working_with_files_and_directories.html",
    "href": "modules/module2/module2-05-working_with_files_and_directories.html",
    "title": "3. Working with files and directories",
    "section": "",
    "text": "3. Working with files and directories\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "3. Working with files and directories"
    ]
  },
  {
    "objectID": "modules/module2/module2-03-moving_around.html",
    "href": "modules/module2/module2-03-moving_around.html",
    "title": "2. Moving around",
    "section": "",
    "text": "2. Moving around\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "2. Moving around"
    ]
  },
  {
    "objectID": "modules/module2/module2-01-introduction_to_the_shell.html",
    "href": "modules/module2/module2-01-introduction_to_the_shell.html",
    "title": "1. Introduction to the shell",
    "section": "",
    "text": "1. Introduction to the shell\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "1. Introduction to the shell"
    ]
  },
  {
    "objectID": "modules/module1/slides/module1_07.html#module-learning-outcomes",
    "href": "modules/module1/slides/module1_07.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 1",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nExplain why it is important to use the right tool for the job.\nName the tools in the data science toolbox and explain their main purposes.\nDescribe the different components of the JupyterLab interface.\nAsk effective questions.\nCreate minimal reproducible code examples when asking for help.\n\n\nThe assignment will concentrate on the learning objectives as well as building knowledge on existing concepts."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#project-jupyter",
    "href": "modules/module1/slides/module1_03.html#project-jupyter",
    "title": "How to use JupyterLab",
    "section": "Project Jupyter",
    "text": "Project Jupyter\n\nMain goals of Project Jupyter:\n\nProviding an ecosystem for interactive data science projects\nBeing language agnostic: support most popular programming languages\n\n\n\nThe name ‚ÄúJupyter‚Äù -&gt; ‚ÄúJulia‚Äù + ‚ÄúPython‚Äù + ‚ÄúR‚Äù\n\n\nProject Jupyter‚Äôs foundation is the interactive Python project (‚ÄúIPython‚Äù), which was started by a Colombian graduate student in physics back in 2001 with the goal of create an easier to use Python environment for scientific computing. In 2014, the notebook interface was first introduced and this part of the project was renamed to Jupyter to indicate that it supported more programming languages than just Python. The main goals of Project Jupyter are to provide an ecosystem for interactive data science projects and to support multiple popular programming languages.\nThe name ‚ÄúJupyter‚Äù is a combination of ‚ÄúJulia‚Äù (popular scientific computing language), ‚ÄúPython‚Äù, and ‚ÄúR‚Äù (popular statistical analysis tool)."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#jupyterlab",
    "href": "modules/module1/slides/module1_03.html#jupyterlab",
    "title": "How to use JupyterLab",
    "section": "JupyterLab",
    "text": "JupyterLab\n\n\nJupyterLab is a browser-based interactive development environment\nYou can work with various types of documents in JupyterLab\nThe main document type used with JupyterLab is Jupyter notebook\n\n\nJupyterLab is an interactive development environment (IDE) that enables you to work with documents and activities such as Jupyter notebooks, text editors, terminals, and custom components in a flexible, integrated, and extensible manner.\nThe main document type that is most commonly used in JupyterLab is the Jupyter notebook.\nOne of the core strengths of Jupyter notebooks is that they enable you to combine narrative text with interactive, executable code and its output all in one place.\nWe‚Äôll talk about Jupyter notebooks in more detail in Module 7."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#the-jupyterlab-interface",
    "href": "modules/module1/slides/module1_03.html#the-jupyterlab-interface",
    "title": "How to use JupyterLab",
    "section": "The JupyterLab interface",
    "text": "The JupyterLab interface\nAfter running jupyter lab, a browser window should open with JupyterLab‚Äôs interface:\n\n\nIn previous courses in this data science specialization, you have been running JupyterLab via a web server, without installing anything on your computer.\nAs part of assignment 1 in this course, you will be installing JupyterLab on your own machine. After you have installed it, you can launch JupyterLab by running the command jupyter lab from a terminal (more on terminals in the first assignment instructions and in Module 2).\nWhen JupyterLab launches, you‚Äôre going to see the ‚ÄúLauncher‚Äù tab, which allows you to create various new working environments."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#the-jupyterlab-interface-1",
    "href": "modules/module1/slides/module1_03.html#the-jupyterlab-interface-1",
    "title": "How to use JupyterLab",
    "section": "The JupyterLab interface",
    "text": "The JupyterLab interface\n\n\nJupyterLab is equipped with a lot of features in traditional IDE‚Äôs such as PyCharm and VS Code. However, JupyterLab is geared towards interactive and exploratory computations.\nThe JupyterLab interface mainly consists of a main work area, and a left sidebar which are marked out in this slide. You‚Äôll spend most of your time using these two elements of the JupyterLab interface for various tasks and we will explore both of them in detail in the next slides."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#the-left-sidebar",
    "href": "modules/module1/slides/module1_03.html#the-left-sidebar",
    "title": "How to use JupyterLab",
    "section": "The left sidebar",
    "text": "The left sidebar\n\n\nHere you can see various tabs of the left sidebar:\n\n(1): This tab is the file explorer, which you can use to navigate your file system, open the files you‚Äôre looking for, or even create and rename files and much more. You can right-click on any file or folder to see available options.\n(2): This is the running terminals and kernels tab. Here you can see all open tabs in the working area, as well as all running kernels. A kernel is a running language engine connected to your notebooks. We‚Äôll learn more about these later in the course.\n(3): This is the Git extension tab. You will be using this extensively in modules 3-5 to version-control your repositories.\n(4): This is your table of contents tab. Whenever you insert Markdown headings to your notebooks, they will automatically show up here and will help you easily jump to any specific section of your notebook. You can also show code cells in the table of contents and expand and collapse sections to get a quick overview of your notebook.\n\nThere is also an Extension Manager tab which we will talk about in more detail in Module 7."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#the-main-work-area",
    "href": "modules/module1/slides/module1_03.html#the-main-work-area",
    "title": "How to use JupyterLab",
    "section": "The main work area",
    "text": "The main work area\n\n\nThe main work area is where all your working windows reside. Here for example, we have opened:\n\na notebook,\nan image file,\nan IPython console, and\na terminal.\n\nThe content of each window, as well as the toolbars (and whether or not you get one!) depends on the type of the file you opened (e.g.¬†notebook, image, PDF), and the type of the window (e.g.¬†whether it‚Äôs a console or a terminal).\nYou can resize the windows as you wish and change their arrangement by dragging the grey margin area between them.\nYou can also drag and drop a tab to another window to make it part of that window, or you can do the reverse."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#simple-mode",
    "href": "modules/module1/slides/module1_03.html#simple-mode",
    "title": "How to use JupyterLab",
    "section": "Simple mode",
    "text": "Simple mode\n\n\nIf you want to maximize a particular open tab so that you can focus on it, you can do so by\n\nfirst clicking the tabs title bar to activate it (note the thin blue bar appearing at above the title when you activate a tab),\nthen clicking the ‚ÄúSimple‚Äù toggle button which is located on the lower left part of the JupyterLab‚Äôs interface in the status bar.\n\nHere, I have focused on my notebook tab."
  },
  {
    "objectID": "modules/module1/slides/module1_00.html#module-learning-outcomes",
    "href": "modules/module1/slides/module1_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nExplain why it is important to use the right tool for the job.\nName the tools in the data science toolbox and explain their main purposes.\nDescribe the different components of the JupyterLab interface.\nAsk effective questions.\nCreate minimal reproducible code examples when asking for help.\n\n\nIn this module we will be introduced to the data science tools that we will be practicing with in this course and learn how to ask effective questions."
  },
  {
    "objectID": "modules/module1/module1-00-module_learning_outcomes.html",
    "href": "modules/module1/module1-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M1. Introduction to the Data Science Toolbox**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/index.html",
    "href": "modules/index.html",
    "title": "Welcome to The Data Science Toolbox!",
    "section": "",
    "text": "Welcome to The Data Science Toolbox!\nThis course is part of the Key Capabilities for Data Science program and covers topics related to workflows, plateforms and tools used in data analysis.\nIn this course, we will dive into the world of data science tools and utilities. While these are not strictly required for data analysis, they are necessary for efficient, reproducible, and collaborative data science practices, and are all important building blocks for a successful and sustained data science career.\nCourse prerequisites: Programming in Python for Data Science",
    "crumbs": [
      "**M0. Welcome to The Data Science Toolbox!**",
      "0. Welcome!"
    ]
  },
  {
    "objectID": "modules/module0/module0-01-the_data_science_toolbox.html",
    "href": "modules/module0/module0-01-the_data_science_toolbox.html",
    "title": "1. The Data Science Toolbox",
    "section": "",
    "text": "1. The Data Science Toolbox\n\nVideoSlides",
    "crumbs": [
      "**M0. Welcome to The Data Science Toolbox!**",
      "1. The Data Science Toolbox"
    ]
  },
  {
    "objectID": "modules/module0/slides/module0_01.html#course-learning-outcomes",
    "href": "modules/module0/slides/module0_01.html#course-learning-outcomes",
    "title": "Welcome!",
    "section": "Course Learning Outcomes",
    "text": "Course Learning Outcomes\nBy the end of the course, students are expected to be able to:\n\nExplain why it is important to use the right tool for the job.\nCommunicate with the computer via a text-based shell.\nWork with projects under version control using Git and GitHub.\nUse additional version control features such as git history, reverting repositories to a previous state, and resolving with merge conflicts.\nCollaborate with Git and GitHub by using branches, forks and pull requests.\nOrganize coding projects with proper file names, folder structures, and virtual environments.\nWork more effectively with JupyterLab.\nBuild books and create websites using Jupyter Book."
  },
  {
    "objectID": "modules/module0/slides/module0_01.html#prerequisites",
    "href": "modules/module0/slides/module0_01.html#prerequisites",
    "title": "Welcome!",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nThis course does not have any formal prerequisites, but it is recommended that you have some experience with Jupyter Notebooks and JupyterLab, either from your own projects or the course Programming in Python for Data Science"
  },
  {
    "objectID": "modules/module1/module1-01-introduction_to_the_data_science_toolbox.html",
    "href": "modules/module1/module1-01-introduction_to_the_data_science_toolbox.html",
    "title": "1. Introduction to the Data Science Toolbox",
    "section": "",
    "text": "1. Introduction to the Data Science Toolbox\n\nVideoSlides",
    "crumbs": [
      "**M1. Introduction to the Data Science Toolbox**",
      "1. Introduction to the Data Science Toolbox"
    ]
  },
  {
    "objectID": "modules/module1/module1-03-how_to_use_jupyterlab.html",
    "href": "modules/module1/module1-03-how_to_use_jupyterlab.html",
    "title": "2. How to use JupyterLab",
    "section": "",
    "text": "2. How to use JupyterLab\n\nVideoSlides",
    "crumbs": [
      "**M1. Introduction to the Data Science Toolbox**",
      "2. How to use JupyterLab"
    ]
  },
  {
    "objectID": "modules/module1/module1-05-asking_effective_questions.html",
    "href": "modules/module1/module1-05-asking_effective_questions.html",
    "title": "3. Asking Effective Questions",
    "section": "",
    "text": "3. Asking Effective Questions\n\nVideoSlides",
    "crumbs": [
      "**M1. Introduction to the Data Science Toolbox**",
      "3. Asking Effective Questions"
    ]
  },
  {
    "objectID": "modules/module1/module1-07-what_did_we_just_learn.html",
    "href": "modules/module1/module1-07-what_did_we_just_learn.html",
    "title": "4. What Did We Just Learn?",
    "section": "",
    "text": "4. What Did We Just Learn?\n\nVideoSlides",
    "crumbs": [
      "**M1. Introduction to the Data Science Toolbox**",
      "4. What Did We Just Learn?"
    ]
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#using-the-right-tool-for-the-job",
    "href": "modules/module1/slides/module1_01.html#using-the-right-tool-for-the-job",
    "title": "Introduction to the Data Science Toolbox",
    "section": "Using the right tool for the job",
    "text": "Using the right tool for the job\n\n\nKnowing which tools to use and how to use them effectively is a fundamental skill in many professions.\nFor example, imagine that you are trying to drive in a screw using a coin instead of a screwdriver. The process of driving in the screw would be less efficient and more laborious than it needs to be. Using a coin as a screwdriver might be acceptable in an emergency situation,but you would not want it to be part of your everyday workflow.\nNow imagine that instead of a coin, you were using a knife to drive in a screw. This will not only be inefficient, but slipping with the knife could cause significant personal injury!\nIn these examples, it is easy to see why using the right tool for the job is both the most efficient and safest option. Even when learning how to use the right tool could that take some time, the effort is worthwhile since it would give you increased efficiency and safety.\nFor tasks that are less hands-on or that does not give immediate negative feedback when something goes wrong, it can be harder to realize the negative consequences of a suboptimal tool choice. A prime example of this is when doing data analysis, where it can be tempting to reach for tools that are familiar instead of critically assessing which is the safest and most effective tool for the job. For a budding data scientist, it can be tricky to understand the long term consequences of using the wrong tool, but failing to do can lead to dire ramifications as we will see in the next slide."
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#the-consequences-of-using-the-wrong-tool",
    "href": "modules/module1/slides/module1_01.html#the-consequences-of-using-the-wrong-tool",
    "title": "Introduction to the Data Science Toolbox",
    "section": "The consequences of using the wrong tool",
    "text": "The consequences of using the wrong tool\n\n\nIn the most benign of cases, working with a less effective toolbox will be a waste of your and your employers time. A good example of this is when people repeatedly carry out tasks manually, instead of automating them which often happens when using a tool such as Excel for data analysis, instead of a programming language like Python.\nThe consequences of using the wrong tool in data science could also be more severe. A striking example of this is how cancer patients were put at risk in incorrectly administered clinical trials, based on research that had several errors introduced when using the wrong tools for data analysis. These errors were not discovered until several years later and they led to that the trials were terminated, around 25 scientific papers related to these trials were retracted, and the lead investigators were put under investigation for malpractice.\nAnother example from a couple of years ago is how the opening of a new expensive hospital was delayed because there had been an error when copying values between spreadsheet; something that could have been avoided if programmatic tools with automatic sanity checks would have been used instead (if you are interested in more details and examples on inappropriate tool use, refer to section 2.1 and 2.2 in one of our recently published papers).\nAlthough the use of improper tools and practices can lead to such negatively impactful real-life outcomes, there are few courses that focus on teaching toolbox skills to data scientists, and in many cases data scientists are expected to figure out what is effective for themselves. This is both inefficient and can lead to unfortunate and easily avoided mistakes.\nIn this course, we learn which tools to use and how to use them to facilitate they are necessary for efficient, reproducible, and collaborative data science practices, which are all important building blocks for a successful and sustained data science career.\nLet‚Äôs briefly introduce the tools in the toolbox, starting with the shell!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#the-shell-bash",
    "href": "modules/module1/slides/module1_01.html#the-shell-bash",
    "title": "Introduction to the Data Science Toolbox",
    "section": "The Shell (Bash)",
    "text": "The Shell (Bash)\n\n\n\nNavigate the filesystem\nLaunch programs\nAutomation of tasks\n\n\nThe first tool we will learn about is the shell. A shell can use to navigate our computers file system, launch programs, and automate tasks via the shell‚Äôs own programming language.\nYou can think of it as a much more powerful version of your default graphical file browser. The specific shell that we will learn more about in this course is called Bash. Bash stands for ‚ÄúThe Bourne Again Shell‚Äù; the name was chosen as a pun to indicate that it was a rebirth with many new features compared to its predecessor ‚ÄúThe Bourne Shell‚Äù (named after its creator Stephen Bourne).\nWe will learn more about the shell in Module 2!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#git-and-github",
    "href": "modules/module1/slides/module1_01.html#git-and-github",
    "title": "Introduction to the Data Science Toolbox",
    "section": "Git and GitHub",
    "text": "Git and GitHub\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVersion control\nCollaboration\nCommunication\n\n\nGit is a program that runs on your computer and allows you to keep track of historic versions of your files. This version control is similar to how ‚ÄúTrack Changes‚Äù works in word processors, but much more elaborate and powerful.\nGitHub is an online platform where developers and data scientists can collaborate on their Git-based projects by raising issues, discuss features, and review code.\nGit and GitHub are used widely in both companies and hobby projects. They are the most common ways of collaborating on code and making sure that it easy to keep track of changes in code bases even as they grow large and are managed by multiple people.\nYou will learn more about Git and GitHub in modules 3-5!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#conda",
    "href": "modules/module1/slides/module1_01.html#conda",
    "title": "Introduction to the Data Science Toolbox",
    "section": "Conda",
    "text": "Conda\n\n\nInstalling programs and packages (Python, R, and more)\nManaging software versions\nSeparating software that requires different environments\n\n\nconda is a package manager, which provides a convenient way to install programs and packages. While there exist package managers that are tailor-made for programming language such as R and Python or for specific operating systems, Conda is the most widely use package manager that is both cross-platform (works on different operating systems) and allows you to install packages from many programming languages.\nConda also allows us to keep different programs separate, so that there are not conflicts when two programs requires different versions of the same software. This is called virtual environments, and we will learn more about it and other Conda features in Module 6!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#jupyterlab-and-vs-code",
    "href": "modules/module1/slides/module1_01.html#jupyterlab-and-vs-code",
    "title": "Introduction to the Data Science Toolbox",
    "section": "JupyterLab and VS Code",
    "text": "JupyterLab and VS Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEdit text and code files\nDevelop interactive notebooks\nCreate and view data visualizations\nGenerate reports\n\n\nAs a soft prerequisite for this course, we recommend you to already be familiar with using JupyterLab to edit Jupyter notebooks. Notebooks are powerful since they allow us to combine code, text, and rich output such as data visualizations.\nIn this course we will see some more advanced features of JupyterLab, such as how to use it with Git for version control, and also introduce you to another commonly used tool for programming: VS Code.\nVS Code is a more traditional programming environment than JupyterLab and in this course we will use it for editing text files and for some aspects of version control with Git.\nWe will learn more about VS Code during the shell and version control modules, and we will look closer at advanced JupyterLab features in Module 7!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#jupyter-book-and-markdown",
    "href": "modules/module1/slides/module1_01.html#jupyter-book-and-markdown",
    "title": "Introduction to the Data Science Toolbox",
    "section": "Jupyter Book and Markdown",
    "text": "Jupyter Book and Markdown\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate websites, books, and documentation\nAllows for code execution and interaction\nContent is written in Jupyter Notebooks and text files\n\n\nJupyter Book is an open source project for building beautiful, publication-quality books and documents. The books allow for code to be executed and for visualizations to be interacted with.\nContent for Jupter Book is written in Jupyter Notebooks and text files, using Markdown syntax. In this course, we will go beyond the simple examples of using Markdown for text formatting and extend that syntax to involve more advanced features which are helpful when authoring a book or web page with Jupyter Book.\nModule 8 will introduce you to how to use Jupyter Book!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#a-commitment-to-open-source",
    "href": "modules/module1/slides/module1_01.html#a-commitment-to-open-source",
    "title": "Introduction to the Data Science Toolbox",
    "section": "A commitment to open source",
    "text": "A commitment to open source\n\n\nBeing able to use the software after leaving school without paying exorbitant amounts of money\nHaving access to the source code - you can learn and fix bugs\nOpen Source software is customizable and flexible\nIt‚Äôs becoming the standard in many tech companies\nYou are part of an awesome and active community!\n\n\nAll the programs mentioned in the previous slides have active development communities and are open source, which means that anyone can read the source code and contribute to these projects. Open source programs have many benefits, primarily including those that are listed on this slide.\nIt is worthwhile saying a few extra words about the second bullet point in the slide. At first, it might not sounds that great that you software has bugs, so it is worth pointing out that nearly all software has some bugs, including commercial software from multi-billion dollar companies. The difference is that when the software is open, you can report bugs yourself and even learn how to fix them together with helpful community members (if you want to)."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#why-even-bother",
    "href": "modules/module1/slides/module1_05.html#why-even-bother",
    "title": "Asking Effective Questions",
    "section": "Why even bother?",
    "text": "Why even bother?\n\nYou will get help faster\nOthers will get help faster\n\n\nAsking questions effectively means that the person helping you will be able to answer your question better and quicker. Being able to answer a question quicker means more time to help others, including your future self.\nWhen questions require clarification, fewer people will be helped overall. Sometimes this in unavoidable because the question is complex, but all too often it if because the person trying to help is not given enough information to reproduce and troubleshoot the problem, or because the question is unclear."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#be-respectful-to-volunteers-helping-you",
    "href": "modules/module1/slides/module1_05.html#be-respectful-to-volunteers-helping-you",
    "title": "Asking Effective Questions",
    "section": "Be respectful to volunteers helping you",
    "text": "Be respectful to volunteers helping you\n\nPeople are often volunteering their help\nBe respectful and considerate\nDon‚Äôt ask unclear questions like this:\nWHY IS THIS CODE NOT WORKING??????\n\n\nWhen you are asking for help online, e.g.¬†on StackOverflow or on GitHub, remember that you are often receiving help from people who are volunteering their time. So please make it as easy as possible for them to help you.\nYou might be frustrated by a problem to the point where you just want to ask something like.\n\nWHY IS THIS CODE NOT WORKING??????\n\nDon‚Äôt do this.\nNo one will help you.\nYou will get more frustrated."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#how-to-ask-effectively",
    "href": "modules/module1/slides/module1_05.html#how-to-ask-effectively",
    "title": "Asking Effective Questions",
    "section": "How to ask effectively",
    "text": "How to ask effectively\n\nMake your question easy to understand\nInclude a succinct description of the problem\nMention what you were expecting to happen and what went wrong\nInclude the minimal code to reproduce the problem\n\n\nThis slide outlines the high level parts that you want to include in an effective question. In essence, you want to make your question as easy to understand as possible and your specific problem as easy to reproduce as possible.\nIf you just include a screenshot and title your question ‚ÄúHelp‚Äù, the person helping you has to spend time trying to figure out what you want help with instead of helping with the actual problem.\nTo avoid this, include a succinct and clear description of your problem together with the minimal code needed to reproduce it. Altogether, this is often called a ‚ÄúMinimal Reproducible Example‚Äù (or MRE for short), which we will learn more about on the next page."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#an-effective-question-with-a-minimal-reproducible-example",
    "href": "modules/module1/slides/module1_05.html#an-effective-question-with-a-minimal-reproducible-example",
    "title": "Asking Effective Questions",
    "section": "An effective question with a Minimal Reproducible Example",
    "text": "An effective question with a Minimal Reproducible Example\n\nSearch for other questions similar to yours.\nDescribe the issue clearly in the title and elaborate briefly in the text body.\nReduce the code to the minimum required to recreate your error, and paste it as text.\n\nIf your code includes functions or classes, include their definitions.\nCreate small toy dataset instead of using real data.\nUse triple backticks to create markdown code blocks with proper indentation and syntax highlighting.\n\nDescribe what you have tried so far, what you don‚Äôt understand or what went wrong, including any error messages and their full traceback.\n\n\nThis slide outlines the detailed steps of how to ask an effective question, starting with searching for other similar questions and also listing the key components of creating an MRE.\nIn essence, you want the person helping you to be able to copy your code and run it on their machine to reproduce the problem right away, so that they can focus on figuring out what has gone wrong.\nIf you are interested on more in-depth articles on how to create effective MRE‚Äôs, there have been several great articles written on what goes into an MRE. Here are some of the ones we recommend you to check out:\n\nhttps://stackoverflow.com/help/how-to-ask\nhttps://stackoverflow.com/help/minimal-reproducible-example\nhttps://community.rstudio.com/t/faq-whats-a-reproducible-example-reprex-and-how-do-i-do-one/5219\nhttps://reprex.tidyverse.org/ (an R package to help creating MREs from code)"
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#type-out-the-problem-for-yourself-before-asking-the-question",
    "href": "modules/module1/slides/module1_05.html#type-out-the-problem-for-yourself-before-asking-the-question",
    "title": "Asking Effective Questions",
    "section": "Type out the problem for yourself before asking the question",
    "text": "Type out the problem for yourself before asking the question\n\nType our a proper question for yourself\nSimplifying and formalizing your issue might even lead you to the solution!\n\n\nIt is easy to get frustrated by a problem, especially if you have been stuck at it for a while. When I feel this frustration myself I find it helpful and calming to put precise words on what the issue is.\nYou can start banging out words in the beginning, but as you slowly adhere to the format of asking properly, it will become like a meditative practice which calms you down and lays the foundation for posting your question online.\nIn addition to your mental well-being, writing down questions properly has another superb quality: they help you solve your own problems. The act of formalizing a question in either speech or text helps you slow down and uncover what you missed while the problem was a mere thought; it is easy to come to conclusions to quickly in our own heads and disregard possible solutions to quickly. We will look closer at this phenomena in the next slide."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#rubber-duck-debugging",
    "href": "modules/module1/slides/module1_05.html#rubber-duck-debugging",
    "title": "Asking Effective Questions",
    "section": "Rubber duck debugging",
    "text": "Rubber duck debugging\n\nImage from Tim Morris - Wikimedia Common\n\nRealizing the solution to your problem as you are verbalizing it is so common that it has a name: ‚ÄúRubber duck debugging‚Äù. Allegedly, a software developer put a rubber duck on their desk and whenever they had a problem they couldn‚Äôt solve in their head, they starting talking to the toy duck, and often came upon the resolution while describing the problem for their toy duck."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#when-to-ask-for-help",
    "href": "modules/module1/slides/module1_05.html#when-to-ask-for-help",
    "title": "Asking Effective Questions",
    "section": "When to ask for help?",
    "text": "When to ask for help?\n\nArtwork by @allison_horst\n\nIt might be tempting to think of yourself as a ‚Äúcode hero‚Äù that can complete everything you need on your own. However, this mentality will ensure that you will get stuck and it would often be more beneficial to ask for help than to keep trying for another hour yourself.\nIt is also important to realize that there aren‚Äôt really any code heroes that excel from working all by themselves. Even people that appear to be super knowledgeable and have figured out everything on their own are in reality lifted up to where they are now by educators and developers, and supported by the community.\nIt is not a sign of weakness to ask for help, and since formulating your thoughts into a question might lead you to the correct answer, it is often beneficial to start doing this early after getting stuck."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#where-to-ask-for-help",
    "href": "modules/module1/slides/module1_05.html#where-to-ask-for-help",
    "title": "Asking Effective Questions",
    "section": "Where to ask for help",
    "text": "Where to ask for help\n\nhttps://stackoverflow.com/\n\n\n\nhttps://stats.stackexchange.com/\n\n\n\nWhen you have written down an effective question without finding the solution yourself in the process, then it is time to reach out to the data science community and ask for help.\nOne of the most common places to ask for help with programming questions is Stack Overflow. For data science questions, its sister site Cross Validated. Thousands of volunteers are answering questions on these sites everyday.\nIf you are asking your question on either of these sites, a tip is to use tags to categorize your question. These can then be used to search for an answer via the syntax [tag-name], and community members can choose to get notifications when a new question with a certain tag is asked.\nRemember, try to make your questions as easy to understand as possible!"
  },
  {
    "objectID": "modules/module2/module2-00-module_learning_outcomes.html",
    "href": "modules/module2/module2-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module2/slides/module2_00.html#module-learning-outcomes",
    "href": "modules/module2/slides/module2_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nUse the shell to navigate the computer‚Äôs filesystem\nCreate new files and directories\nMove, copy, and delete files and directories\nUse ‚Äúwildcards‚Äù\nDefine and distinguish between absolute file paths and relative file paths\nRead the shell‚Äôs built-in manual\nCombine commands with pipes\n\n\nIn this module we will learn to effectively communicate with the computer via a text-based shell."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#our-file-structure",
    "href": "modules/module2/slides/module2_03.html#our-file-structure",
    "title": "Moving around",
    "section": "Our file structure",
    "text": "Our file structure\n/home/username\n‚îú‚îÄ‚îÄ Documents/\n‚îÇ¬†¬† ‚îú‚îÄ‚îÄ another-folder/\n‚îÇ¬†¬† ‚îî‚îÄ‚îÄ my-document.pdf\n‚îú‚îÄ‚îÄ Downloads/\n‚îú‚îÄ‚îÄ Music/\n‚îú‚îÄ‚îÄ Pictures/\n‚îú‚îÄ‚îÄ .hidden-file\n‚îú‚îÄ‚îÄ my-program*\n‚îî‚îÄ‚îÄ todo.txt\n\nFor this slide deck, we will work with a file structure that looks like what is shown in this slide. We have four folders, a hidden file, and two regular files inside our user‚Äôs home directory (/home/username). Inside the Documents directory there is one additional file and one subfolder. Now let‚Äôs see how we can use different shell commands to move around in this structure."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#moving-around-in-the-shell",
    "href": "modules/module2/slides/module2_03.html#moving-around-in-the-shell",
    "title": "Moving around",
    "section": "Moving around in the shell",
    "text": "Moving around in the shell\nls -F\nDownloads/    Music/\nDocuments/    todo.txt\nPictures/     my_program*\n\nls -F Documents\nmy-document.pdf\nanother-folder/\n\nLet‚Äôs first run ls again to remind us about what the directory structure looks like.\nIf we want to see what‚Äôs in the Documents directory we can ask ls to list its contents, by passing the folder name as an argument to ls."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#absolute-and-relative-paths",
    "href": "modules/module2/slides/module2_03.html#absolute-and-relative-paths",
    "title": "Moving around",
    "section": "Absolute and relative paths",
    "text": "Absolute and relative paths\nRelative path\nDocuments/\n\nAbsolute path\n/home/username/Documents/\n\nNote that we can write paths in two separate ways. In the previous slide we used the position Documents relative to the directory we were already in. We could instead have written out it‚Äôs absolute position in the file system, starting with the root directory: /home/username/Documents. Absolute paths always start with a leading slash /.\nUsing a relative path is like telling someone to go two kilometers north and then half a kilometer east; using an absolute path is like giving them the latitude and longitude of their destination.\nThey both have different advantages: An absolute path will always be the same on your file system, whereas using relative paths makes it easier to work with collaborators across multiple computers."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#moving-to-a-directory",
    "href": "modules/module2/slides/module2_03.html#moving-to-a-directory",
    "title": "Moving around",
    "section": "Moving to a directory",
    "text": "Moving to a directory\ncd Documents\n\nThere is not output from the cd command so we use pwd to confirm where we are.\npwd\n/home/username/Documents/\n\nIf we are going to do a lot of work inside the Documents directory, the easiest thing would be to change our current working directory, so that we don‚Äôt have to type zips over and over again. The command to do this is cd, which stands for ‚ÄúChange Directory‚Äù, since it changes what directory we are currently inside.\ncd doesn‚Äôt print anything. This is normal: many shell commands run silently unless something goes wrong, on the theory that they should only ask for our attention when they need it. To confirm that cd has done what we asked, we can use pwd, to print the absolute path to the current directory."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#navigating-up-to-the-parent-directory",
    "href": "modules/module2/slides/module2_03.html#navigating-up-to-the-parent-directory",
    "title": "Moving around",
    "section": "Navigating up to the parent directory",
    "text": "Navigating up to the parent directory\nIncorrect command:\ncd username\ncd: username: No such file or directory\n\nCorrect command followed by pwd:\ncd ..\npwd\n/home/username\n\nWe now know how to navigate down the directory tree, but how do we go back up to our user‚Äôs home directory? It doesn‚Äôt work to simply type cd username since we are inside the Documents subdirectory.\nTo get back up, we could either type out the absolute path cd /home/username or use a special relative path called .. (two periods in a row with no spaces). This is a convenient shortcut that always means ‚Äúthe directory that contains the current one‚Äù, which is often called the ‚Äúparent‚Äù directory of the current directory."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#listing-hidden-files",
    "href": "modules/module2/slides/module2_03.html#listing-hidden-files",
    "title": "Moving around",
    "section": "Listing hidden files",
    "text": "Listing hidden files\nls -F -a\n./             Downloads/    Music/\n../            Documents/    todo.txt\n.hidden-file   Pictures/     my_program*\n\nWhy didn‚Äôt we see the special parent directory symbol .., when we listed the directory content? ls usually doesn‚Äôt show us this special directory‚Äîsince it‚Äôs always there, so displaying it every time would be a distraction.\nIn fact ls hides every file starting with ., since this is an indication that the creator of the file wanted it to be hidden (e.g.¬†many configuration files start with .).\nWe can ask ls to include all files by using the -a option, which stands for ‚Äúall‚Äù. You will see that this also includes a single dot .; this stands for the current directory.\nSome option also exist in a ‚Äúlong form‚Äù, in this case the -a option is equivalent to writing --all. It is also possible to combine options with a single hyphen, so ls -F -a is the same as ls -Fa."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#navigating-several-directories-at-a-time",
    "href": "modules/module2/slides/module2_03.html#navigating-several-directories-at-a-time",
    "title": "Moving around",
    "section": "Navigating several directories at a time",
    "text": "Navigating several directories at a time\nNavigate two folders down:\ncd Documents/another-folder\n\nNavigate two folders up:\ncd ../..\npwd\n/home/username\n\ncd allows us to navigate multiple directories at a time, by joining directory names with the path separator /. We can use this to navigate either down or up.\nFor example, typing cd Documents/another-folder would take us directly to the another-folder directory (in our example folder structure). Typing cd ../.. would take us two folders up: back to out home directory."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#home-directory-shortcut",
    "href": "modules/module2/slides/module2_03.html#home-directory-shortcut",
    "title": "Moving around",
    "section": "Home directory shortcut",
    "text": "Home directory shortcut\ncd ~/Documents\npwd\n/home/username/Documents\n\nThese two cd commands both return you to the home directory:\ncd ~\ncd\npwd\n/home/username\n\ncd also offers a few shortcuts for common operations, e.g.¬†using ~ is a shortcut for typing /home/username, so no matter in which folder you are currently located, you can type cd ~/Documents to navigate to the documents folder in your home directory.\nLikewise, you could type cd ~ to navigate to your home directory, or even just cd without any path argument, since this is a special shortcut just for the home directory.\nAnother common shortcut is cd - (hyphen), which takes you back the most recent directory you visited."
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#searching-for-text-patterns-in-files",
    "href": "modules/module2/slides/module2_07.html#searching-for-text-patterns-in-files",
    "title": "Intermediate shell topics",
    "section": "Searching for text patterns in files",
    "text": "Searching for text patterns in files\ngrep \"the\" note_2022-06-22.md\nnote_2022-06-22.md:These are the first\nnote_2022-06-22.md:in the file.\n\nWe can use the grep command to search for text in files. To search for the word ‚Äúthe‚Äù in our notes file, we can type grep \"the\" note_2022-06-22.md. This will return every line in the file that contains the word ‚Äúthe‚Äù.\nWhen you have a longer command like this that you find annoying to re-type each time, you can use the up/down arrows on your keyboard to navigate the history of commands. This way you can go back to a long command easily and then just modify it a bit instead of retyping it from scratch. In a few slides we will learn about another technique to help with long commands by creating shorter aliases for them."
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#seeing-the-history-of-commands",
    "href": "modules/module2/slides/module2_07.html#seeing-the-history-of-commands",
    "title": "Intermediate shell topics",
    "section": "Seeing the history of commands",
    "text": "Seeing the history of commands\nhistory\n1  pwd\n2  ls\n3  cd Documents/\n4  cd\n5  ls -F -a\n6  history\n\nOccasionally, we might want to re-use a command that we used in the past, but don‚Äôt remember exactly what it was. The history command can help us with this as it lists all the previous commands we have run and in which order we ran them."
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#combining-commands-with-pipes",
    "href": "modules/module2/slides/module2_07.html#combining-commands-with-pipes",
    "title": "Intermediate shell topics",
    "section": "Combining commands with pipes",
    "text": "Combining commands with pipes\nhistory | grep \"ls\"\n2  ls\n5  cd ls -F -a\n7  history | grep \"ls\"\n\nAs you start using the shell more, you will realize that the history command quickly fills up and it becomes difficult to find any particular command we are looking for. In cases like these, it would be useful to be able to search in the list of commands, e.g.¬†you might remember that your command included the word ls, but you don‚Äôt remember exactly which flags you used.\nWe just learned about grep for searching for text in files, so maybe there is someway we could use it to search the text output from the history command? In other words, could we redirect the output from the history command to grep before printing it on the screen?\nThis is exactly what a pipe (|) does, which we can use with the following syntax command1 | command2. In our case this would be history | grep \"ls\", which sends the output of ls to grep, which removes all the lines that don‚Äôt contain ‚Äúls‚Äù, before printing the remaining three lines to the screen."
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#a-complex-pipe",
    "href": "modules/module2/slides/module2_07.html#a-complex-pipe",
    "title": "Intermediate shell topics",
    "section": "A complex pipe",
    "text": "A complex pipe\nFruit Color\nkiwi green\nplum purple\napple red\napple green\nplum purple\napple red\nwatermelon red\n\ntail -n +2 fruit-colors.txt | cut -d ' ' -f2 | sort | uniq -c\n2 green\n2 purple\n3 red\n\nPipes allow us to create rather complex commands. Imagine that we have a text file containing a list of fruits and their colors as in the top of this slide. How can we count how many fruits there are of each color?\nWe need to break this down into several steps:\n\nWe don‚Äôt want to include the first line that says ‚ÄúFruit Color‚Äù when we are counting. To show the entire file except this line we can use tail -n +2 to print everything from the second line to the end of the file.\nTo get only the colors, we need to cut out the second column. We can do this using the cut command, and specifying that the delimiter in this file is a space (-d ' '), and we are interesting in cutting out the second column/field (-f2).\nTo count the unique occurrences, we first need to sort the file so that all the same colors are adjacent to each other. On a sorted file, we can use the uniq command with the -c/--count flag to count the unique occurrences of words.\n\nThis is a rather complex pipe and we introduced a few new commands as well. You don‚Äôt need to worry about the details here, it is the principle that is important: With the shell you can find many useful small commands and if you string them together using a pipe, it is possible to perform rather advanced text processing directly in the shell."
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#creating-an-alias",
    "href": "modules/module2/slides/module2_07.html#creating-an-alias",
    "title": "Intermediate shell topics",
    "section": "Creating an alias",
    "text": "Creating an alias\nBefore creating the alias:\nl\nl: command not found\n\nAfter creating the alias:\nalias l=\"ls -aFltr\"\nl\ntotal 12\n-rw-rw-r-- 1 usergroup username   53 Jun 20 08:47 note_2022-06-22.md\ndrwxr-xr-x 4 usergroup username 4096 Jun 20 11:45 ../\n-rw-rw-r-- 1 usergroup username    0 Jun 20 11:53 note_2022-07-02.md.bkp\n-rw-rw-r-- 1 usergroup username    0 Jun 20 11:53 note_2022-07-02.md\n-rw-rw-r-- 1 usergroup username    0 Jun 20 11:53 note_2022-06-20.md.bkp\ndrwxrwxr-x 2 usergroup username 4096 Jun 20 14:54 ./\n\nIf you have a complex command that you run every so often, but is hard to remember, or just take a long time to type out, you can create a nickname for this command. This could e.g.¬†be a command that uses many of option flags, or a long series of commands piped together.\nAn example of this could be to enhance the ls command, which is one we use very often and could be made more helpful by have a nickname for some of the commonly used options. Let‚Äôs say that we want to include the following options:\n\n-a list all files, including hidden ones\n-F append indicator characters to make the output easier to understand\n-l show the ‚Äúlong‚Äù format, which includes more information about each file (read the man page to find out more!)\n-t sort files by time instead of alphabetically\n-r sort in reverse order with the most recent file at the bottom\n\nWe could type out ls -aFltr each time, but that is cumbersome. If we instead type alias l=\"ls -aFltr\", we can use the shorter l as an ‚Äúalias‚Äù for the longer command. If we want to keep this alias between reboots, we need to save it to file ~/.bash_profile (on Windows and Mac) or ~/.bashrc (on Linux) the same way we did during the setup in assignment 1."
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#reading-the-manual",
    "href": "modules/module2/slides/module2_07.html#reading-the-manual",
    "title": "Intermediate shell topics",
    "section": "Reading the manual",
    "text": "Reading the manual\nman ls\nLS(1)                                                    User Commands\n \nNAME\n       ls - list directory contents\n \nSYNOPSIS\n       ls [OPTION]... [FILE]...\n \nDESCRIPTION\n       List  information  about the FILEs (the current directory by default).  Sort entries alphabetically if none of -cftuvSUX\n       nor --sort is specified.\n \n       Mandatory arguments to long options are mandatory for short options too.\n \n       -a, --all\n              do not ignore entries starting with .\n \n       -A, --almost-all\n              do not list implied . and ..\n \n       --author\n              with -l, print the author of each file\n \n       -b, --escape\n              print C-style escapes for nongraphic characters\n \n       --block-size=SIZE\n              with -l, scale sizes by SIZE when printing them; e.g., '--block-size=M'; see SIZE format below\n \n       -B, --ignore-backups\n              do not list implied entries ending with ~\n...\n\nHow can we find out what options like -t and -r do if we don‚Äôt know of them already? By reading the built-in help manual! Typing man ls brings up the manual help page for the ls command. You can navigate these pages with Space to go down and b to go Back up. q quits the manual and takes you back to the shell prompt.\nTyping / starts a search. Type in the search term and press Enter to be taken to the first hit. To continue to the next search hit, press n, and to go to the previous, press shift + n.\nTechnically, the manual pages are displayed inside a ‚Äúpager‚Äù program called less, which you could use to add interactive navigation to any long piece of text. less is used widely by other shell programs, so these navigation keys are important to remember as they will be helpful to navigate other pages as well!\nNote that on Windows there is no built-in man command. Instead you can pipe the help pages into the less command manually via e.g.¬†ls --help | less. We setup an alias for this called man during the setup in assignment one, so if you followed those instructions, you should be able to type man ls on Windows as well."
  },
  {
    "objectID": "modules/module3/module3-00-module_learning_outcomes.html",
    "href": "modules/module3/module3-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module3/slides/module3_00.html#module-learning-outcomes",
    "href": "modules/module3/slides/module3_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nDifferentiate between the use of GitHub as a remote hosting service for version control and Git as a version control system.\nIdentify a Git repository.\nImplement Git‚Äôs clone, add, status, commit, pull, and push operations on the command line and their equivalent use in the JupyterLab IDE.\nUnderstand what it implies to use the staging area in a Git workflow.\nUse commits as the primary building block for storing a project versions together with an attached message and a unique identifier.\n\n\nThis module covers the basics of version control with Git and GitHub."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#schematic-of-local-and-remote-version-control-repositories.",
    "href": "modules/module3/slides/module3_03.html#schematic-of-local-and-remote-version-control-repositories.",
    "title": "Version control repositories",
    "section": "Schematic of local and remote version control repositories.",
    "text": "Schematic of local and remote version control repositories.\n \n\n\nTypically, when we put a data analysis project under version control, we create two copies of the repository. One copy is used as our primary workspace where we create, edit, and delete files.\nThis copy is referred to as the local repository. The local repository most commonly exists on our computer or laptop, but can also exist within a workspace on a server (e.g., JupyterHub). The other copy is typically stored in a repository hosting service (e.g., GitHub), where we can easily share it with our collaborators. This copy is known as the remote repository.\nUnder the hood, Git only saves the changes between your versions rather than a complete version of the document each time, so it is also efficient in terms of disk space. Note that while Git works great for text files, such as code, it is not so great for binary files such as images because the changes between two versions of the same image cannot easily be expressed in plain text."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#tracking-the-repository-history-using-commit-messages",
    "href": "modules/module3/slides/module3_03.html#tracking-the-repository-history-using-commit-messages",
    "title": "Version control repositories",
    "section": "Tracking the repository history using commit messages",
    "text": "Tracking the repository history using commit messages\n\n\nBoth copies of the repository have a working directory where you can create, store, edit, and delete files (e.g., analysis.ipynb in the image).\nYou have probably noticed that in the local repository there is a staging area, which does not exist in the remote repository. We will soon learn more about the staging area, but for now imagine that it is a particular area in your local repository that will give you more flexibility to track your changes."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#tracking-the-repository-history-using-commit-messages-1",
    "href": "modules/module3/slides/module3_03.html#tracking-the-repository-history-using-commit-messages-1",
    "title": "Version control repositories",
    "section": "Tracking the repository history using commit messages",
    "text": "Tracking the repository history using commit messages\n\n\nBoth repositories also keep a complete project history. This history is a record of all versions of the project files that have been created. The repository history is not automatically generated; Git must be explicitly told when to record a version of the project. These records are called commits. They are a snapshot of the file contents and metadata about the repository at the time the record was created (a commit includes who made the commit, when it was made, etc.).\nIn the local and remote repositories shown in the image, there are two commits represented as gray circles. Each commit can be identified by a human-readable message, which you write when you create the commit, and a commit hash that Git automatically adds for you."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#commit-message",
    "href": "modules/module3/slides/module3_03.html#commit-message",
    "title": "Version control repositories",
    "section": "Commit message",
    "text": "Commit message\n \n\n\nThe purpose of the commit message is to contain a brief, rich description of what work was done since the last commit. Messages act as a very useful narrative of the changes to a project over its lifespan. If you ever want to view or revert to an earlier version of the project, the message can help you identify which commit to view or revert to. In this image, you can see two such messages, one for each commit: Created README.md and Added analysis draft.\nThe hash is a string of characters consisting of about 40 letters and numbers. The purpose of the hash is to serve as a unique identifier for the commit, and is used by Git to index project history. Although hashes are quite long ‚Äî imagine having to type out 40 precise characters to view an old project version! ‚Äî Git is able to work with shorter versions of hashes. In the image, you can see two of these shortened hashes, one for each commit: Daa29d6 and 884c7ce."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#how-can-you-create-your-repositories",
    "href": "modules/module3/slides/module3_03.html#how-can-you-create-your-repositories",
    "title": "Version control repositories",
    "section": "How can you create your repositories?",
    "text": "How can you create your repositories?\n  \n\nCreate the remote repository in www.github.com (GitHub)\nClone the repository to your local computer with the terminal OR JupyterLab IDE (Git)\n\n\nFirst, we are going to learn how to create a remote repository on GitHub and then to clone it locally using the terminal or JupyterLab.\nThere is another possible option to create a repository, that is creating it locally and then pushing it to GitHub, but we are not going to cover it in this course."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#how-can-you-create-your-repositories-1",
    "href": "modules/module3/slides/module3_03.html#how-can-you-create-your-repositories-1",
    "title": "Version control repositories",
    "section": "How can you create your repositories?",
    "text": "How can you create your repositories?\n  \n\n\nCloning a GitHub repository is not the same as downloading it to your computer. When you clone it you are downloading the files and all the project history including the commits and their associated messages. The information about your project that is not the files themselves is downloaded as a hidden folder called .git. Any folder that contains a hidden .git folder is considered a Git repository. By default, all your projects on GitHub are Git repositories.\nYou can clone your project to have a local copy using an integrated development environment (IDE) as JupyterLab or the terminal. The terminal will give you greater versatility since you can use a wide variety of commands, while the IDE will allow you to handle the basic commands in a more intuitive way.\nNext, we are going to learn more about both the steps in this slide, starting with how to create the remote repository!"
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#creating-a-remote-repository-on-github",
    "href": "modules/module3/slides/module3_03.html#creating-a-remote-repository-on-github",
    "title": "Version control repositories",
    "section": "1. Creating a remote repository on GitHub",
    "text": "1. Creating a remote repository on GitHub\n \n\n\nüôå Practice\nBefore you can create remote repositories on GitHub, you will need a GitHub account; you can sign up for a free account at https://github.com. Once you have logged into your account, you can create a new repository to host your project by clicking on the + icon in the upper right-hand corner, and then on New Repository.\nAnother way to create a repository is by clicking the green button New on the left side of the screen."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#creating-a-remote-repository-on-github-1",
    "href": "modules/module3/slides/module3_03.html#creating-a-remote-repository-on-github-1",
    "title": "Version control repositories",
    "section": "1. Creating a remote repository on GitHub",
    "text": "1. Creating a remote repository on GitHub\n\n\nüôå Practice\nRepositories can be set up with a variety of configurations, including a name, optional description, and the inclusion (or not) of several template files. One of the most important configuration items to choose is the visibility to the outside world, either public or private:\n\nPublic repositories can be viewed by anyone.\nPrivate repositories are only visible to you.\n\nBoth public and private repositories are only editable by you, but you can change that by giving access to other collaborators.\nTo get started with a public repository having a template README.md file, take the following steps:\n\nEnter the name of your project repository. In our example, we use canadian_languages.\nMost repositories follow a similar naming convention involving only lowercase letter words separated by either underscores or hyphens.\nChoose an option for the privacy of your repository.\nSelect the option Add a README file. This creates a placeholder README.md file in your repository‚Äôs root folder, which makes it possible to clone the repository to your computer directly.\nWhen you are happy with your repository name and configuration, click on the green Create Repository button.\n\nThat‚Äôs it! Now let‚Äôs clone it to get a local copy on your computer."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide",
    "href": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide",
    "title": "Version control repositories",
    "section": "2. Cloning a repository using Jupyter Lab (IDE)",
    "text": "2. Cloning a repository using Jupyter Lab (IDE)\n  \n\n\nüôå Practice\nCloning a remote repository from GitHub to create a local repository results in a copy that is aware where it was obtained from, so that it knows where to send/receive new committed edits. In order to do this, first click the green button that says Code on your GitHub repo, and choose to copy the URL from the HTTPS tab.\nThe green ‚ÄúCode‚Äù drop-down menu contains the remote address (URL) corresponding to the location of the remote GitHub repository."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-1",
    "href": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-1",
    "title": "Version control repositories",
    "section": "2. Cloning a repository using Jupyter Lab (IDE)",
    "text": "2. Cloning a repository using Jupyter Lab (IDE)\n\n\n\nüôå Practice\nNext, open JupyterLab and click the Jupyter Git Clone icon in the Files tab of the left side bar. We have marked this icon with a red circle in the screenshot in this slide.\nWhen you click this button a dialog box will show up, which we will explain in the next slide."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-2",
    "href": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-2",
    "title": "Version control repositories",
    "section": "2. Cloning a repository using Jupyter Lab (IDE)",
    "text": "2. Cloning a repository using Jupyter Lab (IDE)\n\n\n\nüôå Practice\nOnce the dialog box pops up, you can paste the URL of the GitHub project repository you copied earlier and click the blue CLONE button. This will download the repository files to your computer.\nAnother way to do this is clicking on the Git icon on the side bar as you can see in the image\nIt is important to keep in mind where you want to locate your repository. Before cloning the repository, navigate to the desired folder using the File Browser button on the left sidebar.\nPay attention to not clone your repository inside another Git repository. This is not considered a good practice."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-3",
    "href": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-3",
    "title": "Version control repositories",
    "section": "2. Cloning a repository using Jupyter Lab (IDE)",
    "text": "2. Cloning a repository using Jupyter Lab (IDE)\n\n\n\nüôå Practice\nWhen the cloning is complete, you will now see a folder for the repository showing up in the file browser tab. Inside this folder are all the files that existed on your repository on GitHub."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-terminal",
    "href": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-terminal",
    "title": "Version control repositories",
    "section": "2. Cloning a repository using Jupyter Lab (Terminal)",
    "text": "2. Cloning a repository using Jupyter Lab (Terminal)\n  \n\n\nüôå Practice\nIt is also possible to work with Git from the terminal instead of the JupyterLab Git client. We will later see that there are some advantages of working in the terminal for the more advanced commands. For now, let‚Äôs see how we can perform the same cloning steps in the terminal as we just did via the graphical Git client. Note that we will never need to clone a project both from the Git client and the terminal, so we are just doing this here to show you how it is done in both interfaces.\nTo clone a repository from the terminal, we will use the git clone command followed by the same URL we copied previously as can be seen in the screenshot on this slide. After the cloning has finished, you will see that the repository appears in the JupyterLab files tab, just as it did when we cloned it using the graphical Git client."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#how-do-you-know-if-youre-working-in-a-git-repository-terminal",
    "href": "modules/module3/slides/module3_03.html#how-do-you-know-if-youre-working-in-a-git-repository-terminal",
    "title": "Version control repositories",
    "section": "How do you know if you‚Äôre working in a Git repository? (Terminal)",
    "text": "How do you know if you‚Äôre working in a Git repository? (Terminal)\n  \n\n\nüôå Practice\nAs we mentioned before, a Git repository stores all the necessary information for version control your project in a hidden folder called .git. If you want to know if you are working in a Git repository using the terminal you can use the bash command ls -a as you can see in the image. The -a flag will include into the lists of files displayed on the terminal the hidden folders. If the .git folder is present you are working in a Git repository.\nRemember to first double check that you are in the directory which the files have been cloned to. When you clone, the files will be downloaded to a subdirectory of the folder you are currently in, so you need to use cd to get to that folder before running ls -a. By cloning a repository from GitHub to your computer, you are automatically getting a copy of .git and thus, working in a Git repository."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#committing-the-modified-files-in-the-staging-area",
    "href": "modules/module3/slides/module3_07.html#committing-the-modified-files-in-the-staging-area",
    "title": "Committing changes to a local repository",
    "section": "Committing the modified files in the staging area",
    "text": "Committing the modified files in the staging area\n \n\n\nOnce the files we want to keep have been added to the staging area, we can ‚Äúcommit‚Äù them to the repository history. When we do this, we are required to include an informative message briefly describing the purpose of the changes we made.\nIn the screenshot, the commit message is \"Message about changes...\"; in your work you should make sure to replace this with an informative message about what you changed. It is also important to note that these changes are only being committed to the history of the local repository‚Äôs on your computer. The remote repository on GitHub has not changed, and collaborators would not yet be able to see your new changes online."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#committing-to-add-sections-to-your-project-history",
    "href": "modules/module3/slides/module3_07.html#committing-to-add-sections-to-your-project-history",
    "title": "Committing changes to a local repository",
    "section": "Committing to add sections to your project history",
    "text": "Committing to add sections to your project history\n \n\n\nimage source: xkcd.com\n\n\nWriting meaningful commit messages is really important. When commit messages are too vague (code additions or Add some stuff) it will be difficult to interpret for our collaborators, including ourselves in the future. Writing clear and descriptive commit messages increases the quality of your project and facilitates collaborative work."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (JupyterLab IDE)",
    "text": "Making the commit (JupyterLab IDE)\n\n\n\nüôå Practice\nStep 3. Add a commit message into the Jupyter Git extension commit text box.\nTo commit the staged changes together with an associated commit message, you must write a message in the text box at the bottom of the Git pane and click on the blue ‚ÄúCommit‚Äù button (see image). It is highly recommended to write useful and meaningful messages about what was changed.\nThese commit messages, and the time stamp for a given commit, are the primary means to navigate through the project‚Äôs history in the event that you need to view or retrieve a past version of a file, or revert your project to an earlier state.\nWhen you click the ‚ÄúCommit‚Äù button for the very first time, you will be prompted to enter your name and email. This only needs to be done once for each machine you use Git on, and is added as author information to the commit message."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-1",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-1",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (JupyterLab IDE)",
    "text": "Making the commit (JupyterLab IDE)\n\n\n\nüôå Practice\nStep 3 continued\nWhen committing changes, you need to include a title/summary for each message (the upper text box in JupyterLab). Optionally, you could also include a longer description for the commit in the next text box."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-2",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-2",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (JupyterLab IDE)",
    "text": "Making the commit (JupyterLab IDE)\n \nBad messages ‚ùå :\n\nfixes an error\nadded new code\n\n \nGood messages ‚úÖ :\n\nReorder sections to make the README more welcoming\nFix notebook error to allow for export with images\n\n\nYou can see example of informative commit titles in this slide.\nThe general guideline for the title is to summarize the purpose of the commit as a short descriptive message. It is recommended to write your messages in imperative mood (imagine that your commit should complete the sentence ‚Äúthis commit will‚Ä¶‚Äù) and start with a capital letter."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-3",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-3",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (JupyterLab IDE)",
    "text": "Making the commit (JupyterLab IDE)\n\n\n\nüôå Practice\nAfter recording a commit, the staging area should be empty and you will see that there are 0 staged files. You are now ready to push your changes to the remote repository on GitHub."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-4",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-4",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (JupyterLab IDE)",
    "text": "Making the commit (JupyterLab IDE)\n\n\n\nüôå Practice\nAfter the changes have been successfully committed, you can view them in the History tab together with your message. You have now tracked this change and made it part of the history of your project!"
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-terminal",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-terminal",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (Terminal)",
    "text": "Making the commit (Terminal)\n\n\n\ngit commit\n\nüôå Practice\nThe equivalent terminal command for making a commit with a title and long description, is to type git commit inside Bash and press enter. This will open your default text editor with a temporary file called COMMIT_EDITMSG where you can type in the commit message as shown in the next slide."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-terminal-1",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-terminal-1",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (Terminal)",
    "text": "Making the commit (Terminal)\n\n\n\nüôå Practice\nYour default text editor should be VS Code if you followed the setup steps in the first assignment. If you didn‚Äôt, you might end up in a text editor called vim that runs inside the terminal as shown in this slide. vim is powerful, but has a steep learning curve, so in case this happens, you can exit vim by typing :q and then pressing Enter. Then you can go back and make sure that VS Code is your default editor by following the instructions in the first assignment."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-terminal-2",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-terminal-2",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (Terminal)",
    "text": "Making the commit (Terminal)\n\n\n\nOften, a descriptive summary in the title field is sufficient and we don‚Äôt need to write out a long description. When this is the case, you can use the shorter version of the command git commit with the flag -m, which allows you to type in the title summary together with the command:\ngit commit -m \"Create an eda notebook\""
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub",
    "text": "Pulling changes from GitHub\n\n\nIf you are working on a project with collaborators, they will also be making changes to files (e.g., to the analysis code in a Jupyter notebook and the project‚Äôs README file), committing them to their own local repository, and pushing to the remote GitHub repository to share their commits with you. When they push their changes, those changes will initially only exist in the remote GitHub repository and not in your local repository on your computer.\nTo obtain the new changes from the remote repository on GitHub, you will need to pull/download those changes to your own local repository. By pulling changes, you synchronize your local repository to what is present on GitHub. Additionally, until you pull changes from the remote repository, you will not be able to push any more changes yourself (though you will still be able to work and make commits in your local repository)."
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (JupyterLab IDE)",
    "text": "Pulling changes from GitHub (JupyterLab IDE)\n\n\n\nThe GitHub interface indicates the name of the last user to push a commit to the remote repository, a preview of the associated commit message, the unique commit hash, and how long ago the commit was made.\nIn this example, we can see that someone else has made a change to the repository. We can use Jupyter Lab to pull/download this change to our local Git repository."
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-1",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-1",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (JupyterLab IDE)",
    "text": "Pulling changes from GitHub (JupyterLab IDE)\n\n\n\nüôå Practice\nTo pull from GitHub in JupyterLab, there are two steps:\nStep 1. Click the pull button in the Jupyter Lab Git extension.\nYou can tell Git to ‚Äúpull‚Äù down any new changes from the remote repository at GitHub.com by clicking on the cloud icon with the down arrow in Jupyter Lab."
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-2",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-2",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (JupyterLab IDE)",
    "text": "Pulling changes from GitHub (JupyterLab IDE)\n\n\n\nIn some cases, JupyterLab can warn you about continue modyfing your files locally when there are changes in the branch you are working. It is better to always keep the files updated with the remote and pull the changes!"
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-3",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-3",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (JupyterLab IDE)",
    "text": "Pulling changes from GitHub (JupyterLab IDE)\n\n\n\nüôå Practice\nStep 2. Refresh any open files that had changes pulled down.\nOnce the files are successfully pulled from GitHub, it is important that you refresh or reopen any files that had changes pulled down from GitHub. If you don‚Äôt, Jupyter Lab will keep displaying the old version of the file and it will be confusing if you make changes to this version instead of the newly pulled down version from GitHub.com.\nIn this slide, the red arrows are indicating the changes to the open notebook after pulling and refreshing."
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-4",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-4",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (JupyterLab IDE)",
    "text": "Pulling changes from GitHub (JupyterLab IDE)\n\n\n\nüôå Practice\nThe newly pulled changes will also show up in the history tab, since they are now part of your local repository, just as any commit you made on your computer.\nIt is best practise to pull the changes at the start of each work session before you begin editing any files in your local repository."
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-terminal",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-terminal",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (Terminal)",
    "text": "Pulling changes from GitHub (Terminal)\n\n\n\nüôå Practice\nIf you want to pull changes from GitHub.com via the terminal, you can use the command git pull. As you can see in this slide, Git will print a summary of what it changed when you run git pull (in the image one insertions/additions were made to eda.ipynb)."
  },
  {
    "objectID": "modules/module4/module4-00-module_learning_outcomes.html",
    "href": "modules/module4/module4-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module4/module4-02-practice_a_history_lesson.html",
    "href": "modules/module4/module4-02-practice_a_history_lesson.html",
    "title": "1.1. Exercises",
    "section": "",
    "text": "Clone the repo https://github.com/UBC-MDS/equine_numbers_value_canada, and answer the following questions.",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 1.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/module4-02-practice_a_history_lesson.html#practice-a-history-lesson",
    "href": "modules/module4/module4-02-practice_a_history_lesson.html#practice-a-history-lesson",
    "title": "1.1. Exercises",
    "section": "",
    "text": "Clone the repo https://github.com/UBC-MDS/equine_numbers_value_canada, and answer the following questions.",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 1.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/module4-10-practice_merge_with_care.html",
    "href": "modules/module4/module4-10-practice_merge_with_care.html",
    "title": "5.1. Exercises",
    "section": "",
    "text": "$ cat README.md\n\nIf you have questions, please\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nopen an issue\n=======\nask your question via email.\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; new_branch_to_merge_later",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 5.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/module4-10-practice_merge_with_care.html#practice-merge-with-care",
    "href": "modules/module4/module4-10-practice_merge_with_care.html#practice-merge-with-care",
    "title": "5.1. Exercises",
    "section": "",
    "text": "$ cat README.md\n\nIf you have questions, please\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nopen an issue\n=======\nask your question via email.\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; new_branch_to_merge_later",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 5.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/slides/module4_00.html#module-learning-outcomes",
    "href": "modules/module4/slides/module4_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nExplore the Git history via git log in the terminal, and the equivalent functions in JupyterLab and GitHub.\nCompare commits using git diff in the terminal, and the equivalent functions in JupyterLab and GitHub.\nSolve merge conflicts at the command line and in VS Code.\nAvoid pushing certain local files by including a .gitignore file.\nDifferentiate between doing a revert and a hard reset of a commit when restoring an older version of a project.\n\n\nThis module covers the git history, travelling back in time, dealing with merge conflicts and other related topics."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#comparing-commits",
    "href": "modules/module4/slides/module4_03.html#comparing-commits",
    "title": "Comparing commits",
    "section": "Comparing commits",
    "text": "Comparing commits\n\n\nWe have learned how to check the commit history of a project using GitHub, JupyterLab, and the terminal.\nWe can see some key information about each commit in the history view, such as when it was made and who made it.\nBut what if we want to examine the specific changes made between two commits in more detail? Which files had changes? Which lines exactly have been modified?"
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#comparing-commits-1",
    "href": "modules/module4/slides/module4_03.html#comparing-commits-1",
    "title": "Comparing commits",
    "section": "Comparing commits",
    "text": "Comparing commits\n  \n\n\nIn this slide you can see the comparison between two commits for a single file (README.md). The version of the file displayed on the left side is the older (commit d59b6bb) and the version on the right is more recent (commit aa2a019) The green and red highlights indicate the lines that have changed between the commits: In the example, the phrase ‚ÄúHello world! has been introduced in line number four in the commit aa2a019.\nThis type of comparison is called the ‚Äúdiff‚Äù (difference) between commits. and it can be helpful to understand what has changed.\nLet‚Äôs explore how we can access this view in JupyterLab, the terminal, and GitHub."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#differences-between-commits-jupyterlab",
    "href": "modules/module4/slides/module4_03.html#differences-between-commits-jupyterlab",
    "title": "Comparing commits",
    "section": "üôå Differences between commits: JupyterLab",
    "text": "üôå Differences between commits: JupyterLab\n\n\n\nOpen the History tab in JupyterLab to see the differences between commits.\n\nOnce there, find the older commit you want to compare first and then click the file icon symbol with the left arrow. Repeat the process for the most recent commit that you want to compare, but this time you should click the file icon symbol with the right arrow. After doing so, a new section called Compare d59b6bb and aa2a019 will appear at the bottom of the History tab.\nIn that section you should choose the file for which you want to see the differences. In our example, we have only changed the README.md file. The next step is to click the file icon with the + and - symbols next to the name of the file. The differences between both commits will be displayed as a new file."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#differences-between-commits-terminal",
    "href": "modules/module4/slides/module4_03.html#differences-between-commits-terminal",
    "title": "Comparing commits",
    "section": "üôå Differences between commits: Terminal",
    "text": "üôå Differences between commits: Terminal\n\n\n\nAs we have seen before, the terminal is often more flexible than the graphical user interface and the same is true when comparing commits.\nLet‚Äôs first compare two commits the same way as we did with JupyterLab. For this we will use the command git diff &lt;commit 1 hash&gt; &lt;commit 2 hash&gt; as in the slide. We can read that a line including ‚ÄúHello world!‚Äù was added to the README.md file.\nJust as in JupyterLab, the default is to compare the specified commit with the most recent one so what we wrote about would be equal to specifying only one commit hash (the oldest one) doing git diff d59b6bb, since aa2a019 is the most recent commit.\nNote that git diff is useful for comparing files outside Git repositories as well. You can use git diff &lt;file 1&gt; &lt;file 2&gt; to see all the differences between two text files."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#understanding-the-comparison",
    "href": "modules/module4/slides/module4_03.html#understanding-the-comparison",
    "title": "Comparing commits",
    "section": "Understanding the comparison",
    "text": "Understanding the comparison\n\n\n\nWhen visualizing differences, you can invert the commit order. As result, the output of git diff will be inverted as well. To avoid confusion, we recommend that you always use the same criteria to select the order of the commits to compare.\nYou must also pay attention to the - and + symbols. They are indicating the order in which the commits were chosen to be compared.\n\n- symbol is indicating changes in the first commit you have selected in JupyterLab or git diff first commit hash.\n+ symbol is indicating changes in the second commit you have selected in JupyterLab or git diff second commit hash.\n\nIn both cases, the phrase ‚ÄúHello world!‚Äù has been added. What the - and + are showing you is in which commit is the addition! Which changes show up in red and which show up in green will also depend on which commit hash your write on the left and right side, so you cannot always rely on the color to indicate which change is the oldest.\nIf you want to understand in more detail what the git diff output you can find a more detailed description in this tutorial."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#differences-between-commits-github",
    "href": "modules/module4/slides/module4_03.html#differences-between-commits-github",
    "title": "Comparing commits",
    "section": "üôå Differences between commits: GitHub",
    "text": "üôå Differences between commits: GitHub\n\nhttps://github.com/flordandrea/toy_ds_project/compare/d59b6bb..aa2a019\n\n\n\nSo far we have seen how to compare commits locally in JupyterLab and via the terminal. What about visualizing the differences between commits directly on GitHub, is that possible?\nYes, it is! You can add the following line to your repository‚Äôs URL /compare/&lt;commit1&gt;..&lt;commit2&gt; (substituting in the commits hashes to compare) and you will access the view that you can see in this slide.\nRemember to use 7 characters for the commits id. Otherwise, it is not going to work! Give it a try in one of your repositories!\nAlso note that you could use ... instead of .. to compare commits, but double dot is the same as git diff &lt;commit1&gt; &lt;commit2&gt;. You can read more about the difference of two and three dots in this StackOverflow answer."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-jupyterlab",
    "href": "modules/module4/slides/module4_07.html#reversion-jupyterlab",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (JupyterLab)",
    "text": "Reversion (JupyterLab)\n\n\nAs we saw in the previous slide deck, it is troublesome to perform a hard reset when we are working together with collaborators online. Another approach for undoing some of your work is to create a new commit that reverts your changes. This means that nothing in your Git history is deleted, there is just a new commit added containing the reversions to each file.\nTo revert to a previous commit via JupyterLab, you can click the arrow icon in the commit you want to go back to in JupyterLab‚Äôs ‚ÄúHistory‚Äù tab, as seen in this slide."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-jupyterlab-1",
    "href": "modules/module4/slides/module4_07.html#reversion-jupyterlab-1",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (JupyterLab)",
    "text": "Reversion (JupyterLab)\n\n\nWhen you click the arrow, JupyterLab asks you for the commit title and description for the new reversion commit. You can either keep the preloaded name here or find a more meaningful one."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-jupyterlab-2",
    "href": "modules/module4/slides/module4_07.html#reversion-jupyterlab-2",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (JupyterLab)",
    "text": "Reversion (JupyterLab)\n\n\nNow you can see that you have a new commit, and the state of the your project is the same as it was previously, without deleting anything!\nRemember to push your changes if you want to keep your remote updated. In contrast to a hard reset, a reversion if more friendly for collaborating on GitHub, but it is still important to push big reversions soon and inform your collaborators, since some of them might be modifying the part that you reverted!"
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-terminal",
    "href": "modules/module4/slides/module4_07.html#reversion-terminal",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (Terminal)",
    "text": "Reversion (Terminal)\ngit revert &lt;commit hash&gt;\n\n\n\nIf you want to revert changes with the terminal you can use git revert together with the commit hash you want to revert to."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-terminal-1",
    "href": "modules/module4/slides/module4_07.html#reversion-terminal-1",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (Terminal)",
    "text": "Reversion (Terminal)\n\n\n\nAfter running git revert, your default text editor will pop up so you can modify the final commit message. If you close it as it is, the message will be the default one.\nAfter closing the editor, you can view the new reversion in the project history tab or with git log. The number of files changed, insertions and deletions are informed when you are using the terminal or JupyterLab as you can see in the image."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#travelling-back-in-time",
    "href": "modules/module4/slides/module4_07.html#travelling-back-in-time",
    "title": "Revert changes made to your Git project",
    "section": "Travelling back in time üïë",
    "text": "Travelling back in time üïë\n \n\nDoing a hard reset ‚úîÔ∏è\n\n\n\nReverting previous changes ‚úîÔ∏è\n\n\nIn the last two slide decks, we have learned two ways of restoring our project to a previous point in time: hard reset and revert changes. One of the major differences is that when we select the option of doing a hard reset we are removing the previous commits we made and thereby modifying the Git history of the project. If we instead chose to revert our changes, we keep all our previous commits and add a new ‚Äúreversion‚Äù commit that includes all the changes needed to make our repository identical to a previous points in time."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#unnecessary-untracked-files",
    "href": "modules/module4/slides/module4_11.html#unnecessary-untracked-files",
    "title": "What is .gitignore?",
    "section": "Unnecessary untracked files",
    "text": "Unnecessary untracked files\nYou may have encountered this before:\ngit status\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    .ipynb_checkpoints/\n    .DS_Store\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nAs we know, Git let us know about untracked files when we run the command git status. An untracked file or folder one that you didn‚Äôt have in the previous commit, and which hasn‚Äôt yet been staged. In the example on this slide, there is an untracked folder and file that are automatically saved:\n\n.ipynb_checkpoints contain old backup versions of our notebook which are saved by JupyterLab automatically.\n.DS_Store contains directory display options for the Finder application on MacOS.\n\nThe fact that they both start with a . means that they will be hidden in file browsers and in the output from ls in the terminal; an indication that they are not something that we need to work with manually, but are there for applications on our computer to use when needed.\nTherefore, we also don‚Äôt care about making these folders part of our version controlled project and we‚Äôd prefer not to have them clutter our view of the git status output, so that we instead can focus on the files we do want to track. How can we achieve this?"
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#create-a-.gitignore-file",
    "href": "modules/module4/slides/module4_11.html#create-a-.gitignore-file",
    "title": "What is .gitignore?",
    "section": "Create a .gitignore file",
    "text": "Create a .gitignore file\n\nUse a text editor of your choice (here we use VS Code) to create a file called .gitignore inside your Git repo:\ncode .gitignore\n\nInside the text file, list the files and folders you would like to ignore, one per line. For example:\n.ipynb_checkpoints/\n.DS_Store\n\nTo ‚Äúhide‚Äù folders and files from Git we can create a file called .gitignore in the root/main directory of our repository (the same directory where the .git folder is located). These two slides describe how we can create this file using VS Code, and what we need to add to it in order to ignore the two files from the previous slide."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#create-a-.gitignore-file-1",
    "href": "modules/module4/slides/module4_11.html#create-a-.gitignore-file-1",
    "title": "What is .gitignore?",
    "section": "Create a .gitignore file",
    "text": "Create a .gitignore file\n \nSave the file, add it to the staging area, and commit the changes with Git.  Then try git status again. You should now see that the files are ignored by Git:\n\ngit status\nOn branch main\nnothing to commit, working tree clean"
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#gitignore-tips-and-tricks",
    "href": "modules/module4/slides/module4_11.html#gitignore-tips-and-tricks",
    "title": "What is .gitignore?",
    "section": ".gitignore tips and tricks",
    "text": ".gitignore tips and tricks\n \nHere are two useful tricks so that you can avoid doing unnecessary work when it comes to .gitignore:\n\n\nRecursively ignoring filename patterns\nUsing .gitignore_global to ignore certain patterns in every repository\n\n\nWhile we could list out every file we want to ignore in every project‚Äôs .gitignore, this can quickly become tedious to type.\nInstead, we can use filename pattern matching and global Git settings to simplify this process. We will look closer at each of these two approach in the next couple of slides."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns",
    "href": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns",
    "title": "What is .gitignore?",
    "section": "1. Recursively ignoring of filename patterns",
    "text": "1. Recursively ignoring of filename patterns\n \nWildcards can be used inside .gitignore to ignore multiple files with the same name:\n*.log\n\nPrepending **/ to filenames ignores those files in subdirectories as well:\n**/*.log\n\nThe .gitignore file accepts wildcards for matching pattern names, similar to what we learned about for the shell in Module 2. So say that we e.g.¬†have a Git repository where a lot of log files files are created and they all end in .log. Instead of typing out the name of each file, we could add *.log to the .gitignore file and it would ignore all the log files in the root of the repository.\nIf we wanted to ignore the log files in every subdirectory of the project, we would need to use the **/ patterns, which means ‚Äúin any folder‚Äù. The line in our .gitignore would now read **/*.log."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns-1",
    "href": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns-1",
    "title": "What is .gitignore?",
    "section": "1. Recursively ignoring of filename patterns",
    "text": "1. Recursively ignoring of filename patterns\n \nStarting with a ! tells git to not ignore a certain directory.\n**/*.log\n!important/*.log\n\nWhat if we wanted to ignore all the log files, except those inside a specific directory? Let‚Äôs imagine the directory of the log files we want to keep is called important. We would now need to add two lines to our .gitignore: one to ignore all log files, and a second to tell git to not ignore the log files in the important directory. It would look like this:\n**/*.log\n!important/*.log"
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#using-.gitignore_global",
    "href": "modules/module4/slides/module4_11.html#using-.gitignore_global",
    "title": "What is .gitignore?",
    "section": "2. Using .gitignore_global",
    "text": "2. Using .gitignore_global\n \nCreate a global .gitignore file in your home directory so that you do not have to create the same .gitignore for all your repos\ncode ~/.gitignore_global\n\nNow comes the second trick: There might be certain files that you‚Äôd like to always get ignored in all repos. In that case, you can add them once to a global .gitignore file called .gitignore_global which lives in your home directory."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#using-.gitignore_global-1",
    "href": "modules/module4/slides/module4_11.html#using-.gitignore_global-1",
    "title": "What is .gitignore?",
    "section": "2. Using .gitignore_global",
    "text": "2. Using .gitignore_global\n \n\nJust like for a regular .gitignore file, add a list of files and folders that you want to get ignored in all repos on your computer\nSave .gitignore_global file and configure Git to exclude the file for every Git repository in your computer.\n\ngit config --global core.excludesfile ~/.gitignore_global\n\nThis way, you‚Äôll no longer need to add those particular files or folder names to the .gitignore file of each repo on your computer!\nYou can read more about ignoring files on the GitHub documentation"
  },
  {
    "objectID": "modules/module5/module5-00-module_learning_outcomes.html",
    "href": "modules/module5/module5-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module5/slides/module5_00.html#module-learning-outcomes",
    "href": "modules/module5/slides/module5_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nManage feature-based development efficiently with Git in JupyterLab and in the terminal.\nInfer a repository‚Äôs current status and collaboration pattern by looking at visualizations of the project history in VS Code.\nDifferentiate when to use forking or branching as a collaboration strategy.\nRecognize the essential components of a pull request.\nDetermine whether directly merging changes is preferable to first opening a pull request.\nExplain when GitHub issues are helpful and how to use them.\n\n\nIn this module you will discover how to efficiently collaborate with Git and GitHub by using branches, forks and pull requests."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#how-branches-are-related",
    "href": "modules/module5/slides/module5_03.html#how-branches-are-related",
    "title": "How branches are related?",
    "section": "How branches are related üôå",
    "text": "How branches are related üôå\n\n\nCreate and clone a Git repository to your computer.\nCreate 2 commits (e.g.¬†modifying README file).\nPush to GitHub.\nStart a new branch using the terminal or JupyterLab.\nCreate 2 commits in the new branch.\nGo back to the main branch.\nCreate 2 commits in the main branch.\n\n\nBefore moving forward, let‚Äôs practice!\nRemember that after you create the branch you are always going to be working on that new branch. If you want to go back to your original branch you can (1) click the name of the branch you want to return in the Branches tab (JupyterLab) or (2) run git switch &lt;branch-name&gt; (terminal).\nWe will use the repository you just created as an example for the rest of this module."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-terminal",
    "href": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-terminal",
    "title": "How branches are related?",
    "section": "Seeing how branches are related (terminal)",
    "text": "Seeing how branches are related (terminal)\n\ngit log --oneline --all --graph\n\n\n\nFor this section we are going to simulate that we start working on a project. After cloning the repository for the first time we want to see what the branches look like. To see all branches as well as a graph indicating their relationship, we can type git log --oneline --all --graph in the terminal.\nYou can clone any repository on github.com and run this command to visualize the project history. For example, in the image we are visualizing the repository of the open source project Glosario using the History tab of JupyterLab and also the command git log --oneline --all --graph in the terminal. Glosario is an open source glossary of terms used in data science that is available online and also as a library in both R and Python.\nRemember that you can use space on your keyboard to page down through the commit history and b to page up. Press q to exit back out to the terminal."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-vs-code",
    "href": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-vs-code",
    "title": "How branches are related?",
    "section": "Seeing how branches are related (VS Code)",
    "text": "Seeing how branches are related (VS Code)\n\n\n\nEven if the branch representations that we can view in the terminal and JupyterLab are correct, it is not as detailed as the one we can get from VS Code.\nOpen the current folder in VS Code by typing code . inside your git folder (remember that . is a shortcut that means ‚Äúcurrent directory‚Äù). In VS Code, go to the extensions tab and search for ‚Äúgit history‚Äù, install the extension. Then go to View -&gt; Command Palette and start writing Git: View History (git log). A new tab will open with the Git History. If you want to display all the branches you will have to select them in one of the menus as you can see in the image.\nWhere it currently says main, change it to show ‚ÄúAll branches‚Äù and you should now see a nice graphical overview looking like the one in the picture. If the Git history view hangs or looks strange, press ‚ÄúRefresh‚Äù. You‚Äôre free to use the one you prefer between VS Code and git log, but many of the commands are the easiest to run via terminal."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#observing-the-trees",
    "href": "modules/module5/slides/module5_03.html#observing-the-trees",
    "title": "How branches are related?",
    "section": "Observing the trees",
    "text": "Observing the trees\n\n\n\nDownloading a public GitHub repository from a project you like and observing the number of branches is an excellent exercise. For example you can try to determine how many branches exist that have not been merged and where the most recent modifications have occurred.\nUnderstanding these graph-based commit history visualizations is helpful to understand the relationships between branches, provides vital information about the structure of a project, and can help you fix problems if they arise.\nIn this slide, you can see the public repository of JupyterLab that has been cloned and opened using VS Code. Here we can see that there are three active branches:\n\nThe default master branch which is indicated on the topmost row. This is the orange line in the graphical representation to the left and there are five commits visible in this image on this branch (the black dots on the orange line).\nThe branch for version 3.4 which is indicated on the second row from the top. This is the middle red line in the graphical representation and there are three commits visible in this image on this branch.\nThe branch with a long name starting with 12758-snapshots at the third row from the bottom (commit message: ‚ÄúUpdate snapshots for challenger commit‚Äù). This is the red line in the graphical representation to the right, and it contains only a single commit."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#when-merging-branches-goes-social",
    "href": "modules/module5/slides/module5_07.html#when-merging-branches-goes-social",
    "title": "When merging branches goes social: opening pull requests",
    "section": "When merging branches goes social",
    "text": "When merging branches goes social\n \n\nWhen I first started we all pushed to one branch, but the problem is you push and nobody knows what changes are going through and there is no chance for a review. Our current system is that you don‚Äôt make any changes without submitting a pull request[‚Ä¶]and then one or more members will review it and you need one thumbs up from another team member to merge it, otherwise it can‚Äôt go in.\n\n‚Äî Kalliamvakou, E. (2014). The Code-Centric Collaboration Perspective: Evidence from GitHub.\n\nPull requests involve merging someone else‚Äôs changes into your remote repository on GitHub. They are essential for team collaboration and proper pull request review is critical for for ensuring code quality.\nIn the previous part, we did not push our feature branch to GitHub. Instead, we finished the development of this branch locally and merged it into our main branch using JupyterLab GUI or the command git merge.\nWhen working as a team, it is recommended to push your code to GitHub first and then make a pull request so that others can review it and suggest any needed adjustments before merging it."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nTo create a pull request, you have to push the changes in your branch to GitHub. After doing so, a message will appear at the top of the repository interface on GitHub and you can click the green button that says ‚ÄúCompare and pull request‚Äù."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request-1",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request-1",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nAfter clicking ‚ÄúCompare and pull request‚Äù, you will be taken to a screen that looks like the screenshot in this slide. The dropdown menus on top indicate the branches the pull request is related to. As general rule you are going to be opening pull requests from your feature branch with the main branch as the ‚Äúbase‚Äù, but GitHub allows you to change the base branch (the leftmost arrow in the slide) and the branch to pull the changes from (the right most arrow in the slide).\nYou should include a descriptive title for your pull request and elaborate on your suggested changes in the comment section. Remember that you can use Markdown to format the message content and that you can use the tab Preview to view what the rendered Markdown will look like before creating the pull request.\nIn the body of the message you can also indicate if it is fixing a currently open issue by typing close #1 to close issue number 1 (pull requests and issues use the same numbering system, so if there is already an open issue, the first PR would be get the number 2)."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request-2",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request-2",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nThe next step is for the upstream repository maintainers to review your work and merge it in if they approve it. You have the option of assigning someone to a pull request and/or designating the parson as reviewer.\n\nReviewers: You can choose anyone who can help from the list of prior authors that GitHub will offer as reviewers for that code. A review request will be sent to the reviewers and you will obtain a notification and email once they have submitted their feedback. If you are working with a team you will probably define guidelines for which team member reviews which PRs.\n\nAnother useful thing that you can do is to label each pull request, they can help you by grouping similar pull requests together, e.g.¬†‚ÄúBug fixes‚Äù, ‚ÄúEnhancements‚Äù, etc."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request-3",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request-3",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nOnce you have opened a pull request you can continue adding commits by pushing them to your feature branch on GitHub (the commits will appear in chronological order). This means that you can open the pull request before finishing the work and doing so is a way to communicate that you are preparing changes to merge in main (or another branch) that will need review.\nUntil the PR is ready for review, you can open it as a ‚ÄúDraft‚Äù by clicking the dropdown arrow on the green button that says ‚ÄúCreate Pull Request‚Äù and mark it as ‚ÄúReady for review‚Äù later."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#pull-request-successfully-merged-and-closed",
    "href": "modules/module5/slides/module5_07.html#pull-request-successfully-merged-and-closed",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Pull request successfully merged and closed",
    "text": "Pull request successfully merged and closed\n\ngit push &lt;remote&gt; --delete &lt;branch&gt;\n\n\n\nAfter a collaborator has reviewed your changes and approved the pull request, they or you can click the Merge button and accept the pull request Then, GitHub will offer you to delete the branch via the web interface. To do this you should click Delete branch button.\nPay attention to the fact that deleting a remote branch won‚Äôt affect the local branch report in your local repository. Instead, the label origin/report will disappear from your git logor project history visualisation. You still have to delete the local version of report if you want to get rid of that branch as we learned some minutes ago.\nIt is possible to delete the remote branch from the terminal using the command git push &lt;remote&gt; --delete &lt;branch&gt;. For example, the command git push origin --delete report would allow you to perform the same action that we did on GitHub in the image.\nAlthough it is not necessary to remove a branch after merging it, doing so can help to keep your repository tidy."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#collaborative-work",
    "href": "modules/module5/slides/module5_11.html#collaborative-work",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Collaborative work",
    "text": "Collaborative work\nThere are two main strategies we can use to work with others:\n\nBranching\n Forking \n\n\nWe have learned that if you create your repository on GitHub or you are part of a team with write access to a repo, then you can clone it to your computer, make changes and then push them back to this repository. We called this style of collaboration branching.\nIf you want the code from someone else‚Äôs repository but you are not an official collaborator, you can clone it and use it on your computer. However, you cannot push your changes back to the GitHub repository because you don‚Äôt have write permissions to the repository.\nIt would still be beneficial for the repository‚Äôs owners to receive your contributions if you make code enhancements, without having to grant you full access and run the risk of breaking something. Instead of working directly on the repository, you can fork (copy) someone else‚Äôs repository and work on a branch in your own copy."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#how-can-i-fork-a-repository",
    "href": "modules/module5/slides/module5_11.html#how-can-i-fork-a-repository",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "How can I fork a repository?",
    "text": "How can I fork a repository?\n\n\n\nGo to the GitHub page of the project that you want to fork. In the upper right corner, click the icon that says ‚Äúfork‚Äù. That‚Äôs it! You just forked a repo!\n\nForks are copies of other‚Äôs repositories on GitHub that you own. You can do anything you want on your fork. If you make improvements, you can send a notification to the owner of the ‚Äúupstream‚Äù repository (the one you forked from) and request that they pull the code from your repository (referred to as ‚Äúorigin‚Äù) into theirs. As we learned earlier, this is referred to as a ‚Äúpull request‚Äù, and includes a review of the code from the maintainers of the upstream repository as we discussed in the last section.\nThe fork workflow is used in many open source projects where there is often a small team of core maintainers, but contributions from many more users. For example, the JupyterLab project has around 10 members in their team, but more than 300 people have contributed code to the project and almost 2 000 has forked it.\nIn the example, we are forking the repository of the project Glosario from The Carpentries, a multilingual glossary for computing and data science terms that is also an open-source project. As you can see in the image, this repository has been forked by 168 users so far.\nüôå Go to the GitHub page of the project that you want to fork. In the upper right corner, click the icon that says ‚Äúfork‚Äù. That‚Äôs it! You just forked a repo!"
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#developing-on-a-forked-repo",
    "href": "modules/module5/slides/module5_11.html#developing-on-a-forked-repo",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Developing on a forked repo",
    "text": "Developing on a forked repo\n\n\n\nTo start developing on a fork, first clone it to your computer (your fork, not the upstream repo). It is good practice to always create a branch when you are about to add changes to a fork, and in many projects this is required, so they will not accept a pull request that comes from your main branch. This is because it is easier to keep track of branches with descriptive names compared to having all pull request branches names main, but coming from different people.\nWhen you are working on a branch you have to push your changes to GitHub and ask for it to be merged via a pull request. Since you don‚Äôt have write access to the upstream repo, you have to request that the maintainer pull your code (remember that merging is part of what happens during a pull request, so this is similar to what we did with branches via git merge, just that the code first needs to be fetched from your forked repo)"
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#keeping-your-remote-origin-up-to-date-with-the-upstream-remote",
    "href": "modules/module5/slides/module5_11.html#keeping-your-remote-origin-up-to-date-with-the-upstream-remote",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Keeping your remote (origin) up to date with the upstream remote",
    "text": "Keeping your remote (origin) up to date with the upstream remote\n\n\n\nForking a repo happens via the GitHub web interface, but this is a one time operation. If there are changes made to the upstream repo that you want to sync to your forked repo (origin), you have to first pull them from the upstream remote to your forked remote (origin).\nTo solve this you can update your forked repository with the button Sync fork. Then you can pull this changes to continue working locally before opening the pull request. In the example there are not changes in the repository that I have just forked, but if this was the case I would have to select the option update branch."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#create-a-pull-request-from-the-forked-repository",
    "href": "modules/module5/slides/module5_11.html#create-a-pull-request-from-the-forked-repository",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Create a pull request from the forked repository",
    "text": "Create a pull request from the forked repository\n\n\n\nWhen you finish your local changes and you push to the fork that lives in your user‚Äôs account, you can create the pull request to the upstream repository if you click in the Contribute button. If you have added some commits, the Open pull request option will be available.\n‚ö†Ô∏è You should read the CONTRIBUTING.md file before making your first contribution to a new open-source project. There you will find relevant instructions on how to participate in the project. Another file you must read is the CODE_OF_CONDUCT.md. There, you will discover information on who to contact if you ever feel uncomfortable working on the project as well as other guidelines you should adhere to in order to foster a welcoming and supportive environment among the contributors.\nBoth files are typically located in the root of the repository."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#communicating-using-github-issues",
    "href": "modules/module5/slides/module5_11.html#communicating-using-github-issues",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Communicating using GitHub issues",
    "text": "Communicating using GitHub issues\nThe ‚ÄúIssues‚Äù tab on the GitHub web interface\n\n\n\nRegardless of whether you are collaborating with forks or using branches directly on the main repo, you don‚Äôt just want a historical record of who changed what file and when in the project. When working on a any collaborative project, you also want a record of decisions that were made, ideas that were floated, problems that were identified and addressed, and all other communication surrounding the project.\nEmail and messaging apps are both very popular for general communication, but are not designed for project-specific communication: they often lack functionality for organizing conversations by project subtopics, searching for conversations related to particular bugs or software versions, etc.\nüôå To open a GitHub issue, first click on the ‚ÄúIssues‚Äù tab, and then click the green button that says ‚ÄúNew Issue‚Äù."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#communicating-using-github-issues-1",
    "href": "modules/module5/slides/module5_11.html#communicating-using-github-issues-1",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Communicating using GitHub issues",
    "text": "Communicating using GitHub issues\nDialog boxes and submission button for creating new GitHub issues.\n\n\n\nGitHub issues are an alternative written communication medium to email and messaging apps, and were designed specifically to facilitate project-specific communication. Issues are opened from the ‚ÄúIssues‚Äù tab on the project‚Äôs GitHub page, and they persist there even after the conversation is over and the issue is closed (in contrast to email, issues are not usually deleted). One issue thread is usually created per topic, and they are easily searchable using GitHub‚Äôs search tools.\nAll issues are accessible to all project collaborators, so no one is left out of the conversation. If someone mention your name with the syntax @yourname, you will get a notification. If you want to be notified about all new issues and pull requests you can click the little eye icon in the top right corner that says ‚ÄúWatch‚Äù. Replying to issues from email is also possible. Given all of these advantages, we highly recommend the use of issues for project-related communication."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#communicating-using-github-issues-2",
    "href": "modules/module5/slides/module5_11.html#communicating-using-github-issues-2",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Communicating using GitHub issues",
    "text": "Communicating using GitHub issues\nThe ‚ÄúClosed‚Äù issues tab on the GitHub web interface.\n\n\n\nüôå When a conversation is resolved, you can click ‚ÄúClose issue.‚Äù The closed issue can be later viewed by clicking the ‚ÄúClosed‚Äù header link in the ‚ÄúIssue‚Äù tab. Issues will be automatically closed if you merge a PR that refers to the issue.\nAlthough you might think that GitHub issues are mostly for collaborative projects, they are highly useful for individual projects too, as it is important to record ideas and decisions for yourself in the future.\nGitHub has recently also improved issues capabilities to be used for project management, so that you don‚Äôt need to use a separate program for that. It is beyond the scope of this course to go through this topic in detail, but you can find more information about GitHub issues on this page."
  }
]