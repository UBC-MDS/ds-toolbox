[
  {
    "objectID": "modules/module5/slides/module5_13.html#module-learning-outcomes",
    "href": "modules/module5/slides/module5_13.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 5",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nManage feature-based development efficiently with Git in JupyterLab and in the terminal.\nInfer a repository‚Äôs current status and collaboration pattern by looking at visualizations of the project history in VS Code.\nDifferentiate when to use forking or branching as a collaboration strategy.\nRecognize the essential components of a pull request.\nDetermine whether directly merging changes is preferable to first opening a pull request.\nExplain when GitHub issues are helpful and how to use them.\n\n\nNow is time to work!"
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#lets-work-together",
    "href": "modules/module5/slides/module5_09.html#lets-work-together",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Let‚Äôs work together!",
    "text": "Let‚Äôs work together!\n\n\n\nArtwork by @allison_horst\n\nWe have already seen some ways in which Git and GitHub allow collaboration with others. Here we will dive more in depth into which collaborative workflows are the most effective when multiple people are contributing code to the same repository.\nArtwork by @allison_horst"
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#branching-and-forking",
    "href": "modules/module5/slides/module5_09.html#branching-and-forking",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Branching and forking",
    "text": "Branching and forking\nThere are two main strategies we can use to work with others:\n\nBranching\nForking\n\n\nThere are two major ways to work in a collaborative basis using Git and GitHub:\n\nWorking with colleagues in a repository where all of you are members with permission to push code. We call this strategy branching.\n\nIf you start a new repository with some coworkers and you add them as collaborators, you can all contribute to it using branching.\n\nContributing to a repository that you don‚Äôt have access to using a GitHub tool called forking.\n\nThe use of forks is common when collaborating on online repositories where you don‚Äôt have write access, such as open source projects led by someone else.\nAs an example imagine that you want to contribute to this multilingual glossary for computing and data science terms created by The Carpentries, an inclusive community willing to teach data and coding skills.\nIf you explore the GitHub repo of the project (https://github.com/carpentries/glosario) you will see a file called CONTRIBUTING.md where it is explained how someone can add new terms to the glossary.\nIn general, when you want to contribute to a public repository as this one, you will have to fork the repository first because you don‚Äôt have write access. Forking it allow you to create a copy in your GitHub account of the repository at that moment."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#collaborative-work",
    "href": "modules/module5/slides/module5_09.html#collaborative-work",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Collaborative work",
    "text": "Collaborative work\nThere are two main strategies we can use to work with others:\n\n Branching \nForking\n\n\nIn the next slide deck we will focus on forking, but let‚Äôs start by learning about the branching strategy first!\nBefore we dive in, remember that regardless of whether you are collaborating via branching or forking, the most common practice before accepting contributions to the main branch involves opening a pull request with the proposed changes and ask for a review before merging those changes."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project",
    "href": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Giving collaborators access to your project",
    "text": "Giving collaborators access to your project\nThe ‚ÄúInvite a collaborator‚Äù button on the GitHub web interface.\n\n\nWhen working with a branching workflow, all collaborators need to have ‚Äúwrite access‚Äù to the remote repository so that they can push up their branches to GitHub. As mentioned earlier, GitHub allows you to control who has access to your project. The default of both public and private projects are that only the creator of the GitHub repository has permissions to create, edit and delete files (write access). Go to the ‚ÄúSettings‚Äù tab if your repostiroy on GitHub and select ‚ÄúCollaborators‚Äù There, you must click the green ‚ÄúAdd people‚Äù button."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project-1",
    "href": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project-1",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Giving collaborators access to your project",
    "text": "Giving collaborators access to your project\n\n\n\nThen type in the collaborator‚Äôs GitHub username or email, and select their name when it appears.\nAfter this, you should see your newly added collaborator listed under the ‚ÄúManage access‚Äù tab. They should receive an email invitation to join the GitHub repository as a collaborator. They need to accept this invitation to enable write access."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#branch-protection-rules",
    "href": "modules/module5/slides/module5_09.html#branch-protection-rules",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Branch protection rules",
    "text": "Branch protection rules\nUnder ‚ÄúBranch name pattern‚Äù, type the branch name or pattern you want to protect.\n\n\n\nNow that everyone has access, they can clone the repository and create a branch using a meaningful name with the feature they are willing to work on. If some of the collaborators push to main without communicating it to the other team members first could it create merging problems. To reduce that risk, you can set up a branch protection rule in the repository, which requires a pull request before merging any code into the protected branch.\nüôå To add a branch protection rule you can go to Settings &gt; Code and Automation (sidebar) &gt; Branch protection rules and click ‚ÄúAdd rule‚Äù.\nüôå Under ‚ÄúBranch name pattern‚Äù, type the branch name or pattern you want to protect. Notice that you can create protect branches different to main but we will not cover those use cases in this tutorial."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#branch-protection-rules-1",
    "href": "modules/module5/slides/module5_09.html#branch-protection-rules-1",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Branch protection rules",
    "text": "Branch protection rules\n\n\n\nIf you think in the analogy of the house, protecting the main branch would be similar to avoid creating modifications in the foundation of the house meanwhile each member is working in different sections. This makes sense since any changes in the house‚Äôs foundation could give rise to problems when combining the parts, including the risk of collapsing the house.\nIn your repository, this means that you should be sure that code in main, also called the production branch, is high quality code without bugs or other run problems. Each time you accept merging a contribution of another team member in main be sure that the code is doing what is expected and it is well documented. This way you will always have stable and well build code that runs propoperly in your main branch. This ensures that you are producing code in an organized way.\nUsing branch protection rules is a team decision that could prevent the error of pushing to the main branch without notifying your colleagues. If you made only minor edits the team might let you merge these to main locally and then push up the updated main branch (or even let you not create a branch in the first place).\n‚ö†Ô∏è Remember to get the input from other team members before deciding to implement branch protection, so that everyone in your team is on the same page."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#how-pull-requests-look-like-after-you-protect-the-branch",
    "href": "modules/module5/slides/module5_09.html#how-pull-requests-look-like-after-you-protect-the-branch",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "How pull requests look like after you protect the branch",
    "text": "How pull requests look like after you protect the branch\n\n\n\nThis is how pull requests look like after you protect the branch. You will need the approval of a team member before you can merge the pull request."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#a-basic-branching-workflow",
    "href": "modules/module5/slides/module5_09.html#a-basic-branching-workflow",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "A basic branching workflow",
    "text": "A basic branching workflow\n\nClone the project - To work locally.\nCreate your branch - Create code or apply your changes.\nMake the desired modifications - Adding a new feature, fixing a bug, etc.\nPush your changes - This will upload your branch to GitHub\nCreate a pull request - So that your changes can be reviewed by another team member.\n\nRemember to pull the changes before starting to work in the repository\n\nGiving your collaborators access to your repository is mandatory to collaborate using branches. Protecting the main branch is considered good practice but experienced users that are very familiar with the workflow could opt to not use this strategy.\nThe workflow will be the same that we have learned before, cloning, adding to the staging area, committing the changes and pushing to the repo with the only difference being that you will have to create a pull request. Merge conflicts could happen and you can use the strategies you have learned in the past modules to resolve them.\nWe are ready to start collaborating!"
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#merging-branches",
    "href": "modules/module5/slides/module5_05.html#merging-branches",
    "title": "Merging branches",
    "section": "Merging branches",
    "text": "Merging branches\n\n\n\nOnce you have finished your modifications in the branch you are working on, it is time to merge your changes to the main branch!\nUpon merging, the changes you were working on in a particular branch are combined with the content of the main branch (or any other branch that you decide to merge your changes with).\nWhen you merge two branches you are creating a new commit with the combined changes. In the image, these commits are represented by yellow circles."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#merging-branches-jupyterlab",
    "href": "modules/module5/slides/module5_05.html#merging-branches-jupyterlab",
    "title": "Merging branches",
    "section": "Merging branches (JupyterLab)",
    "text": "Merging branches (JupyterLab)\n\n\n\nTo merge a branch using JupyterLab, you have to click on the tab Branches and then on the name of the branch you want to merge your current work into. For example, if you are working on the branch main, you can click next to the report branch in the side panel and select ‚ÄúMerge this branch into the current branch‚Äù.\nNotice that after doing this, the report branch is not deleted automatically, so you can still access it if you need to."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#merging-branches-terminal",
    "href": "modules/module5/slides/module5_05.html#merging-branches-terminal",
    "title": "Merging branches",
    "section": "Merging branches (Terminal)",
    "text": "Merging branches (Terminal)\n\ngit merge &lt;branch&gt;\n\n\n\nIf you want to use the terminal to merge the branches and you are currently working on the main branch, you can type git merge &lt;branch&gt; to merge the commits from the branch with the new feature into the main branch. In this slide, we merged in the changes of the branched named report into main by typing git merge report while having the main branch active."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#visualizing-merged-branches",
    "href": "modules/module5/slides/module5_05.html#visualizing-merged-branches",
    "title": "Merging branches",
    "section": "Visualizing merged branches",
    "text": "Visualizing merged branches\n\n\n\nLet‚Äôs see how VS Code‚Äôs graphical representation of the Git history changed when we merged the branches together. Remember that you can open VS Code from the terminal using the command code .. Then go to View &gt; Command Palette and start writing Git: View History (git log). A new tab will open with the Git History. If you want to display all the branches you will have to select them in one of the menus. In this view, we can see that the line for our branch has re-connected to the main branch with a merge commit."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#deleting-branches-jupyterlab",
    "href": "modules/module5/slides/module5_05.html#deleting-branches-jupyterlab",
    "title": "Merging branches",
    "section": "Deleting branches (JupyterLab)",
    "text": "Deleting branches (JupyterLab)\n\n\n\nYou will notice that merging the branch will not automatically delete it. If you are not going to be developing that feature anymore you can delete the branch after merging it by clicking on the small garbage bin icon in the Branches tab.\nYou can only delete a branch when you are not working on it (it is not highlighted in blue in the JupyterLab UI) and although it can be difficult to recover the information after it is deleted, you can safely do so after successfully merging the changes into another branch."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#deleting-branches-terminal",
    "href": "modules/module5/slides/module5_05.html#deleting-branches-terminal",
    "title": "Merging branches",
    "section": "Deleting branches (terminal)",
    "text": "Deleting branches (terminal)\n\ngit branch -d &lt;branch-name&gt;\n\n\n\nIf you want to delete the branches using the terminal you can use the command git branch -d &lt;branch-name&gt;. Be careful! You should use -d and NOT -D. If you write the flag with a capital -D it will force the deletion, even if the branch has not been merged yet, what could be dangerous. If you add the d flag, it will only delete the branch after it has been merged.\nNow that you have a better grip on how to read the Git history and how to merge branches, it will be easier to work with both branches and forks!"
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#what-is-a-branch",
    "href": "modules/module5/slides/module5_01.html#what-is-a-branch",
    "title": "The role of branches",
    "section": "What is a branch?",
    "text": "What is a branch?\n\n\nIn Git, a branch represents an isolated line of commits in a repository. By default, you will always start working on the so called main branch. Creating a new branch allows you to work on a series of commits in isolation from the main branch.\nThis is beneficial since you don‚Äôt want the repository‚Äôs default branch to be updated with every commit of a half-finished feature. Instead, new features are developed on separate branches that will be ‚Äúmerged‚Äù into the main branch once the development of that feature is finished. The separation of feature branches from the main branch facilitates parallel development where progress can be made on multiple independent features simultaneously.\nTo illustrate feature-based development with a practical example, we can use the construction of a house as you can see in this slide (each dot represent a commit). First, you need to build the foundation. Since everything depends on the foundation being built, this would be developed on the main branch. When the foundation is finished the construction of other parts of the house that don‚Äôt depend on each other could take place in parallel, e.g.¬†some contributors might start working on the walls and others on the floor. When either of these features is finished, it can be added back to the house (what would be similar to merged into main)."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#when-should-a-new-branch-be-opened",
    "href": "modules/module5/slides/module5_01.html#when-should-a-new-branch-be-opened",
    "title": "The role of branches",
    "section": "When should a new branch be opened?",
    "text": "When should a new branch be opened?\n\nWhen we initiate a repository by default we start working on the main branch, but we can be working in parallel in other features.\n\nIn the image we can see that two branches were created from main. The first one, feat-trained-model, is based on the state of the repository at the third commit to the main branch. The second branch is called fix-eda-plot and was initiated from the fourth commit of the main branch to fix one of the exploratory analysis plots. At the end we merge all these branches to main so the isolated modifications are included in the principal branch of our repository.\nWhen should a new branch be opened? Generally speaking, you can assume that every modification that has the potential to break the original code is suitable to be developed in its own feature branch to avoid the risk of it changing how the code in the main branch works.\nNote that the name main for the default branch is just a convention and in some old repositories the default branch could be called master instead of main."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab",
    "title": "The role of branches",
    "section": "How to create a branch? (JupyterLab)",
    "text": "How to create a branch? (JupyterLab)\n\n\n\nTo create a branch in JupyterLab you have to go to Branches &gt; New branch and then write the name of the branch there. If you want to create the new branch based on another branch than main you can click and select it in the menu. You can always switch easily between branches on the Branches tab in the side bar.\nIn this slide, the options available are to create a branch from main, from origin/HEAD and origin/main. We already know that main is the default branch, but what about origin and HEAD?\nThe material of this module is based on the book by Timbers, T., Campbell, T., & Lee, M. (2022). Data science: A first introduction. CRC Press and the course DSCI 521: Computing Platforms for Data Science from the UBC Master of Data Science."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab-1",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab-1",
    "title": "The role of branches",
    "section": "How to create a branch? (JupyterLab)",
    "text": "How to create a branch? (JupyterLab)\n\n\n\nIn the terminal, you can use git log --oneline to check the history of your project, and see which commits correspond to the names origin/HEAD, origin/main and main. You can also see that the currently active branch is shown in cyan at the end of the terminal prompt.\n\nmain is your default local branch.\nHEAD is pointing where you currently are (in this case, on the main branch)\norigin is a nickname for your remote repo on GitHub (instead of showing the full URL), so origin/main is the main branch of the version of the repo you pushed to GitHub.com.\n\nYou don‚Äôt need to care about origin/HEAD, it just point to the default remote branch, which will always be main unless you mess around with the settings on the GitHub webpage.\nIn JupyterLab you can see this information as labels under the tab Changes in the sidebar.\n‚ö†Ô∏è Here we added a new synonym for a GitHub repository. Previously, we were using remote as a way to refer to any GitHub repository. Here Git refers to the default remote in which we are working on with the nickname origin."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal",
    "title": "The role of branches",
    "section": "How to create a branch? (Terminal)",
    "text": "How to create a branch? (Terminal)\n\ngit switch -c &lt;branch-name&gt; &lt;commit-hash&gt;\n\n\n\nThe git switch command can be used to alternate between existing branches. If a branch does not yet exist, you can append the -c flag to create the branch as you switch to it. Let‚Äôs create a new branch! Type git switch -c &lt;branch-name&gt;, to create and switch to this branch. If you want to create a branch starting in a particular commit you should add the commit hash as another argument. In the example, the branch is created from the last commit, that is the default behaviour when a commit hash is not included.\nAfter creating the branch, you will switch to working on there. In the terminal, you‚Äôll notice that the name of the new branch, in this case report, appears now in parenthesis in the terminal. Also, the Current branch tab in JupyterLab is updated, and the new branch is now listed there.\nüôå\nTo practice working with branches, let‚Äôs try adding a commit to one of your example repositories and check what happens in JupyterLab (tab Changes) and with the command line (running the command git log --oneline):\n\nBefore and after doing a commit.\nBefore and after pushing to the remote."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal-1",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal-1",
    "title": "The role of branches",
    "section": "How to create a branch? (Terminal)",
    "text": "How to create a branch? (Terminal)\n\n\n\nLet‚Äôs see what happens when we make a commit locally.\n\nEdit your README to append one more line of your choice, then add it to the staging area and commit it.\nRun git log --oneline\n\nAs expected, only the reference to where we are currently (HEAD) and the report branch moved, because we have not pushed the changes to our GitHub remote (origin). If you push your changes, the GitHub main branch (origin/main) will also be updated with the latest commit. To confirm this, you can run git log --oneline after pushing the new commit to GitHub.\nBut how can we push a local branch to GitHub?"
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#pushing-a-new-branch",
    "href": "modules/module5/slides/module5_01.html#pushing-a-new-branch",
    "title": "The role of branches",
    "section": "Pushing a new branch",
    "text": "Pushing a new branch\n\ngit push --set-upstream origin &lt;new-branch-name&gt;\n\n\n\nPushing a new branch using JupyterLab is exactly the same as you are used to with the ‚Äúpush‚Äù button. However, there is a slight change in the command when you are pushing a branch you created locally with the terminal. Instead of git push you will have to write:\ngit push --set-upstream origin &lt;new-branch-name&gt;\nThis command decides what the new branch will be called on the remote GitHub repo. It is recommended that you use the same name as you use locally, and using a different name is rarely necessary. You don‚Äôt need to worry about remembering this command, because git will remind you in the case you forget to specify it as you can see in the image.\nAfter pushing the new branch report to the remote you will notice that the local branch report and the remote branch origin/report are placed in the same commit when you read the history of the project. This means that your remote repository is synchronized with your local repository."
  },
  {
    "objectID": "modules/module5/module5-13-what_did_we_just_learn.html",
    "href": "modules/module5/module5-13-what_did_we_just_learn.html",
    "title": "7. What Did We Just Learn?",
    "section": "",
    "text": "7. What Did We Just Learn?\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "7. What Did We Just Learn?"
    ]
  },
  {
    "objectID": "modules/module5/module5-11-collaborative_github_workflows:_forking.html",
    "href": "modules/module5/module5-11-collaborative_github_workflows:_forking.html",
    "title": "6. Collaborative GitHub workflows: Forking",
    "section": "",
    "text": "6. Collaborative GitHub workflows: Forking\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "6. Collaborative GitHub workflows: Forking"
    ]
  },
  {
    "objectID": "modules/module5/module5-09-collaborative_github_workflows:_branching.html",
    "href": "modules/module5/module5-09-collaborative_github_workflows:_branching.html",
    "title": "5. Collaborative GitHub workflows: Branching",
    "section": "",
    "text": "5. Collaborative GitHub workflows: Branching\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "5. Collaborative GitHub workflows: Branching"
    ]
  },
  {
    "objectID": "modules/module5/module5-07-when_merging_branches_goes_social:_opening_pull_requests.html",
    "href": "modules/module5/module5-07-when_merging_branches_goes_social:_opening_pull_requests.html",
    "title": "4. When merging branches goes social: opening pull requests",
    "section": "",
    "text": "4. When merging branches goes social: opening pull requests\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "4. When merging branches goes social: opening pull requests"
    ]
  },
  {
    "objectID": "modules/module5/module5-05-merging_branches.html",
    "href": "modules/module5/module5-05-merging_branches.html",
    "title": "3. Merging branches",
    "section": "",
    "text": "3. Merging branches\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "3. Merging branches"
    ]
  },
  {
    "objectID": "modules/module5/module5-03-how_branches_are_related.html",
    "href": "modules/module5/module5-03-how_branches_are_related.html",
    "title": "2. How branches are related?",
    "section": "",
    "text": "2. How branches are related?\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "2. How branches are related?"
    ]
  },
  {
    "objectID": "modules/module5/module5-01-the_role_of_branches.html",
    "href": "modules/module5/module5-01-the_role_of_branches.html",
    "title": "1. The role of branches",
    "section": "",
    "text": "1. The role of branches\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "1. The role of branches"
    ]
  },
  {
    "objectID": "modules/module4/slides/module4_13.html#module-learning-outcomes",
    "href": "modules/module4/slides/module4_13.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 4",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nExplore the Git history via git log in the terminal, and the equivalent functions in JupyterLab and GitHub.\nCompare commits using git diff in the terminal, and the equivalent functions in JupyterLab and GitHub.\nSolve merge conflicts at the command line and in VS Code.\nAvoid pushing certain local files by including a .gitignore file.\nDifferentiate between doing a revert and a hard reset of a commit when restoring an older version of a project.\n\n\nThe assignment will concentrate on the learning objectives as well as building knowledge on existing concepts."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise",
    "href": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise",
    "title": "Handling merge conflicts",
    "section": "When does a merge conflict arise?",
    "text": "When does a merge conflict arise?\n\n\n\nAs we mentioned a few slide decks ago, it is good practice to pull any changes at the start of every work session before you start working on your local copy. If you forget to do this you might end up in a situation where your collaborators have pushed some changes to the remote that you don‚Äôt have locally.\nThe solution to this situation is usually simple: you pull down the remote changes to your computer and let Git automatically merge the changes for you, which often works well even if you and your collaborators were working on different parts of the same file!\nHowever, if you and your collaborators made changes to the same line(s) of the same file(s), Git will not be able to automatically merge the changes since it doesn‚Äôt know whether to keep your version of the line(s), your collaborator‚Äôs version of the line(s), or some blend of the two. When this happens, Git will inform you that you have a ‚Äúmerge conflict‚Äù in certain file(s) and let you decide how to solve the issue."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise-1",
    "href": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise-1",
    "title": "Handling merge conflicts",
    "section": "When does a merge conflict arise?",
    "text": "When does a merge conflict arise?\n\n\n\nYou also can visualize the merge conflict as an error when you try to push your local changes to GitHub.\nImagine that at least one commit in the remote repository and one in your local repository are incompatible to combine without overwriting a portion of the work. This is why attempting to pull or push modifications will result in an error. Git is unable to merge the remote and the local version."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: Terminal",
    "text": "Handling merge conflicts: Terminal\ngit status\nOn branch main\nYour branch and 'origin/main' have diverged,\nand have 2 and 1 different commits each, respectively.\n  (use \"git pull\" to merge the remote branch into yours)\n\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add &lt;file&gt;...\" to mark resolution)\n        both modified:   README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nIf you are using the terminal, you can detect which files are affected in the merge conflict with the command git status.\nEvery file affected by a merge conflict will be listed in the ‚ÄúUnmerged paths‚Äù, in the example we can see that there is a merge conflict on the README.md file."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-1",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-1",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: Terminal",
    "text": "Handling merge conflicts: Terminal\n\n\n\nIn a merge conflict, Git will create marks in the affected files that indicate which areas it is unsure how to handle. To resolve a merge conflict, you need to open the indicated file in a plain text editor and edit the marked up content in a way so that Git knows which changes you want to keep.\nYou can click on the file and select the Option Open With Editor -&gt; Editor"
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-2",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-2",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: Terminal",
    "text": "Handling merge conflicts: Terminal\n\n\n\nOnce you open the file, you have to find the merge conflict. The beginning of the merge conflict is preceded by &lt;&lt;&lt;&lt;&lt;&lt;&lt; and the end of the merge conflict is marked by &gt;&gt;&gt;&gt;&gt;&gt;&gt;. Between these markings, Git also inserts a separator (=======). The version of the change before the separator is your change (marked with HEAD), and the version that follows the separator was the change that existed on GitHub (marked with the commit hash). In the image, you can see that in your local repository the README.md title is Canadian languages. It looks like your collaborator made an edit to that line too, but the name selected for the title is slightly different: Data Science project: Canadian languages !\nTo resolve the merge conflict, we can do anything we want:\n\nKeep the change made in the local repository,\nKeep the change made in the remote repository,\nWrite something new to replace both, or get rid of the change entirely.\n\nOnce you have decided which option you prefer, you must remove any separators and unwanted text/code from the file and leave only the information you want to include in the new version of the file. After you made your changes, the file must first be saved, then added to the staging area, and finally committed before you will be able to push your changes to GitHub."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: JupyterLab",
    "text": "Handling merge conflicts: JupyterLab\n\n\n\nJupyterLab makes it easier to detect and resolve merge conflicts. In the Git tab, a new section called Conflicted will appear below Changes.\nThere you can visualize all the files that have a merge conflict. In the example, the issue is only affecting the README.md file."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab-1",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab-1",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: JupyterLab",
    "text": "Handling merge conflicts: JupyterLab\n\n\n\nOnce you click the file with the merge conflict, you will be able to select to accept your current local change or the incoming changes from the remote. In this case, I accepted the current changes by clicking the arrow next to the change. After that, click Mark as resolved, stage the changes, and create a new commit to resolve the conflict.\nYou will now be able to push or pull changes without error!"
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks",
    "href": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks",
    "title": "Handling merge conflicts",
    "section": "Special case: Version control and Jupyter Notebooks",
    "text": "Special case: Version control and Jupyter Notebooks\nJSON format\n{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Canadian Languages\\n\",\n    \"\\n\",\n    \"This project aims to understand what languages Canadian residents speak, and where they speak them.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 3,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"import pandas as pd\\n\",\n    \"import altair as alt\"\n   ]\n  },\n\nFirst - a bit about what a Jupyter notebook are ‚Äúplain‚Äù text files, and we can view them in a plain text editor.\nHowever, the contents of the notebook are encoded in JSON format, which means that there are many brackets in the file, which can make it hard to read for humans (but easy for machines)."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-1",
    "href": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-1",
    "title": "Handling merge conflicts",
    "section": "Special case: Version control and Jupyter Notebooks",
    "text": "Special case: Version control and Jupyter Notebooks\n\n\n\nBecause the notebooks are stored as plain text, we can use them for version control, but this is not without issues, since the JSON format can make it difficult to interpret difference between files and to manually fix conflicts.\nIn this situation is better to use JupyterLab than any other editor. The same as we explained before, to solve the merge conflict you have to click in this case in the notebook eda.ipynb that show up in the section called Conflicted."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-2",
    "href": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-2",
    "title": "Handling merge conflicts",
    "section": "Special case: Version control and Jupyter Notebooks",
    "text": "Special case: Version control and Jupyter Notebooks\n\n\n\nA new tab will appear, displaying the current local changes and incoming remote changes that are incompatible. JupyterLab displays the .ipynb files as notebooks even during the merge conflicts and the conflicting lines are highlighted in red as you can see in the image. You can choose to keep the current changes, the incoming changes, or go back to the commit before the project‚Äôs history diverged. The last option is known as ‚ÄúCommon ancestor‚Äù In the example, I decided to keep the current changes, so you should click the small arrow next to the selected option. Finally, you should click the Mark as solved button. Remember that you need to stage and commit the changes after solving the conflict.\nWe recommend using JupyterLab rather than the terminal to resolve merge conflicts in Jupyter Notebooks."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal",
    "href": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal",
    "title": "Handling merge conflicts",
    "section": "Extra: Stashing local non-committed changes before pulling (Terminal)",
    "text": "Extra: Stashing local non-committed changes before pulling (Terminal)\nerror: Your local changes to the following files would be overwritten by merge:\n        README.md\nPlease commit your changes or stash them before you merge.\nAborting\n\nWe have learned that if there are changes in your remote repo on GitHub and you already have locally committed changes, you will need to pull before you can push. If the local and remote changes are in the same lines, you will have to resolve the resulting merge conflict, otherwise Git will merge automatically.\nBut what if you have just started to make changes to a file when you realize that you forgot to pull before you started to work? The first thing to do is to try to pull, if you‚Äôre lucky there are either no new changes or they are not in the same file you modified. If they are in the same file, you will get an error message like the one in the slide."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal-1",
    "href": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal-1",
    "title": "Handling merge conflicts",
    "section": "Extra: Stashing local non-committed changes before pulling (Terminal)",
    "text": "Extra: Stashing local non-committed changes before pulling (Terminal)\ngit stash\nSaved working directory and index state WIP on main: d59b6bb Add MIT license\n\nTo solve this error in the previous slide, we can use a command called git stash, which removes your local changes from the working area and saves them in another location (you can think of this as a secrete pocket which Git does not care about when pulling from the remote repo, and from which you can take out the changes again when you need them). You can then do git pull, and follow up with a git stash apply to bring your changes back from the stash to the working area, and then carry on working.\nThis workflow can save you from running into merge conflicts, as long as you have not already made modifications to the same lines as you are pulling down. If you have already modified the same file that was updated remotely, you will still run into a merge conflict when you do git stash apply.\nStashing is also great when you are working on one feature but realize that you should actually work on another unrelated feature first, you can stash your existing work (instead of manually saving it elsewhere) and finish working on the most urgent feature first."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#time-travelling",
    "href": "modules/module4/slides/module4_05.html#time-travelling",
    "title": "Reset your Git project to an earlier state",
    "section": "Time travelling",
    "text": "Time travelling\n\nWe are going to learn two ways to travel back in time to a previous commit:\n\n\nDoing a hard reset\nReverting previous changes\n\n\nIt‚Äôs not uncommon to realize that we made a mistake when viewing the history! Maybe we didn‚Äôt mean to delete an important file and we want to undo our latest commit. Don‚Äôt worry, we can now take advantage of tracking our files using version control to retrieve a previous state of a file and replace the current version.\nThere are two ways of traveling back in time to an earlier state of the repo:\n\nRemove commits from the Git history (a ‚Äúhard reset‚Äù).\nCreate a new commit to undo previous changes (a ‚Äúreversion‚Äù).\n\nIn this slide deck we will look into git reset and in the next one we will cover git revert."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab",
    "href": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (JupyterLab)",
    "text": "Hard reset (JupyterLab)\n\n\nA hard reset deletes your changes AND the history of your project by removing the commits from your current branch. To perform a hard reset in JupyterLab, you should click the clock icon next to the commit you would like to travel back to."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-1",
    "href": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-1",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (JupyterLab)",
    "text": "Hard reset (JupyterLab)\n\n\nBe careful! This action can‚Äôt be undone and JupyterLab will display a dialog box to confirm that you are sure that you want to discard your commits."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-2",
    "href": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-2",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (JupyterLab)",
    "text": "Hard reset (JupyterLab)\n\n\nAfter doing a hard reset on your local Git repository, you would need to push your changes to the remote repository for them to be visible online. However, because you have changed the Git history by removing some commits, this would lead to issues for your colleagues who still have these commits on their computers. Therefore, it is not recommended to use a hard reset when working with collaborators, unless there are extraordinary circumstances requiring it.\nIf you have performed a hard reset locally, but you change your mind you could use the backup on the remote repository to undo your local changes by pulling back the commits from the remote repository."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-terminal",
    "href": "modules/module4/slides/module4_05.html#hard-reset-terminal",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (Terminal)",
    "text": "Hard reset (Terminal)\ngit reset --hard &lt;commit hash&gt;\ngit push -f/--force\n\n\n\nIn the terminal, you can look at the git log output to find the commit hash we want to reset our project to. Then we can use the command git reset --hard &lt;commit hash&gt;.\nGit by default protects from unintentionally pushing after a hard reset. If you really want to delete the commits and remove them from GitHub, you must use the command git push -f to ‚Äúforce‚Äù the push in the terminal, regardless of whether you choose to execute the hard reset using the JupyterLab IDE or the terminal.\nAfter doing a hard reset, JupyterLab will offer you to pull the locally deleted commits from the remote. You shouldn‚Äôt pull if you want to preserve the deletion of commits you made with the hard reset!\nExtra\nIf we want to make a new commit with the changes since the reset point, we can perform a ‚Äúsoft‚Äù reset with git reset --soft. This command will not discard the information on the deleted commits as git reset --hard, if not will save all in the staging area in case you would like to create a new commit with those changes. This command is useful if you want to combine a series of local commits into one. Note that git reset --soft is only available in the terminal, and not via JupyterLab."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project",
    "title": "Viewieng the history of your project",
    "section": "Viewing the history of a project",
    "text": "Viewing the history of a project\n\nThere are three ways you can view the Git history of a project:\n\nOn GitHub\n\nIn the GitHub web interface through the repo‚Äôs code commit view\n\nOn your computer\n\nIn Jupyter Lab, through the repo‚Äôs code commit view\nIn the terminal, using git log\n\n\nDo you remember the commit messages we learned about in module 3? When reviewing the history of our repository, the commit messages are useful since they help us remember what was modified in each commit. We will outline three alternative ways to look at the history of the entire project.\nLet‚Äôs look closer at each one in the next few slides.\n\nThe material of this chapter is based the course DSCI 521: Computing Platforms for Data Science from the UBC Master of Data Science program."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github",
    "title": "Viewieng the history of your project",
    "section": "1. Viewing the history of a project: GitHub",
    "text": "1. Viewing the history of a project: GitHub\n\n\n\nFirst, we will view the history of our project on github.com. On the repository‚Äôs landing page on GitHub, you can click the ‚ÄúN commits‚Äù link marked in red in the slide (where N is the number of commits made on the repo)."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github-1",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github-1",
    "title": "Viewieng the history of your project",
    "section": "1. Viewing the history of a project: GitHub",
    "text": "1. Viewing the history of a project: GitHub\n\n\n\nAfter clicking the ‚ÄúN commits‚Äù link, we can see that there are only three commits in this project. You can identify all parts of each commit, including the day it was made, its author, and hash. You can also go back to browse the state of the repository at the time of this commit by clicking the &lt;&gt; button."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-jupyter-lab",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-jupyter-lab",
    "title": "Viewieng the history of your project",
    "section": "2. Viewing the history of a project: Jupyter Lab",
    "text": "2. Viewing the history of a project: Jupyter Lab\n\n\n\nIn JupyterLab, you can access the history of your project by looking in the ‚ÄúHistory‚Äù tab within the Git extension side panel (as we did in the previous module). In this view, we can see the same information as we could online: the time when the commit was made, its author, and hash."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal",
    "title": "Viewieng the history of your project",
    "section": "3. Viewing the history of a project: the Terminal",
    "text": "3. Viewing the history of a project: the Terminal\n\n\n\nYou can use the command git log to view your project‚Äôs history in the terminal. In this slide, we‚Äôve indicated with a red line how the three commits in the git log output correspond to the information in Jupyter Lab‚Äôs ‚ÄúHistory‚Äù tab.\nIt is important to note that git log output shows the long version of the commit hash, not the 7-character version that is displayed by default in Jupyter Lab or GitHub. Except your project is extremely large, Git won‚Äôt require more than 7 characters to identify the commit. In consequence, if you need the commit hash and you are using the terminal, you can only copy and paste the first 7 hash characters of the commit."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal-1",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal-1",
    "title": "Viewieng the history of your project",
    "section": "3. Viewing the history of a project: the Terminal",
    "text": "3. Viewing the history of a project: the Terminal\n\n\n\nAnother option is adding the flag --oneline to the command git log. The command git log --oneline will provide a more succinct version of the information in each commit. This is often more convenient as it is easier to digest and get an overview of the project history, but it can be tedious to type out each time. Here it would be good to create a shell alias, which we learned about in module 2! Executing alias gl=\"git log --oneline\" means that we can simply type gl each time we want to view the git log output. Refer to module 2 for more details around aliases and how to make them persist through reboots.\nThe terminal allows greater flexibility when it comes to displaying the history of the project. If you would like to know what other possibilities you have for using the git log command, you can access the help by typing the command git log --help (any operating system) or man git log (MacOS and Linux)."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-1",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-1",
    "title": "Viewieng the history of your project",
    "section": "Viewing the history of a project",
    "text": "Viewing the history of a project\n\nOn GitHub\n\nOn GitHub through the repo‚Äôs code commit view ‚úîÔ∏è\n\nOn your computer\n\nIn Jupyter Lab through the repo‚Äôs code commit view ‚úîÔ∏è\nIn the terminal using git log ‚úîÔ∏è\n\n\nWe have covered three distinct methods for viewing your project‚Äôs history. Prior to starting the multiple choice questions below, give these commands a try yourself in an example Git repository!"
  },
  {
    "objectID": "modules/module4/module4-13-what_did_we_just_learn.html",
    "href": "modules/module4/module4-13-what_did_we_just_learn.html",
    "title": "7. What did we just learn?",
    "section": "",
    "text": "7. What did we just learn?\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "7. What did we just learn?"
    ]
  },
  {
    "objectID": "modules/module4/module4-11-.gitgnore.html",
    "href": "modules/module4/module4-11-.gitgnore.html",
    "title": "6. .gitgnore",
    "section": "",
    "text": "6. .gitgnore\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "6. .gitgnore"
    ]
  },
  {
    "objectID": "modules/module4/module4-09-deal_with_merge_conflicts.html",
    "href": "modules/module4/module4-09-deal_with_merge_conflicts.html",
    "title": "5. Deal with merge conflicts",
    "section": "",
    "text": "5. Deal with merge conflicts\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "5. Deal with merge conflicts"
    ]
  },
  {
    "objectID": "modules/module4/module4-07-revert_changes_made_to_your_git_project.html",
    "href": "modules/module4/module4-07-revert_changes_made_to_your_git_project.html",
    "title": "4. Revert changes made to your Git project",
    "section": "",
    "text": "4. Revert changes made to your Git project\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "4. Revert changes made to your Git project"
    ]
  },
  {
    "objectID": "modules/module4/module4-05-reset_your_git_project_to_an_earlier_state.html",
    "href": "modules/module4/module4-05-reset_your_git_project_to_an_earlier_state.html",
    "title": "3. Reset your Git project to an earlier state",
    "section": "",
    "text": "3. Reset your Git project to an earlier state\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "3. Reset your Git project to an earlier state"
    ]
  },
  {
    "objectID": "modules/module4/module4-03-comparing_commits.html",
    "href": "modules/module4/module4-03-comparing_commits.html",
    "title": "2. Comparing commits",
    "section": "",
    "text": "2. Comparing commits\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "2. Comparing commits"
    ]
  },
  {
    "objectID": "modules/module4/module4-01-viewieng_the_history_of_your_project.html",
    "href": "modules/module4/module4-01-viewieng_the_history_of_your_project.html",
    "title": "1. Viewieng the history of your project",
    "section": "",
    "text": "1. Viewieng the history of your project\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "1. Viewieng the history of your project"
    ]
  },
  {
    "objectID": "modules/index.html",
    "href": "modules/index.html",
    "title": "Welcome to The Data Science Toolbox!",
    "section": "",
    "text": "Welcome to The Data Science Toolbox!\nThis course is part of the Key Capabilities for Data Science program and covers topics related to workflows, plateforms and tools used in data analysis.\nIn this course, we will dive into the world of data science tools and utilities. While these are not strictly required for data analysis, they are necessary for efficient, reproducible, and collaborative data science practices, and are all important building blocks for a successful and sustained data science career.\nCourse prerequisites: Programming in Python for Data Science",
    "crumbs": [
      "**M0. Welcome to The Data Science Toolbox!**",
      "0. Welcome!"
    ]
  },
  {
    "objectID": "modules/module4/module4-00-module_learning_outcomes.html",
    "href": "modules/module4/module4-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module4/module4-02-practice_a_history_lesson.html",
    "href": "modules/module4/module4-02-practice_a_history_lesson.html",
    "title": "1.1. Exercises",
    "section": "",
    "text": "Clone the repo https://github.com/UBC-MDS/equine_numbers_value_canada, and answer the following questions.",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 1.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/module4-02-practice_a_history_lesson.html#practice-a-history-lesson",
    "href": "modules/module4/module4-02-practice_a_history_lesson.html#practice-a-history-lesson",
    "title": "1.1. Exercises",
    "section": "",
    "text": "Clone the repo https://github.com/UBC-MDS/equine_numbers_value_canada, and answer the following questions.",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 1.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/module4-10-practice_merge_with_care.html",
    "href": "modules/module4/module4-10-practice_merge_with_care.html",
    "title": "5.1. Exercises",
    "section": "",
    "text": "$ cat README.md\n\nIf you have questions, please\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nopen an issue\n=======\nask your question via email.\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; new_branch_to_merge_later",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 5.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/module4-10-practice_merge_with_care.html#practice-merge-with-care",
    "href": "modules/module4/module4-10-practice_merge_with_care.html#practice-merge-with-care",
    "title": "5.1. Exercises",
    "section": "",
    "text": "$ cat README.md\n\nIf you have questions, please\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nopen an issue\n=======\nask your question via email.\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; new_branch_to_merge_later",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 5.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/slides/module4_00.html#module-learning-outcomes",
    "href": "modules/module4/slides/module4_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nExplore the Git history via git log in the terminal, and the equivalent functions in JupyterLab and GitHub.\nCompare commits using git diff in the terminal, and the equivalent functions in JupyterLab and GitHub.\nSolve merge conflicts at the command line and in VS Code.\nAvoid pushing certain local files by including a .gitignore file.\nDifferentiate between doing a revert and a hard reset of a commit when restoring an older version of a project.\n\n\nThis module covers the git history, travelling back in time, dealing with merge conflicts and other related topics."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#comparing-commits",
    "href": "modules/module4/slides/module4_03.html#comparing-commits",
    "title": "Comparing commits",
    "section": "Comparing commits",
    "text": "Comparing commits\n\n\nWe have learned how to check the commit history of a project using GitHub, JupyterLab, and the terminal.\nWe can see some key information about each commit in the history view, such as when it was made and who made it.\nBut what if we want to examine the specific changes made between two commits in more detail? Which files had changes? Which lines exactly have been modified?"
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#comparing-commits-1",
    "href": "modules/module4/slides/module4_03.html#comparing-commits-1",
    "title": "Comparing commits",
    "section": "Comparing commits",
    "text": "Comparing commits\n  \n\n\nIn this slide you can see the comparison between two commits for a single file (README.md). The version of the file displayed on the left side is the older (commit d59b6bb) and the version on the right is more recent (commit aa2a019) The green and red highlights indicate the lines that have changed between the commits: In the example, the phrase ‚ÄúHello world! has been introduced in line number four in the commit aa2a019.\nThis type of comparison is called the ‚Äúdiff‚Äù (difference) between commits. and it can be helpful to understand what has changed.\nLet‚Äôs explore how we can access this view in JupyterLab, the terminal, and GitHub."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#differences-between-commits-jupyterlab",
    "href": "modules/module4/slides/module4_03.html#differences-between-commits-jupyterlab",
    "title": "Comparing commits",
    "section": "üôå Differences between commits: JupyterLab",
    "text": "üôå Differences between commits: JupyterLab\n\n\n\nOpen the History tab in JupyterLab to see the differences between commits.\n\nOnce there, find the older commit you want to compare first and then click the file icon symbol with the left arrow. Repeat the process for the most recent commit that you want to compare, but this time you should click the file icon symbol with the right arrow. After doing so, a new section called Compare d59b6bb and aa2a019 will appear at the bottom of the History tab.\nIn that section you should choose the file for which you want to see the differences. In our example, we have only changed the README.md file. The next step is to click the file icon with the + and - symbols next to the name of the file. The differences between both commits will be displayed as a new file."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#differences-between-commits-terminal",
    "href": "modules/module4/slides/module4_03.html#differences-between-commits-terminal",
    "title": "Comparing commits",
    "section": "üôå Differences between commits: Terminal",
    "text": "üôå Differences between commits: Terminal\n\n\n\nAs we have seen before, the terminal is often more flexible than the graphical user interface and the same is true when comparing commits.\nLet‚Äôs first compare two commits the same way as we did with JupyterLab. For this we will use the command git diff &lt;commit 1 hash&gt; &lt;commit 2 hash&gt; as in the slide. We can read that a line including ‚ÄúHello world!‚Äù was added to the README.md file.\nJust as in JupyterLab, the default is to compare the specified commit with the most recent one so what we wrote about would be equal to specifying only one commit hash (the oldest one) doing git diff d59b6bb, since aa2a019 is the most recent commit.\nNote that git diff is useful for comparing files outside Git repositories as well. You can use git diff &lt;file 1&gt; &lt;file 2&gt; to see all the differences between two text files."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#understanding-the-comparison",
    "href": "modules/module4/slides/module4_03.html#understanding-the-comparison",
    "title": "Comparing commits",
    "section": "Understanding the comparison",
    "text": "Understanding the comparison\n\n\n\nWhen visualizing differences, you can invert the commit order. As result, the output of git diff will be inverted as well. To avoid confusion, we recommend that you always use the same criteria to select the order of the commits to compare.\nYou must also pay attention to the - and + symbols. They are indicating the order in which the commits were chosen to be compared.\n\n- symbol is indicating changes in the first commit you have selected in JupyterLab or git diff first commit hash.\n+ symbol is indicating changes in the second commit you have selected in JupyterLab or git diff second commit hash.\n\nIn both cases, the phrase ‚ÄúHello world!‚Äù has been added. What the - and + are showing you is in which commit is the addition! Which changes show up in red and which show up in green will also depend on which commit hash your write on the left and right side, so you cannot always rely on the color to indicate which change is the oldest.\nIf you want to understand in more detail what the git diff output you can find a more detailed description in this tutorial."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#differences-between-commits-github",
    "href": "modules/module4/slides/module4_03.html#differences-between-commits-github",
    "title": "Comparing commits",
    "section": "üôå Differences between commits: GitHub",
    "text": "üôå Differences between commits: GitHub\n\nhttps://github.com/flordandrea/toy_ds_project/compare/d59b6bb..aa2a019\n\n\n\nSo far we have seen how to compare commits locally in JupyterLab and via the terminal. What about visualizing the differences between commits directly on GitHub, is that possible?\nYes, it is! You can add the following line to your repository‚Äôs URL /compare/&lt;commit1&gt;..&lt;commit2&gt; (substituting in the commits hashes to compare) and you will access the view that you can see in this slide.\nRemember to use 7 characters for the commits id. Otherwise, it is not going to work! Give it a try in one of your repositories!\nAlso note that you could use ... instead of .. to compare commits, but double dot is the same as git diff &lt;commit1&gt; &lt;commit2&gt;. You can read more about the difference of two and three dots in this StackOverflow answer."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-jupyterlab",
    "href": "modules/module4/slides/module4_07.html#reversion-jupyterlab",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (JupyterLab)",
    "text": "Reversion (JupyterLab)\n\n\nAs we saw in the previous slide deck, it is troublesome to perform a hard reset when we are working together with collaborators online. Another approach for undoing some of your work is to create a new commit that reverts your changes. This means that nothing in your Git history is deleted, there is just a new commit added containing the reversions to each file.\nTo revert to a previous commit via JupyterLab, you can click the arrow icon in the commit you want to go back to in JupyterLab‚Äôs ‚ÄúHistory‚Äù tab, as seen in this slide."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-jupyterlab-1",
    "href": "modules/module4/slides/module4_07.html#reversion-jupyterlab-1",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (JupyterLab)",
    "text": "Reversion (JupyterLab)\n\n\nWhen you click the arrow, JupyterLab asks you for the commit title and description for the new reversion commit. You can either keep the preloaded name here or find a more meaningful one."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-jupyterlab-2",
    "href": "modules/module4/slides/module4_07.html#reversion-jupyterlab-2",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (JupyterLab)",
    "text": "Reversion (JupyterLab)\n\n\nNow you can see that you have a new commit, and the state of the your project is the same as it was previously, without deleting anything!\nRemember to push your changes if you want to keep your remote updated. In contrast to a hard reset, a reversion if more friendly for collaborating on GitHub, but it is still important to push big reversions soon and inform your collaborators, since some of them might be modifying the part that you reverted!"
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-terminal",
    "href": "modules/module4/slides/module4_07.html#reversion-terminal",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (Terminal)",
    "text": "Reversion (Terminal)\ngit revert &lt;commit hash&gt;\n\n\n\nIf you want to revert changes with the terminal you can use git revert together with the commit hash you want to revert to."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-terminal-1",
    "href": "modules/module4/slides/module4_07.html#reversion-terminal-1",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (Terminal)",
    "text": "Reversion (Terminal)\n\n\n\nAfter running git revert, your default text editor will pop up so you can modify the final commit message. If you close it as it is, the message will be the default one.\nAfter closing the editor, you can view the new reversion in the project history tab or with git log. The number of files changed, insertions and deletions are informed when you are using the terminal or JupyterLab as you can see in the image."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#travelling-back-in-time",
    "href": "modules/module4/slides/module4_07.html#travelling-back-in-time",
    "title": "Revert changes made to your Git project",
    "section": "Travelling back in time üïë",
    "text": "Travelling back in time üïë\n \n\nDoing a hard reset ‚úîÔ∏è\n\n\n\nReverting previous changes ‚úîÔ∏è\n\n\nIn the last two slide decks, we have learned two ways of restoring our project to a previous point in time: hard reset and revert changes. One of the major differences is that when we select the option of doing a hard reset we are removing the previous commits we made and thereby modifying the Git history of the project. If we instead chose to revert our changes, we keep all our previous commits and add a new ‚Äúreversion‚Äù commit that includes all the changes needed to make our repository identical to a previous points in time."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#unnecessary-untracked-files",
    "href": "modules/module4/slides/module4_11.html#unnecessary-untracked-files",
    "title": "What is .gitignore?",
    "section": "Unnecessary untracked files",
    "text": "Unnecessary untracked files\nYou may have encountered this before:\ngit status\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    .ipynb_checkpoints/\n    .DS_Store\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nAs we know, Git let us know about untracked files when we run the command git status. An untracked file or folder one that you didn‚Äôt have in the previous commit, and which hasn‚Äôt yet been staged. In the example on this slide, there is an untracked folder and file that are automatically saved:\n\n.ipynb_checkpoints contain old backup versions of our notebook which are saved by JupyterLab automatically.\n.DS_Store contains directory display options for the Finder application on MacOS.\n\nThe fact that they both start with a . means that they will be hidden in file browsers and in the output from ls in the terminal; an indication that they are not something that we need to work with manually, but are there for applications on our computer to use when needed.\nTherefore, we also don‚Äôt care about making these folders part of our version controlled project and we‚Äôd prefer not to have them clutter our view of the git status output, so that we instead can focus on the files we do want to track. How can we achieve this?"
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#create-a-.gitignore-file",
    "href": "modules/module4/slides/module4_11.html#create-a-.gitignore-file",
    "title": "What is .gitignore?",
    "section": "Create a .gitignore file",
    "text": "Create a .gitignore file\n\nUse a text editor of your choice (here we use VS Code) to create a file called .gitignore inside your Git repo:\ncode .gitignore\n\nInside the text file, list the files and folders you would like to ignore, one per line. For example:\n.ipynb_checkpoints/\n.DS_Store\n\nTo ‚Äúhide‚Äù folders and files from Git we can create a file called .gitignore in the root/main directory of our repository (the same directory where the .git folder is located). These two slides describe how we can create this file using VS Code, and what we need to add to it in order to ignore the two files from the previous slide."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#create-a-.gitignore-file-1",
    "href": "modules/module4/slides/module4_11.html#create-a-.gitignore-file-1",
    "title": "What is .gitignore?",
    "section": "Create a .gitignore file",
    "text": "Create a .gitignore file\n \nSave the file, add it to the staging area, and commit the changes with Git.  Then try git status again. You should now see that the files are ignored by Git:\n\ngit status\nOn branch main\nnothing to commit, working tree clean"
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#gitignore-tips-and-tricks",
    "href": "modules/module4/slides/module4_11.html#gitignore-tips-and-tricks",
    "title": "What is .gitignore?",
    "section": ".gitignore tips and tricks",
    "text": ".gitignore tips and tricks\n \nHere are two useful tricks so that you can avoid doing unnecessary work when it comes to .gitignore:\n\n\nRecursively ignoring filename patterns\nUsing .gitignore_global to ignore certain patterns in every repository\n\n\nWhile we could list out every file we want to ignore in every project‚Äôs .gitignore, this can quickly become tedious to type.\nInstead, we can use filename pattern matching and global Git settings to simplify this process. We will look closer at each of these two approach in the next couple of slides."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns",
    "href": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns",
    "title": "What is .gitignore?",
    "section": "1. Recursively ignoring of filename patterns",
    "text": "1. Recursively ignoring of filename patterns\n \nWildcards can be used inside .gitignore to ignore multiple files with the same name:\n*.log\n\nPrepending **/ to filenames ignores those files in subdirectories as well:\n**/*.log\n\nThe .gitignore file accepts wildcards for matching pattern names, similar to what we learned about for the shell in Module 2. So say that we e.g.¬†have a Git repository where a lot of log files files are created and they all end in .log. Instead of typing out the name of each file, we could add *.log to the .gitignore file and it would ignore all the log files in the root of the repository.\nIf we wanted to ignore the log files in every subdirectory of the project, we would need to use the **/ patterns, which means ‚Äúin any folder‚Äù. The line in our .gitignore would now read **/*.log."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns-1",
    "href": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns-1",
    "title": "What is .gitignore?",
    "section": "1. Recursively ignoring of filename patterns",
    "text": "1. Recursively ignoring of filename patterns\n \nStarting with a ! tells git to not ignore a certain directory.\n**/*.log\n!important/*.log\n\nWhat if we wanted to ignore all the log files, except those inside a specific directory? Let‚Äôs imagine the directory of the log files we want to keep is called important. We would now need to add two lines to our .gitignore: one to ignore all log files, and a second to tell git to not ignore the log files in the important directory. It would look like this:\n**/*.log\n!important/*.log"
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#using-.gitignore_global",
    "href": "modules/module4/slides/module4_11.html#using-.gitignore_global",
    "title": "What is .gitignore?",
    "section": "2. Using .gitignore_global",
    "text": "2. Using .gitignore_global\n \nCreate a global .gitignore file in your home directory so that you do not have to create the same .gitignore for all your repos\ncode ~/.gitignore_global\n\nNow comes the second trick: There might be certain files that you‚Äôd like to always get ignored in all repos. In that case, you can add them once to a global .gitignore file called .gitignore_global which lives in your home directory."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#using-.gitignore_global-1",
    "href": "modules/module4/slides/module4_11.html#using-.gitignore_global-1",
    "title": "What is .gitignore?",
    "section": "2. Using .gitignore_global",
    "text": "2. Using .gitignore_global\n \n\nJust like for a regular .gitignore file, add a list of files and folders that you want to get ignored in all repos on your computer\nSave .gitignore_global file and configure Git to exclude the file for every Git repository in your computer.\n\ngit config --global core.excludesfile ~/.gitignore_global\n\nThis way, you‚Äôll no longer need to add those particular files or folder names to the .gitignore file of each repo on your computer!\nYou can read more about ignoring files on the GitHub documentation"
  },
  {
    "objectID": "modules/module5/module5-00-module_learning_outcomes.html",
    "href": "modules/module5/module5-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams‚Ä¶ Welcome to the Git nature walk!**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module5/slides/module5_00.html#module-learning-outcomes",
    "href": "modules/module5/slides/module5_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nManage feature-based development efficiently with Git in JupyterLab and in the terminal.\nInfer a repository‚Äôs current status and collaboration pattern by looking at visualizations of the project history in VS Code.\nDifferentiate when to use forking or branching as a collaboration strategy.\nRecognize the essential components of a pull request.\nDetermine whether directly merging changes is preferable to first opening a pull request.\nExplain when GitHub issues are helpful and how to use them.\n\n\nIn this module you will discover how to efficiently collaborate with Git and GitHub by using branches, forks and pull requests."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#how-branches-are-related",
    "href": "modules/module5/slides/module5_03.html#how-branches-are-related",
    "title": "How branches are related?",
    "section": "How branches are related üôå",
    "text": "How branches are related üôå\n\n\nCreate and clone a Git repository to your computer.\nCreate 2 commits (e.g.¬†modifying README file).\nPush to GitHub.\nStart a new branch using the terminal or JupyterLab.\nCreate 2 commits in the new branch.\nGo back to the main branch.\nCreate 2 commits in the main branch.\n\n\nBefore moving forward, let‚Äôs practice!\nRemember that after you create the branch you are always going to be working on that new branch. If you want to go back to your original branch you can (1) click the name of the branch you want to return in the Branches tab (JupyterLab) or (2) run git switch &lt;branch-name&gt; (terminal).\nWe will use the repository you just created as an example for the rest of this module."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-terminal",
    "href": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-terminal",
    "title": "How branches are related?",
    "section": "Seeing how branches are related (terminal)",
    "text": "Seeing how branches are related (terminal)\n\ngit log --oneline --all --graph\n\n\n\nFor this section we are going to simulate that we start working on a project. After cloning the repository for the first time we want to see what the branches look like. To see all branches as well as a graph indicating their relationship, we can type git log --oneline --all --graph in the terminal.\nYou can clone any repository on github.com and run this command to visualize the project history. For example, in the image we are visualizing the repository of the open source project Glosario using the History tab of JupyterLab and also the command git log --oneline --all --graph in the terminal. Glosario is an open source glossary of terms used in data science that is available online and also as a library in both R and Python.\nRemember that you can use space on your keyboard to page down through the commit history and b to page up. Press q to exit back out to the terminal."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-vs-code",
    "href": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-vs-code",
    "title": "How branches are related?",
    "section": "Seeing how branches are related (VS Code)",
    "text": "Seeing how branches are related (VS Code)\n\n\n\nEven if the branch representations that we can view in the terminal and JupyterLab are correct, it is not as detailed as the one we can get from VS Code.\nOpen the current folder in VS Code by typing code . inside your git folder (remember that . is a shortcut that means ‚Äúcurrent directory‚Äù). In VS Code, go to the extensions tab and search for ‚Äúgit history‚Äù, install the extension. Then go to View -&gt; Command Palette and start writing Git: View History (git log). A new tab will open with the Git History. If you want to display all the branches you will have to select them in one of the menus as you can see in the image.\nWhere it currently says main, change it to show ‚ÄúAll branches‚Äù and you should now see a nice graphical overview looking like the one in the picture. If the Git history view hangs or looks strange, press ‚ÄúRefresh‚Äù. You‚Äôre free to use the one you prefer between VS Code and git log, but many of the commands are the easiest to run via terminal."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#observing-the-trees",
    "href": "modules/module5/slides/module5_03.html#observing-the-trees",
    "title": "How branches are related?",
    "section": "Observing the trees",
    "text": "Observing the trees\n\n\n\nDownloading a public GitHub repository from a project you like and observing the number of branches is an excellent exercise. For example you can try to determine how many branches exist that have not been merged and where the most recent modifications have occurred.\nUnderstanding these graph-based commit history visualizations is helpful to understand the relationships between branches, provides vital information about the structure of a project, and can help you fix problems if they arise.\nIn this slide, you can see the public repository of JupyterLab that has been cloned and opened using VS Code. Here we can see that there are three active branches:\n\nThe default master branch which is indicated on the topmost row. This is the orange line in the graphical representation to the left and there are five commits visible in this image on this branch (the black dots on the orange line).\nThe branch for version 3.4 which is indicated on the second row from the top. This is the middle red line in the graphical representation and there are three commits visible in this image on this branch.\nThe branch with a long name starting with 12758-snapshots at the third row from the bottom (commit message: ‚ÄúUpdate snapshots for challenger commit‚Äù). This is the red line in the graphical representation to the right, and it contains only a single commit."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#when-merging-branches-goes-social",
    "href": "modules/module5/slides/module5_07.html#when-merging-branches-goes-social",
    "title": "When merging branches goes social: opening pull requests",
    "section": "When merging branches goes social",
    "text": "When merging branches goes social\n \n\nWhen I first started we all pushed to one branch, but the problem is you push and nobody knows what changes are going through and there is no chance for a review. Our current system is that you don‚Äôt make any changes without submitting a pull request[‚Ä¶]and then one or more members will review it and you need one thumbs up from another team member to merge it, otherwise it can‚Äôt go in.\n\n‚Äî Kalliamvakou, E. (2014). The Code-Centric Collaboration Perspective: Evidence from GitHub.\n\nPull requests involve merging someone else‚Äôs changes into your remote repository on GitHub. They are essential for team collaboration and proper pull request review is critical for for ensuring code quality.\nIn the previous part, we did not push our feature branch to GitHub. Instead, we finished the development of this branch locally and merged it into our main branch using JupyterLab GUI or the command git merge.\nWhen working as a team, it is recommended to push your code to GitHub first and then make a pull request so that others can review it and suggest any needed adjustments before merging it."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nTo create a pull request, you have to push the changes in your branch to GitHub. After doing so, a message will appear at the top of the repository interface on GitHub and you can click the green button that says ‚ÄúCompare and pull request‚Äù."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request-1",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request-1",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nAfter clicking ‚ÄúCompare and pull request‚Äù, you will be taken to a screen that looks like the screenshot in this slide. The dropdown menus on top indicate the branches the pull request is related to. As general rule you are going to be opening pull requests from your feature branch with the main branch as the ‚Äúbase‚Äù, but GitHub allows you to change the base branch (the leftmost arrow in the slide) and the branch to pull the changes from (the right most arrow in the slide).\nYou should include a descriptive title for your pull request and elaborate on your suggested changes in the comment section. Remember that you can use Markdown to format the message content and that you can use the tab Preview to view what the rendered Markdown will look like before creating the pull request.\nIn the body of the message you can also indicate if it is fixing a currently open issue by typing close #1 to close issue number 1 (pull requests and issues use the same numbering system, so if there is already an open issue, the first PR would be get the number 2)."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request-2",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request-2",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nThe next step is for the upstream repository maintainers to review your work and merge it in if they approve it. You have the option of assigning someone to a pull request and/or designating the parson as reviewer.\n\nReviewers: You can choose anyone who can help from the list of prior authors that GitHub will offer as reviewers for that code. A review request will be sent to the reviewers and you will obtain a notification and email once they have submitted their feedback. If you are working with a team you will probably define guidelines for which team member reviews which PRs.\n\nAnother useful thing that you can do is to label each pull request, they can help you by grouping similar pull requests together, e.g.¬†‚ÄúBug fixes‚Äù, ‚ÄúEnhancements‚Äù, etc."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request-3",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request-3",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nOnce you have opened a pull request you can continue adding commits by pushing them to your feature branch on GitHub (the commits will appear in chronological order). This means that you can open the pull request before finishing the work and doing so is a way to communicate that you are preparing changes to merge in main (or another branch) that will need review.\nUntil the PR is ready for review, you can open it as a ‚ÄúDraft‚Äù by clicking the dropdown arrow on the green button that says ‚ÄúCreate Pull Request‚Äù and mark it as ‚ÄúReady for review‚Äù later."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#pull-request-successfully-merged-and-closed",
    "href": "modules/module5/slides/module5_07.html#pull-request-successfully-merged-and-closed",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Pull request successfully merged and closed",
    "text": "Pull request successfully merged and closed\n\ngit push &lt;remote&gt; --delete &lt;branch&gt;\n\n\n\nAfter a collaborator has reviewed your changes and approved the pull request, they or you can click the Merge button and accept the pull request Then, GitHub will offer you to delete the branch via the web interface. To do this you should click Delete branch button.\nPay attention to the fact that deleting a remote branch won‚Äôt affect the local branch report in your local repository. Instead, the label origin/report will disappear from your git logor project history visualisation. You still have to delete the local version of report if you want to get rid of that branch as we learned some minutes ago.\nIt is possible to delete the remote branch from the terminal using the command git push &lt;remote&gt; --delete &lt;branch&gt;. For example, the command git push origin --delete report would allow you to perform the same action that we did on GitHub in the image.\nAlthough it is not necessary to remove a branch after merging it, doing so can help to keep your repository tidy."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#collaborative-work",
    "href": "modules/module5/slides/module5_11.html#collaborative-work",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Collaborative work",
    "text": "Collaborative work\nThere are two main strategies we can use to work with others:\n\nBranching\n Forking \n\n\nWe have learned that if you create your repository on GitHub or you are part of a team with write access to a repo, then you can clone it to your computer, make changes and then push them back to this repository. We called this style of collaboration branching.\nIf you want the code from someone else‚Äôs repository but you are not an official collaborator, you can clone it and use it on your computer. However, you cannot push your changes back to the GitHub repository because you don‚Äôt have write permissions to the repository.\nIt would still be beneficial for the repository‚Äôs owners to receive your contributions if you make code enhancements, without having to grant you full access and run the risk of breaking something. Instead of working directly on the repository, you can fork (copy) someone else‚Äôs repository and work on a branch in your own copy."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#how-can-i-fork-a-repository",
    "href": "modules/module5/slides/module5_11.html#how-can-i-fork-a-repository",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "How can I fork a repository?",
    "text": "How can I fork a repository?\n\n\n\nGo to the GitHub page of the project that you want to fork. In the upper right corner, click the icon that says ‚Äúfork‚Äù. That‚Äôs it! You just forked a repo!\n\nForks are copies of other‚Äôs repositories on GitHub that you own. You can do anything you want on your fork. If you make improvements, you can send a notification to the owner of the ‚Äúupstream‚Äù repository (the one you forked from) and request that they pull the code from your repository (referred to as ‚Äúorigin‚Äù) into theirs. As we learned earlier, this is referred to as a ‚Äúpull request‚Äù, and includes a review of the code from the maintainers of the upstream repository as we discussed in the last section.\nThe fork workflow is used in many open source projects where there is often a small team of core maintainers, but contributions from many more users. For example, the JupyterLab project has around 10 members in their team, but more than 300 people have contributed code to the project and almost 2 000 has forked it.\nIn the example, we are forking the repository of the project Glosario from The Carpentries, a multilingual glossary for computing and data science terms that is also an open-source project. As you can see in the image, this repository has been forked by 168 users so far.\nüôå Go to the GitHub page of the project that you want to fork. In the upper right corner, click the icon that says ‚Äúfork‚Äù. That‚Äôs it! You just forked a repo!"
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#developing-on-a-forked-repo",
    "href": "modules/module5/slides/module5_11.html#developing-on-a-forked-repo",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Developing on a forked repo",
    "text": "Developing on a forked repo\n\n\n\nTo start developing on a fork, first clone it to your computer (your fork, not the upstream repo). It is good practice to always create a branch when you are about to add changes to a fork, and in many projects this is required, so they will not accept a pull request that comes from your main branch. This is because it is easier to keep track of branches with descriptive names compared to having all pull request branches names main, but coming from different people.\nWhen you are working on a branch you have to push your changes to GitHub and ask for it to be merged via a pull request. Since you don‚Äôt have write access to the upstream repo, you have to request that the maintainer pull your code (remember that merging is part of what happens during a pull request, so this is similar to what we did with branches via git merge, just that the code first needs to be fetched from your forked repo)"
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#keeping-your-remote-origin-up-to-date-with-the-upstream-remote",
    "href": "modules/module5/slides/module5_11.html#keeping-your-remote-origin-up-to-date-with-the-upstream-remote",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Keeping your remote (origin) up to date with the upstream remote",
    "text": "Keeping your remote (origin) up to date with the upstream remote\n\n\n\nForking a repo happens via the GitHub web interface, but this is a one time operation. If there are changes made to the upstream repo that you want to sync to your forked repo (origin), you have to first pull them from the upstream remote to your forked remote (origin).\nTo solve this you can update your forked repository with the button Sync fork. Then you can pull this changes to continue working locally before opening the pull request. In the example there are not changes in the repository that I have just forked, but if this was the case I would have to select the option update branch."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#create-a-pull-request-from-the-forked-repository",
    "href": "modules/module5/slides/module5_11.html#create-a-pull-request-from-the-forked-repository",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Create a pull request from the forked repository",
    "text": "Create a pull request from the forked repository\n\n\n\nWhen you finish your local changes and you push to the fork that lives in your user‚Äôs account, you can create the pull request to the upstream repository if you click in the Contribute button. If you have added some commits, the Open pull request option will be available.\n‚ö†Ô∏è You should read the CONTRIBUTING.md file before making your first contribution to a new open-source project. There you will find relevant instructions on how to participate in the project. Another file you must read is the CODE_OF_CONDUCT.md. There, you will discover information on who to contact if you ever feel uncomfortable working on the project as well as other guidelines you should adhere to in order to foster a welcoming and supportive environment among the contributors.\nBoth files are typically located in the root of the repository."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#communicating-using-github-issues",
    "href": "modules/module5/slides/module5_11.html#communicating-using-github-issues",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Communicating using GitHub issues",
    "text": "Communicating using GitHub issues\nThe ‚ÄúIssues‚Äù tab on the GitHub web interface\n\n\n\nRegardless of whether you are collaborating with forks or using branches directly on the main repo, you don‚Äôt just want a historical record of who changed what file and when in the project. When working on a any collaborative project, you also want a record of decisions that were made, ideas that were floated, problems that were identified and addressed, and all other communication surrounding the project.\nEmail and messaging apps are both very popular for general communication, but are not designed for project-specific communication: they often lack functionality for organizing conversations by project subtopics, searching for conversations related to particular bugs or software versions, etc.\nüôå To open a GitHub issue, first click on the ‚ÄúIssues‚Äù tab, and then click the green button that says ‚ÄúNew Issue‚Äù."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#communicating-using-github-issues-1",
    "href": "modules/module5/slides/module5_11.html#communicating-using-github-issues-1",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Communicating using GitHub issues",
    "text": "Communicating using GitHub issues\nDialog boxes and submission button for creating new GitHub issues.\n\n\n\nGitHub issues are an alternative written communication medium to email and messaging apps, and were designed specifically to facilitate project-specific communication. Issues are opened from the ‚ÄúIssues‚Äù tab on the project‚Äôs GitHub page, and they persist there even after the conversation is over and the issue is closed (in contrast to email, issues are not usually deleted). One issue thread is usually created per topic, and they are easily searchable using GitHub‚Äôs search tools.\nAll issues are accessible to all project collaborators, so no one is left out of the conversation. If someone mention your name with the syntax @yourname, you will get a notification. If you want to be notified about all new issues and pull requests you can click the little eye icon in the top right corner that says ‚ÄúWatch‚Äù. Replying to issues from email is also possible. Given all of these advantages, we highly recommend the use of issues for project-related communication."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#communicating-using-github-issues-2",
    "href": "modules/module5/slides/module5_11.html#communicating-using-github-issues-2",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Communicating using GitHub issues",
    "text": "Communicating using GitHub issues\nThe ‚ÄúClosed‚Äù issues tab on the GitHub web interface.\n\n\n\nüôå When a conversation is resolved, you can click ‚ÄúClose issue.‚Äù The closed issue can be later viewed by clicking the ‚ÄúClosed‚Äù header link in the ‚ÄúIssue‚Äù tab. Issues will be automatically closed if you merge a PR that refers to the issue.\nAlthough you might think that GitHub issues are mostly for collaborative projects, they are highly useful for individual projects too, as it is important to record ideas and decisions for yourself in the future.\nGitHub has recently also improved issues capabilities to be used for project management, so that you don‚Äôt need to use a separate program for that. It is beyond the scope of this course to go through this topic in detail, but you can find more information about GitHub issues on this page."
  }
]