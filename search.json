[
  {
    "objectID": "modules/module9/slides/module9_00.html#you-did-it",
    "href": "modules/module9/slides/module9_00.html#you-did-it",
    "title": "Congratulations on completing the Data Science Toolbox!",
    "section": "You did it!",
    "text": "You did it!\nWe covered a lot of ground but you managed to finished all eight Modules. It’s important to celebrate this success."
  },
  {
    "objectID": "modules/module9/slides/module9_00.html#attribution",
    "href": "modules/module9/slides/module9_00.html#attribution",
    "title": "Congratulations on completing the Data Science Toolbox!",
    "section": "Attribution",
    "text": "Attribution\n\nResearch Software Engineering with Python, Damien Irving, Kate Hertweck, Luke Johnston, Joel Ostblom, Charlotte Wickham, and Greg Wilson.\nMaterial from UBC’s DSCI 521: Computing Platforms for Data Science by Tiffany A. Timbers, Vicenzo Coia, Firas Moovsi, Joel Ostblom, Florencia D’Andrea \nTimbers, Tiffany, Trevor Campbell, and Melissa Lee. Data science: A first introduction. CRC Press, 2022. https://datasciencebook.ca/\nJupyter Book documentation\nJupyter Project documentation\nThe logo of this course has been created by Hayley Boyce"
  },
  {
    "objectID": "modules/module9/slides/module9_00.html#special-thanks",
    "href": "modules/module9/slides/module9_00.html#special-thanks",
    "title": "Congratulations on completing the Data Science Toolbox!",
    "section": "Special thanks",
    "text": "Special thanks\nNot only did you put in a lot of work by completing this course, but many people did too by helping make this course possible.\nSpecial thanks must be attributed to the following individuals and organizations (in alphabetical order):\n\nHayley Boyce\nInes Montani\n Tiffany Timbers\n Varada Kolhatkar\nThe Master of Data Science Program at UBC\nOur friends, family and colleagues for supporting us and cheering us on!"
  },
  {
    "objectID": "modules/module9/slides/module9_00.html#about-us",
    "href": "modules/module9/slides/module9_00.html#about-us",
    "title": "Congratulations on completing the Data Science Toolbox!",
    "section": "About us",
    "text": "About us\nIn alphabetical order:\n\nFlorencia D’Andrea\n\nWebsite: https://florencia.netlify.app\nTwitter: @cantoflor_87  \n\nJoel Ostblom\n\nWebsite: https://joelostblom.com/\nTwitter: @joelostblom  \n\nArman Seyed-Ahmadi\n\nLinkedIn profile: https://www.linkedin.com/in/arman-seyed-ahmadi-38983864/"
  },
  {
    "objectID": "modules/module8/slides/module8_09.html#module-learning-outcomes",
    "href": "modules/module8/slides/module8_09.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 8",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nExplain the Jupyter Book ecosystem.\nBuild Jupyter Books via the command line.\nCreate your own content files.\nPublish your book online for free using GitHub Pages.\n\n\nNow is time to get to work with the last assignment!"
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#margin-content",
    "href": "modules/module8/slides/module8_05.html#margin-content",
    "title": "Add your own content: Advanced features",
    "section": "Margin content",
    "text": "Margin content\nMargin content is similar to footnotes in a conventional book:\n```{margin} Did you know?\nJupiter is 11.0x larger than Earth!\n```\n\nRendered:\n\n\nSometimes it is helpful to add notes to the margin of a page. This is similar to footnotes in a conventional book.\nIn Jupyter Book, you can do that using blocks denoted by {margin} in a markdown file:\n```{margin} Did you know?\nJupiter is 11.0x larger than Earth!\n```\nNote that this syntax is similar to what we used for creating a figure: ```{figure}.\nThese types of blocks are called directives in Jupyter Book and we will see several different types on the following few slides.\n\nYou can see the rendered version of the margin directive in this slide."
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#admonitions",
    "href": "modules/module8/slides/module8_05.html#admonitions",
    "title": "Add your own content: Advanced features",
    "section": "Admonitions",
    "text": "Admonitions\nAdmonitions draw attention to important information:\n\n\n```{note}\nI'm a note!\n```\n\n\n{note} can be replaced with {warning}, {tip}, {danger} and so on.\nThis is how these admonitions will show up:\n\n\nAdmonitions in Jupyter Book are visual elements that you can use to draw attention to important information.\nThere are different types of admonitions that you can use in Jupyter Book, including Note, Tip, Warning, Danger and Hint.\nYou can define an admonition by inserting an admonition code block:\n\n\n```{note}\nI'm a note!\n```\n\n\n{note} can be replaced with {warning}, {tip}, {danger} and so on. This slide shows how these admonitions will show up in the output.\nAnother way of writing the admonition syntax is to use ::: instead of ```:\n:::{note}\nI'm a note!\n:::\nThis does not change anything for how Jupyter Book interprets the content, but ensures that it is formatted as Markdown instead of as code when viewing the file in JupyterLab, which can make it easier for the eye when editing.\nYou can read more about these “Markdown-friendly” directives in the documentation."
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#grids",
    "href": "modules/module8/slides/module8_05.html#grids",
    "title": "Add your own content: Advanced features",
    "section": "Grids",
    "text": "Grids\nGrids organize content into containers:\n\n\nGrids provide an easy way for you to organize chunks of content into flexible containers on your page. They are useful for creating card-like layouts and flexible columns and rows.\nThis slide shows an example that creates a grid with two cards. Not that we are using the markdown friendly ::: directives here just as an example, we could also have used ``` instead.\nNote that:\n\nWe are nesting directives here, starting with four : for the grid directive and three : for the grid-item-card directive to indicate that the latter is a sub-directive of the outer grid directive.\n:gutter: specifies the separation width between the cards. In this case, it is set to 3.\nThe text immediately following :::{grid-item-card} will be the title of that card.\n+++ can also be used to define the card’s footer.\n\nYou can embed all kinds of content inside of grids, or have grids with columns and rows of different sizes. Check out this page for more details."
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#dropdowns",
    "href": "modules/module8/slides/module8_05.html#dropdowns",
    "title": "Add your own content: Advanced features",
    "section": "Dropdowns",
    "text": "Dropdowns\nDropdowns can hide and show content:\n\n\n\nYou can use the {dropdown} directive to create a dropdown with a title, that shows content only when clicked.\nThis is good when you want your readers to think about something on their own, before revealing the information you have written, e.g. for a practice quiz."
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#dropdown-admonitions",
    "href": "modules/module8/slides/module8_05.html#dropdown-admonitions",
    "title": "Add your own content: Advanced features",
    "section": "Dropdown admonitions",
    "text": "Dropdown admonitions\nDropdowns admonitions combine admonitions and dropdown:\n\n\n\nYou can also hide the body of your admonition blocks so that users must click a button to reveal their content.\nThis is helpful if you’d like to include some text that isn’t immediately visible to the user.\nYou can see an example in this slide."
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#showing-and-hiding-code-and-its-output",
    "href": "modules/module8/slides/module8_05.html#showing-and-hiding-code-and-its-output",
    "title": "Add your own content: Advanced features",
    "section": "Showing and hiding code and its output",
    "text": "Showing and hiding code and its output\n\n\nWe need to edit the cell’s metadata to tell Jupyter Book to show/hide the code or its output.\n\nSometimes we may not want to show the content of a code cell, or its output.\nFor example, suppose that we have the code cell in this slide. It generates a plot that is important to our readers, but maybe we don’t need to show them all the code.\nSo how can we hide the input code cell while still showing the output visualization?\nWe saw in the Jupyter notebook slide deck that we could export a notebook without its code cells using the nbconvert shell command, since there was no built-in interface element in JupyterLab to achieve this.\nFor Jupyter Book, the option to hide code input is built-in since it’s a very common use case.\nWe can hide the input of a cell by editing the cell’s metadata to tell Jupyter Book whether we want to hide the code input or its output."
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#showing-and-hiding-code-and-its-output-1",
    "href": "modules/module8/slides/module8_05.html#showing-and-hiding-code-and-its-output-1",
    "title": "Add your own content: Advanced features",
    "section": "Showing and hiding code and its output",
    "text": "Showing and hiding code and its output\nAccessing code cell metadata in JupyterLab:\n\n\nTo edit a code cell’s metadata in JupyterLab:\n\nSelect the cell and click on the gear icon in your JupyterLab environment\nThen expand the “Advanced Tools” tab"
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#showing-and-hiding-code-and-its-output-2",
    "href": "modules/module8/slides/module8_05.html#showing-and-hiding-code-and-its-output-2",
    "title": "Add your own content: Advanced features",
    "section": "Showing and hiding code and its output",
    "text": "Showing and hiding code and its output\n\n\n\nFor hiding the code itself, add a “Cell Tag” called hide-input to the cell via the Jupyter Lab interface. The easier way to do this is to click the button “Add Tag +” in the side panel, and type in hide-input. This will automatically populate the “Cell Metadata” box with the correct text as shown in the slide. If you wanted, you could also edit the “Cell Metadata” text box directly, but you will have to be careful getting the brackets correct."
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#showing-and-hiding-code-and-its-output-3",
    "href": "modules/module8/slides/module8_05.html#showing-and-hiding-code-and-its-output-3",
    "title": "Add your own content: Advanced features",
    "section": "Showing and hiding code and its output",
    "text": "Showing and hiding code and its output\n\n\n\nNow if you rebuild your book, the code cell will show up like the screenshot in this slide.\nYou can see that the code itself is hidden, while the output is visible. If the reader clicks the “Click to show” button, they can see the code as well."
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#showing-and-hiding-code-and-its-output-4",
    "href": "modules/module8/slides/module8_05.html#showing-and-hiding-code-and-its-output-4",
    "title": "Add your own content: Advanced features",
    "section": "Showing and hiding code and its output",
    "text": "Showing and hiding code and its output\n\n\nSimilar to the last slide, you can hide a code cell’s output by adding \"hide-output\" to the “Cell Metadata” in JupyterLab.\nThis slide shows the rendered result of hiding the output."
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#gluing-variables-in-your-notebook",
    "href": "modules/module8/slides/module8_05.html#gluing-variables-in-your-notebook",
    "title": "Add your own content: Advanced features",
    "section": "“Gluing” variables in your notebook",
    "text": "“Gluing” variables in your notebook\nUsing the glue prefix, you can:\n\nBind a variable to a name (called a “key”)\nReference that variable from your page’s content\n\n\n\nSometimes we might want to access the value of a variable within the text that we’re writing.\nThis is useful since the value in the text will be updated each time the notebook is executed, instead of having to change it manually if something changes in our data or analysis code.\nJupyter Book allows us to do this using the glue prefix, which makes it possible to “glue” numbers and even figures into our text.\nYou can see an example of gluing a numerical variable in this slide. If you are gluing a string/text variable and you want to avoid the variable value being surrounded by quotation marks in the text, you can pass the text option to the glue prefix like this: {glue:text}."
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#gluing-variables-in-your-notebook-1",
    "href": "modules/module8/slides/module8_05.html#gluing-variables-in-your-notebook-1",
    "title": "Add your own content: Advanced features",
    "section": "“Gluing” variables in your notebook",
    "text": "“Gluing” variables in your notebook\n\n\nImportant application of “gluing”:\nPreviously, we have learned how to give auto-numbered and referenceable captions to figures that contain image files. However, we’ve never discussed how we can do the same for figures generated right in notebook. Good news is, gluing can be used for giving captions to figures generated from code as well.\nHere I first create an altair figure and then I assign it to a variable called fig.\nThen I glue the name altair_fig to fig, so I can use it later elsewhere in my Jupyter Book.\nAfter doing this, Jupyter Book knows about that figure object, so I can “paste” the object anywhere I want. Here, I’ve used this functionality to give an auto-numbered and referenceable caption to my figure."
  },
  {
    "objectID": "modules/module8/slides/module8_05.html#gluing-variables-in-your-notebook-2",
    "href": "modules/module8/slides/module8_05.html#gluing-variables-in-your-notebook-2",
    "title": "Add your own content: Advanced features",
    "section": "“Gluing” variables in your notebook",
    "text": "“Gluing” variables in your notebook\n\n\nAnd here is what this Jupyter notebook looks like when rendered by Jupyter Book:\nNote that:\n\nI’ve hidden the piece of code that generates the altair figure. I did this using cell metadata tags that we discussed in the earlier slides.\nMoreover, in the HTML version of your built book, try using your mouse to drag and zoom in/out on the figure. You’ll see that the figure is interactive, just like in a Jupyter notebook!"
  },
  {
    "objectID": "modules/module8/slides/module8_01.html#what-is-jupyter-book",
    "href": "modules/module8/slides/module8_01.html#what-is-jupyter-book",
    "title": "Create your first Jupyter Book",
    "section": "What is Jupyter Book?",
    "text": "What is Jupyter Book?\n\n\nLogo source\n\nKey Jupyter Book features:\n\nWrite publication-quality content\nWrite content in multiple formats\nAdd interactivity to your book\nGenerate a variety of outputs\nA command-line interface\n\n\nJupyter Book is an open source project to help you create publication-quality books and documents from Markdown documents and Jupyter Notebooks.\n\nKey Jupyter Book features:\n\nWrite publication-quality content including figures, math, citations and cross-references\nWrite content as Jupyter Notebooks, Markdown, or reStructuredText\nAdd interactivity to your book, e.g., toggle visibility of cells, connect with an online service like Binder, and include interactive outputs (e.g., figures and widgets)\nGenerate a variety of outputs, including websites (which might use HTML, CSS, JS), markdown and PDF.\nJupyterBook provides a command-line interface to quickly build books, for example, you can run jupyter-book build my-book/ to easily build the output of your book.\n\nUnder the hood, Jupyter Books rely on the well-regarded Sphinx documentation system, which is the gold standard for writing Python package documentation. This makes writing Jupyter Book both powerful and flexible."
  },
  {
    "objectID": "modules/module8/slides/module8_01.html#book-building-process",
    "href": "modules/module8/slides/module8_01.html#book-building-process",
    "title": "Create your first Jupyter Book",
    "section": "Book building process",
    "text": "Book building process\n\nBuilding a Jupyter Book broadly consists of these steps:\n\n\n✏️ Create your book’s content\n\n\n\n🛠 Build your book\n\n\n\n📚 Publish your book online\n\n\nBuilding a Jupyter Book broadly consists of these steps:\n\n✏️ Create your book’s content.\n\nYou structure your book with a collection of folders, files, and configuration.\n\n🛠 Build your book.\n\nUsing Jupyter Book’s command-line interface you can convert your pages into either an HTML or a PDF book.\n\n📚 Publish your book online.\n\nOnce your book is built, you can share it with others. Most common is to build HTML, and host it as a public website."
  },
  {
    "objectID": "modules/module8/slides/module8_01.html#anatomy-of-a-jupyter-book",
    "href": "modules/module8/slides/module8_01.html#anatomy-of-a-jupyter-book",
    "title": "Create your first Jupyter Book",
    "section": "Anatomy of a Jupyter Book",
    "text": "Anatomy of a Jupyter Book\n\nThe three components of every Jupyter Book:\n\nA configuration file (_config.yml)\nA table of contents file (_toc.yml)\nYour book’s content\n\n\nThere are three things that you need in order to build a Jupyter Book.\n\nA configuration file (_config.yml)\nA table of contents file (_toc.yml)\nYour book’s content\n\nWe will learn about these more in detail in the later part of this slide deck, but let’s first see how we can conveniently generate a template of a sample book with all the necessary files for a book."
  },
  {
    "objectID": "modules/module8/slides/module8_01.html#generate-a-sample-book-with-template-files",
    "href": "modules/module8/slides/module8_01.html#generate-a-sample-book-with-template-files",
    "title": "Create your first Jupyter Book",
    "section": "Generate a sample book with template files",
    "text": "Generate a sample book with template files\nCreate a sample book:\njupyter-book create my-book/\n\nThe created directory my-book/ should look like this:\nmy-book/\n├── _config.yml\n├── _toc.yml\n├── intro.md\n├── logo.png\n├── markdown-notebooks.md\n├── markdown.md\n├── notebooks.ipynb\n├── references.bib\n└── requirements.txt\n\nJupyter Book comes bundled with a lightweight sample book that you can use both to help you understand a book’s structure and as templates to build your own book from.\nYou can create a sample book by running the following command (the name of the folder can be anything, here we chose my-book/ as an example):\njupyter-book create my-book/\nThis will generate a small Jupyter Book in your current working directory that you can both build and explore locally.\nThis is helpful since we can quickly get an overview of what a full Jupyter Book looks like, instead of figuring it out while creating the files one by one ourselves.\nThe created directory my-book/ should look like this:\nmy-book/\n├── _config.yml\n├── _toc.yml\n├── intro.md\n├── logo.png\n├── markdown-notebooks.md\n├── markdown.md\n├── notebooks.ipynb\n├── references.bib\n└── requirements.txt\nYou can see that this structure includes the configuration and structure files that we mentioned on the previous slide (i.e., _config.yml and _toc.yml). It also includes the following:\n\nThe landing page in intro.md\nA logo for the book in logo.png\nContent for the book in markdown-notebooks.md, markdown.md, and notebook.ipynb\nLiterary references in references.bib\nThe Python packages required to build the book in requirements.txt\n\nWe will use this sample Jupyter Book as a starting point to work from in the rest of this slide deck and explain each of the book parts in more detail."
  },
  {
    "objectID": "modules/module8/slides/module8_01.html#book-configuration-_config.yml",
    "href": "modules/module8/slides/module8_01.html#book-configuration-_config.yml",
    "title": "Create your first Jupyter Book",
    "section": "Book configuration (_config.yml)",
    "text": "Book configuration (_config.yml)\n\nAll of the configuration for your book is in a YAML file called _config.yml.\n\nHere’s an example of a simple _config.yml file:\n# In _config.yml\ntitle: My sample book\nauthor: The Jupyter Book Community\nlogo: logo.png\nexecute:\n  execute_notebooks: force\n\n# Add a bibtex file so that we can create citations\nbibtex_bibfiles:\n  - references.bib\n\nAll of the configuration for your book is in a file called _config.yml. This file is in the YAML format, just as the environment.yml files that we created in Module 6 uses conda.\nYou can define metadata for your book (such as its title), add a book logo, turn on different “interactive” buttons (such as a Binder button for pages built from a Jupyter Notebook), and more.\nHere’s an example of a simple _config.yml file, which contains key-value pairs to specify the configuration of our book:\n\ntitle: defines a title for the book. It will show up in the left sidebar.\nauthor: adds the author’s name to your book template, for attribution.\nlogo: defines a path to an image file for your book’s logo, which will also show up in the sidebar.\nexecute: contains a collection of configuration options to control execution and caching.\nexecute_notebooks: tells Jupyter Book to force execution of any computational content each time it builds the book. By default, Jupyter Book executes and caches all book content.\nbibtex_bibfiles: is a section to define bibliography files for your Jupyter Book. This configuration activates citations for your book.\n\nThere are helpful comments in the configuration file that explain many of the additional options that can be used. For an even more extensive explanation of all the configuration options, refer to the documentation."
  },
  {
    "objectID": "modules/module8/slides/module8_01.html#table-of-contents-_toc.yml",
    "href": "modules/module8/slides/module8_01.html#table-of-contents-_toc.yml",
    "title": "Create your first Jupyter Book",
    "section": "Table of contents (_toc.yml)",
    "text": "Table of contents (_toc.yml)\n\nThe _toc.yml file defines the structure of the book:\n# In _toc.yml\nformat: jb-book\nroot: intro\nchapters:\n- file: markdown\n- file: notebooks\n- file: markdown-notebooks\n\nImportant:\n\nEach entry under chapters: is the name of a file (extensions are optional).\nThe filenames should be relative to your book’s root folder.\n\n\nJupyter Book uses your table-of-contents file to define the structure of your book. For example, your chapters, sub-chapters, etc.\nThis is a YAML file with a collection of pages, each one linking to a file in your book. Here’s an example of the _toc.yml file:\n# In _toc.yml\nformat: jb-book\nroot: intro\nchapters:\n- file: markdown\n- file: notebooks\n- file: markdown-notebooks\nThe _toc.yml can be configured to format the book either as jb-article, or jb-book.\nThe root item is considered the landing page for html builds, and is used as front matter for Latex builds.\nFor jb-book, subsequent chapters can be added under the chapters: section in the .yml file.\n\nImportant:\n\nEach entry under chapters: is the name of a file (extensions are optional).\nThe filenames should be relative to your book’s root folder.\n\nThe title of each chapter will be inferred from the title in your files, i.e. the heading specified with a single #, such as # Title, which stands for the “top-level” heading."
  },
  {
    "objectID": "modules/module8/slides/module8_01.html#table-of-contents-_toc.yml-1",
    "href": "modules/module8/slides/module8_01.html#table-of-contents-_toc.yml-1",
    "title": "Create your first Jupyter Book",
    "section": "Table of contents (_toc.yml)",
    "text": "Table of contents (_toc.yml)\n\nYou can also put chapters into different groups, which are called parts:\n\n\nYou may optionally organize your chapters into parts, by using the parts: key in your _toc.yml:\nThe parts: key accepts a list of entries, each of which defines a chapter.\nYou can number each part by including numbered: True.\nThere are more details on numbering and part-specific configuration in the documentation."
  },
  {
    "objectID": "modules/module8/slides/module8_01.html#book-content",
    "href": "modules/module8/slides/module8_01.html#book-content",
    "title": "Create your first Jupyter Book",
    "section": "Book content",
    "text": "Book content\n\nMarkdown files (.md):\n\nLet’s take a look at one of the markdown files in the template book, intro.md:\n\n\nMarkdown files (.md):\nAs we learned in the previous module, the Markdown format can be used to structure text with extra characters and syntax to give it extra meaning (e.g., using **bold** to indicate that we want that piece of text to be shown in bold font). It is very popular and used across many different technology platforms, including Jupyter Book.\n\nLet’s take a look at one of the markdown files in the template book, intro.md:\n\nYou can see that there are some special formatting that we didn’t learn about in the last module, e.g. :::. There are some additions to the regular Markdown syntax that are specific for Jupyter Book and we will learn more about them in the next slide deck."
  },
  {
    "objectID": "modules/module8/slides/module8_01.html#book-content-1",
    "href": "modules/module8/slides/module8_01.html#book-content-1",
    "title": "Create your first Jupyter Book",
    "section": "Book content",
    "text": "Book content\n\nJupyter Notebooks (.ipynb):\n\n\nJupyter Notebooks (.ipynb):\nThe other type of content is a Jupyter Notebook file with the .ipynb extension.\nJupyter Notebooks have a combination of computational content and narrative content.\nEach notebook is associated with a kernel (e.g. Python, R, Julia) that defines the language used to execute the notebook’s computational content.\nBy default, when Jupyter Book builds your book, notebooks will be executed and their outputs cached. On subsequent builds, notebook pages will be re-executed only if their code has changed.\nAny outputs generated by the notebook will be inserted into your built book (though they may not be in your input notebook). This way you do not need to store the notebook’s outputs with your repository."
  },
  {
    "objectID": "modules/module8/slides/module8_01.html#time-to-build-your-book",
    "href": "modules/module8/slides/module8_01.html#time-to-build-your-book",
    "title": "Create your first Jupyter Book",
    "section": "Time to build your book!",
    "text": "Time to build your book!\nRun the build command in the sample book folder:\njupyter-book build my-book/\n\nContent of the build directory (my-book/_build/html/):\nhtml/\n├── _panels_static\n│   ├── ...\n├── _sources\n│   ├── intro.md\n│   ├── markdown-notebooks.ipynb\n│   ├── ...\n├── _static\n│   ├── ...\n├── index.html\n...\n\nNow that we’ve added content and configured our book, it’s time to “build” the book.\nYou can think of the build process as a more advanced type of export for Jupyter Notebooks, since it will take your source documents and will create output documents (e.g. like a web page) that can be used to present your book.\nSince we have already created the sample book in the folder my-book/, you can run the following build command in your terminal to create a fully functioning HTML website:\njupyter-book build my-book/\nNote: You can use the short-hand jb instead of jupyter-book in the above command, and run jb build my-book/ instead.\n\nIf you look into my-book/_build/html/ folder, you’ll see something like this:\nhtml/\n├── _panels_static\n│   ├── ...\n├── _sources\n│   ├── intro.md\n│   ├── markdown-notebooks.ipynb\n│   ├── ...\n├── _static\n│   ├── ...\n├── index.html\n...\nThese are all the files needed for a standalone website!"
  },
  {
    "objectID": "modules/module8/slides/module8_01.html#your-first-jupyter-book-website",
    "href": "modules/module8/slides/module8_01.html#your-first-jupyter-book-website",
    "title": "Create your first Jupyter Book",
    "section": "Your first Jupyter Book website",
    "text": "Your first Jupyter Book website\n\nThis is what your home page file _build/html/index.html looks like:\n\n\nYou can view the website you just created by opening _build/html/index.html using any browser that you like. You should see a webpage like this:\n\nAlthough this page opens in a browser, so far it only exists locally on your computer. Later in this module we will see how you can make this book publicly available using GitHub’s publishing system."
  },
  {
    "objectID": "modules/module8/module8-09-what_did_we_just_learn.html",
    "href": "modules/module8/module8-09-what_did_we_just_learn.html",
    "title": "5. What Did We Just Learn?",
    "section": "",
    "text": "5. What Did We Just Learn?\n\nVideoSlides",
    "crumbs": [
      "**M8. Jupyter Book**",
      "5. What Did We Just Learn?"
    ]
  },
  {
    "objectID": "modules/module8/module8-07-publish_your_book_online.html",
    "href": "modules/module8/module8-07-publish_your_book_online.html",
    "title": "4. Publish your book online",
    "section": "",
    "text": "4. Publish your book online\n\nVideoSlides",
    "crumbs": [
      "**M8. Jupyter Book**",
      "4. Publish your book online"
    ]
  },
  {
    "objectID": "modules/module8/module8-05-add_your_own_content:_advanced_features.html",
    "href": "modules/module8/module8-05-add_your_own_content:_advanced_features.html",
    "title": "3. Add your own content: Advanced features",
    "section": "",
    "text": "3. Add your own content: Advanced features\n\nVideoSlides",
    "crumbs": [
      "**M8. Jupyter Book**",
      "3. Add your own content: Advanced features"
    ]
  },
  {
    "objectID": "modules/module8/module8-03-add_your_own_content:_essentials.html",
    "href": "modules/module8/module8-03-add_your_own_content:_essentials.html",
    "title": "2. Add your own content: Essentials",
    "section": "",
    "text": "2. Add your own content: Essentials\n\nVideoSlides",
    "crumbs": [
      "**M8. Jupyter Book**",
      "2. Add your own content: Essentials"
    ]
  },
  {
    "objectID": "modules/module8/module8-01-create_your_first_jupyter_book.html",
    "href": "modules/module8/module8-01-create_your_first_jupyter_book.html",
    "title": "1. Create your first Jupyter Book",
    "section": "",
    "text": "1. Create your first Jupyter Book\n\nVideoSlides",
    "crumbs": [
      "**M8. Jupyter Book**",
      "1. Create your first Jupyter Book"
    ]
  },
  {
    "objectID": "modules/module7/slides/module7_09.html#module-learning-outcomes",
    "href": "modules/module7/slides/module7_09.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 7",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nPerform literate data science programming using Jupyter Notebooks.\nUse Markdown to efficiently produce formatted text.\nEnhance productivity via advanced JupyterLab features.\nExport notebooks to various formats for sharing your work.\n\n\nThe assignment will concentrate on the learning objectives as well as building knowledge on existing concepts."
  },
  {
    "objectID": "modules/module7/slides/module7_05.html#using-multiple-views-of-the-same-content",
    "href": "modules/module7/slides/module7_05.html#using-multiple-views-of-the-same-content",
    "title": "Intermediate JupyterLab tips and tricks",
    "section": "Using multiple views of the same content",
    "text": "Using multiple views of the same content\n\nIn JupyterLab, you can change the way you view content in three main ways:\n\nOpening an additional view of the same notebook.\nOpening an additional view of the output of a specific cell.\nRender cell output on the side of a code cell instead of below it.\n\n\nAs we’ve learned previously, it is possible to have multiple windows open in JupyterLab.\nIn fact, we can even view the same content in more than one window, which can be helpful when for example, you want to have two parts of a long notebook visible at the same time, or have specific space constraints to work around.\nThere are 3 main ways that can change how we can view content in JupyterLab:\n\nOpening an additional view of the same notebook\nOpening an additional view of the output of a specific cell\nRender cell output on the side of a code cell instead of below it\n\nLet’s see how views look like in JupyterLab in the next slides."
  },
  {
    "objectID": "modules/module7/slides/module7_05.html#additional-notebook-views",
    "href": "modules/module7/slides/module7_05.html#additional-notebook-views",
    "title": "Intermediate JupyterLab tips and tricks",
    "section": "1. Additional notebook views",
    "text": "1. Additional notebook views\n\n\n\nAdditional notebook views can be created by right clicking the notebook’s title bar, and choose “New View for Notebook”. An alternative way is to go to the “File” menu, and choose “New View for Notebook”.\nAs you can see here in the screenshot at the bottom of the slide, both open tabs are views of the same Jupyter notebook. Now you can work on and edit a part of the notebook, while also looking at a different part and potentially editing that part too.\nRemember, though, you can only have one cell running at a time. This is because you still have only one kernel for your notebook, even though you’re working with it from different views."
  },
  {
    "objectID": "modules/module7/slides/module7_05.html#additional-cell-output-views",
    "href": "modules/module7/slides/module7_05.html#additional-cell-output-views",
    "title": "Intermediate JupyterLab tips and tricks",
    "section": "2. Additional cell output views",
    "text": "2. Additional cell output views\n\n\n\nTo create an output view for any computational cell, you can right-click anywhere in the cell, and then choose “Create New View for Output”. This can be useful when an output can’t fit on the screen under the code cell and needs to be repositioned.\nYou can reposition the location of your new output window as you wish, by dragging the title bar of the output window to the desired position."
  },
  {
    "objectID": "modules/module7/slides/module7_05.html#side-by-side-output-views",
    "href": "modules/module7/slides/module7_05.html#side-by-side-output-views",
    "title": "Intermediate JupyterLab tips and tricks",
    "section": "3. Side-by-side output views",
    "text": "3. Side-by-side output views\n\n\nWhen vertical space is precious, another option is to enable side-by-side rendering of cell outputs. This way the output of each cell will appear horizontally to the right of the cell, thereby saving vertical space.\nThis has the advantage that it applies to all output cells. You don’t have to create a separate view for each cell as you might with cell output views.\nIn order to enable this feature, either go the “View” menu and choose “Render Side-by-Side”, or press Shift + R on your keyboard. When you do that, your notebook will look as it does in this slide."
  },
  {
    "objectID": "modules/module7/slides/module7_05.html#exporting-notebooks",
    "href": "modules/module7/slides/module7_05.html#exporting-notebooks",
    "title": "Intermediate JupyterLab tips and tricks",
    "section": "Exporting notebooks",
    "text": "Exporting notebooks\n\nTo share your work with others, it is possible to export your notebook to various formats in JupyterLab, including:\n\nHTML\nPDF\nMarkdown\n\n\n\n\nTo share your work with others, it is possible to export your notebook to various formats in JupyterLab, including:\n\nHTML\nPDF\nMarkdown\n\nExporting your notebooks to these formats means that you can share them with your colleagues even if they don’t have JupyterLab installed themself. This makes it easy to collect feedback from others, since they can work in a format that is already familiar to them.\nWe will go through some of the key export options in the next few slides, and you can always read more about Jupyter notebook exports in the documentation."
  },
  {
    "objectID": "modules/module7/slides/module7_05.html#notebook-to-html",
    "href": "modules/module7/slides/module7_05.html#notebook-to-html",
    "title": "Intermediate JupyterLab tips and tricks",
    "section": "1. Notebook to HTML",
    "text": "1. Notebook to HTML\n\n\nTo export your notebook to HTML, go to File -&gt; Save and Export Notebook As... -&gt; HTML in the JupyterLab menu bar.\nYou can see how our notebook looks like when converted to HTML in this slide. This is the format used to show content on the web. Converting to HTML often means that all your plots and animations will show up just as they do in the JupyterLab interface.\nTherefore, converting a notebook to HTML is convenient when you want to share it with someone who does not have JupyterLab installed on their computer, while keeping most formatting and visualizations intact.\nAfter exporting, you can simply send the HTML file in a email to your colleague and they can download and open the file in any modern browser, such as Firefox or Google Chrome."
  },
  {
    "objectID": "modules/module7/slides/module7_05.html#notebook-to-pdf",
    "href": "modules/module7/slides/module7_05.html#notebook-to-pdf",
    "title": "Intermediate JupyterLab tips and tricks",
    "section": "2. Notebook to PDF",
    "text": "2. Notebook to PDF\n\n\nThere are two ways to convert notebooks to PDF: the regular PDF option which requires LaTeX to be installed, and the newer “WebPDF” option.\nThe WebPDF option is generally preferable, since this makes the output PDF document look more like what you see in JupyterLab, whereas the LaTeX PDF option will format the output document quite differently.\nYou can export to WebPDF by going to File -&gt; Save and Export Notebook As... -&gt; WebPDF.\nIf you don’t have this option available, you might need to run pip install nbconvert[webpdf] in the environment where you have JupyterLab installed (more details on webpdf in the documentation).\nIt’s worth noting that the WebPDF option does not support rendering images that are inserted using HTML tags."
  },
  {
    "objectID": "modules/module7/slides/module7_05.html#notebook-to-markdown",
    "href": "modules/module7/slides/module7_05.html#notebook-to-markdown",
    "title": "Intermediate JupyterLab tips and tricks",
    "section": "3. Notebook to Markdown",
    "text": "3. Notebook to Markdown\n\n\nWe’ve learned quite a bit about the Markdown format so far in this module. The Markdown option converts your notebook to a Markdown file that only contains plain text, and can be opened with any text editor. In order to see the rendered Markdown file, however, you need to open it using JupyterLab or another IDE like VS Code.\nIn the screenshot on this slide, you can see what an example notebook would look like when converted to Markdown. Note how computational cells are converted to Markdown code blocks with appropriate syntax highlighting.\nIt is actually possible to work with notebooks directly in Markdown format instead of the default JSON format in which .ipynb files are stored. This has the advantage of making the notebook source files easier on the eyes, which can be helpful when reviewing other people’s code on GitHub. This is why it’s preferred to store notebooks as Mardown documents in some organizations.\nTo do this, you need to install the Jupytext extension. We will show you how to install extensions in the next few slides."
  },
  {
    "objectID": "modules/module7/slides/module7_05.html#jupyterlab-extensions",
    "href": "modules/module7/slides/module7_05.html#jupyterlab-extensions",
    "title": "Intermediate JupyterLab tips and tricks",
    "section": "JupyterLab extensions",
    "text": "JupyterLab extensions\n\nJupyterLab is built to be modular and extensible by nature\nWhen a feature is needed, developers can add it to JupyterLab by creating an extension\nJupyterLab itself is mainly a collection of various extensions\n\n\n\nJupyterLab is built to be modular and extensible by nature. When a feature does not already exist in JupyterLab, developers can create an extension to provide that feature for JupyterLab.\nDo you remember using the Git extension in JupyterLab in previous modules? Well, as the name suggests, that was an extension that was added on to JupyterLab when you followed the installation guide in Assignment 0!\nAs a matter of fact, JupyterLab itself is mainly a collection of various extensions. We will cover some of the highlights for JupyterLab extensions in the next few slides and you can find out more about JupyterLab extensions in the documentation."
  },
  {
    "objectID": "modules/module7/slides/module7_05.html#installing-jupyterlab-extensions",
    "href": "modules/module7/slides/module7_05.html#installing-jupyterlab-extensions",
    "title": "Intermediate JupyterLab tips and tricks",
    "section": "Installing JupyterLab extensions",
    "text": "Installing JupyterLab extensions\n\n\nJupyterLab extensions can be either in source or prebuilt format.\n\nPrebuilt\n\nMost JupyterLab extensions are in the prebuilt format\nThey can be installed by running conda install &lt;extension_name&gt;\nThey can be used right away after installation\n\nSource\n\nSome older JupyterLab extensions still use the source format\nThese can be installed via the Extension Manager or by using jupyter labextension install &lt;extension_name&gt;\nA source extension cannot be used right away, and requires rebuilding JupyterLab\n\n\n\nAlways refer to an extension’s documentation to find the recommended way of installation.\n\n\nJupyterLab extensions can be either in source or prebuilt format.\nPrebuilt\n\nMost JupyterLab extensions are in the prebuilt format\nThey can be installed by running conda install &lt;extension_name&gt;\nThey can be used right away after installation\n\n\nSource\n\nSome older JupyterLab extensions still use the source format\nThese can be installed via the Extension Manager GUI or by running jupyter labextension install &lt;extension_name&gt; in the command line\nA source extension cannot be used right away, and requires rebuilding JupyterLab.\n\nThis rebuild operation requires a program called Node.js to be installed in your Conda environment. You can install Node.js by running conda install nodejs.\n\n\nSince there are different ways of installing extensions, make sure to always refer to an extension’s documentation to find the recommended way of installation.\nAs an example, here is the link to the installation steps recommended by the jupyterlab-git extension. This is an example of a Conda installation of a prebuilt extension."
  },
  {
    "objectID": "modules/module7/slides/module7_05.html#jupyterlab-extension-manager",
    "href": "modules/module7/slides/module7_05.html#jupyterlab-extension-manager",
    "title": "Intermediate JupyterLab tips and tricks",
    "section": "JupyterLab Extension Manager",
    "text": "JupyterLab Extension Manager\n\n\nJupyterLab provides a GUI for managing extensions.\nAs shown in the screenshots, you can view a list of installed extensions by clicking on the puzzle-piece icon on the left-hand side bar of JupyterLab.\nSuppose that we’re looking for a particular extension called “jupyterlab-drawio”. If you type “draw” in the search box at the top and hit Enter, you’ll see that this extension appears at the top. Now you just need to click “Install”, and your desired extension will be installed.\nNote that, since the extensions that you can install using the GUI are not prebuilt, you will be prompted with a message box to rebuild JupyterLab. But no need to worry! Simply click the “Rebuild” button. Finally, you’ll see a “Build Complete” message if everything is successful. It’s safest to click “Save and Reload” so that you don’t lose any unsaved changes."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#what-is-a-jupyter-notebook",
    "href": "modules/module7/slides/module7_01.html#what-is-a-jupyter-notebook",
    "title": "Jupyter notebooks",
    "section": "What is a Jupyter notebook?",
    "text": "What is a Jupyter notebook?\n\n\nA Jupyter notebook is a document that contains narrative text, alongside runnable code\nJupyter notebooks have an .ipynb extension\n\n\n\n\nA Jupyter notebook is a document that contains narrative text, alongside runnable code\nJupyter notebooks have an .ipynb extension"
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#creating-new-notebooks",
    "href": "modules/module7/slides/module7_01.html#creating-new-notebooks",
    "title": "Jupyter notebooks",
    "section": "Creating new notebooks",
    "text": "Creating new notebooks\n\n\n\nYou can create new notebooks in three ways:\nThe first way is to click the blue + button on the top left corner of the file explorer tab, which opens a new Launcher.\nYou can then click on any one of the available environment kernels to create a new notebook with that kernel. This is marked with the red arrow on the left side of this slide.\nThe second way is to click the icon in the main working area for the conda environment you want to launch, which is marked by the red arrow on the right side of this slide."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#creating-new-notebooks-1",
    "href": "modules/module7/slides/module7_01.html#creating-new-notebooks-1",
    "title": "Jupyter notebooks",
    "section": "Creating new notebooks",
    "text": "Creating new notebooks\n\n\n\nThe third way to create a new Jupyter notebook is to right-click on the empty space of the file explorer, and then choose “New notebook”. You’ll be asked to choose a kernel right afterwards, and then your new notebook will be ready."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#building-blocks-of-notebooks",
    "href": "modules/module7/slides/module7_01.html#building-blocks-of-notebooks",
    "title": "Jupyter notebooks",
    "section": "Building blocks of notebooks",
    "text": "Building blocks of notebooks\n\n\n\nA Jupyter notebook consists of cells.\nA cell is a block of characters, that can be interpreted in different ways depending on its type.\nEach cell in a notebook can be one of these three types:\n\nCode\n\nAllows the execution of code in multiple languages.\n\nMarkdown\n\nContains formatted text. We will look more at Markdown in Module 7.\n\nRaw\n\nIn a raw cell, everything appears as is, without any formatting or code execution."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#cell-selection-modes",
    "href": "modules/module7/slides/module7_01.html#cell-selection-modes",
    "title": "Jupyter notebooks",
    "section": "Cell selection modes",
    "text": "Cell selection modes\nAn active cell in a Jupyter notebook can be in either command or edit mode:\n\n\n\nWhenever you interact with a cell inside a Jupyter notebook, it becomes activated. This means that the cell is selected, and ready to be edited or executed.\nAn active cell in a Jupyter notebook can be in either command or edit mode:\n\nCommand mode:\n\nYou don’t have a cursor inside the cell\nThe cell has a grey background\nYou can hit Esc or click outside a cell to switch from edit to command mode\n\nEdit mode:\n\nYou have a cursor inside the cell\nYou can start typing or edit the code or text inside a cell\nThe cell has a white background\nYou can hit Enter or click in a cell to switch from command to edit mode"
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#cell-selection-modes-1",
    "href": "modules/module7/slides/module7_01.html#cell-selection-modes-1",
    "title": "Jupyter notebooks",
    "section": "Cell selection modes",
    "text": "Cell selection modes\n\n\nYou can also find out whether you’re in command or edit mode by looking at the status bar when you have an active cell."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#code-cells-and-kernels",
    "href": "modules/module7/slides/module7_01.html#code-cells-and-kernels",
    "title": "Jupyter notebooks",
    "section": "Code cells and kernels",
    "text": "Code cells and kernels\n\n\nCode cells contain executable code written in a specific programming language.\nEach notebook is connected to a kernel, which is the backend engine in charge of running code in a notebook.\nCode cells are executed using a notebook’s kernel.\nYou may run code cells in any order.\n\n\n\nCode cells contain executable code written in a specific programming language.\nEach notebook is connected to a kernel, which is the backend engine in charge of running code in a notebook.\n\nFor example, a Jupyter notebook can be connected to an Python kernel.\nRemember that we installed ipykernel in our Conda environments to make them visible to JupyterLab? ipykernel is the kernel we’ve been talking about here, which is nothing but an interactive Python engine that works with JupyterLab.\nWhen you create a notebook with the kernel from a particular Conda environment, you’ll have access to all packages installed in that environment. It is basically the same as running Python code in that environment.\n\nCode cells are executed using a notebook’s kernel\n\nWhen you run a code cell, the code inside the cell is sent to the kernel\nThe kernel executes the code. If there are any outputs, those will be sent back to the Jupyter notebook, and we’ll see them as the cell’s output.\n\nYou may run code cells in any order.\n\nEach time you run a code cell, the number to the left of the code cell (e.g. [8]:) is incremented by 1. This helps you keep track of the order of executions."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#running-code-cells",
    "href": "modules/module7/slides/module7_01.html#running-code-cells",
    "title": "Jupyter notebooks",
    "section": "Running code cells",
    "text": "Running code cells\nTo run a code cell:\n\nFirst make sure the cell is selected\nThen, either click the little play button in the notebook toolbar, or\nHit Shift + Enter on your keyboard\n\n\n\nTo run a code cell:\n\nFirst make sure the cell is selected\n\nYou can click anywhere in a code cell to select and activate it\nAn active code cell is indicated by a blue vertical bar on its left\n\nThen, either click the little play button in the notebook toolbar, or\nHit Shift + Enter on your keyboard\n\nYou can also use Ctrl + Enter to run a cell. The difference is that Shift + Enter runs the cell, then advances to the next cell, whereas with Ctrl + Enter the focus remains on the currently selected cell.\n\n\nNote how [ ]: next to the cell changes to [1]: when you run the cell. Anytime you run this cell, this execution count is incremented by 1."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#useful-keyboard-shortcuts-for-cell-manipulation",
    "href": "modules/module7/slides/module7_01.html#useful-keyboard-shortcuts-for-cell-manipulation",
    "title": "Jupyter notebooks",
    "section": "Useful keyboard shortcuts for cell manipulation",
    "text": "Useful keyboard shortcuts for cell manipulation\nWhen you are in command mode, you can use the following keyboard shortcuts to perform a variety of cell actions:\n\n↑: move cell selection to above cell\n↓: move cell selection to below cell\nShift + ↑: extend selection to above cell\nShift + ↓: extend selection to below cell\nA: insert a new cell above current cell\nB: insert a new cell below current cell\nDD: delete current cell\nC: copy current cell\nX: cut current cell\nV: paste already cut or copied cell below current cell\nZ: undo last cell action\nShift + Z: redo last undone cell action\nCtrl + F: find match in notebook\n\nYou’re already familiar with the following shortcuts:\n\nCtrl + Enter: run current cell\nShift + Enter: run current cell and advance\n\n\nYou can always find all keyboard shortcuts using the “Settings” menu in JupyterLab interface. Just go to “Settings” -&gt; “Advanced Settings Editor”, and in the newly opened window, select “Keyboard Shortcuts” on the left sidebar."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#consoles",
    "href": "modules/module7/slides/module7_01.html#consoles",
    "title": "Jupyter notebooks",
    "section": "Consoles",
    "text": "Consoles\n\nConsoles in JupyterLab are interactive command lines connected to a kernel.\n\n\nThere are times that you want to quickly experiment with short pieces of code, but you don’t necessarily want the code you write to be part of your Jupyter notebook.\nUsing an interactive console is a great idea in such a situation. The nice thing about it is that you can open a console that’s connected to your notebook’s kernel, so it will be aware of all variables, arrays, functions, etc. that you have defined in your notebook.\nIn order to open a console that’s connected to your notebook’s kernel, right-click on your notebook’s name in the tab bar, and choose “New Console for Notebook”."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#consoles-1",
    "href": "modules/module7/slides/module7_01.html#consoles-1",
    "title": "Jupyter notebooks",
    "section": "Consoles",
    "text": "Consoles\n\n\nHere I have opened a console for the notebook which I already created. As you can see, I print a variable called myString, which stores a string value. Because the console is connected to the notebook’s kernel, I can access that variable right from the console.\nYou can resize or move the console window as you wish. Also, remember that you can run the piece of code that you’ve entered in the input area by pressing Shift + Enter.\nSince the Jupyter Console is suitable for quick exploration, an increasing number of well-known data science packages have started to include it as part of their documentation. For example, the well-known numpy package allows you to try out NumPy directly on their web page without installing anything using a special Jupyter Console (under the “Try NumPy” section at https://numpy.org/)"
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#getting-help-when-writing-code",
    "href": "modules/module7/slides/module7_01.html#getting-help-when-writing-code",
    "title": "Jupyter notebooks",
    "section": "Getting help when writing code",
    "text": "Getting help when writing code\n\nAuto-completion:\nYou can partially type the name of a variable, function, class, or any other known name in your Python session, and then press Tab to see the available options for auto-completion.\n\n\nLike in a terminal, you can take advantage of the auto-completion capability of JupyterLab (through the IPython kernel).\nWhenever you partially type the name of a variable, function, class, etc. you can press Tab on your keyboard to see the available options. You can then press Tab and Shift + Tab to cycle through the completion and press Enter to insert the one you want.\nAuto-completion is a very handy feature also to see what methods and functions are available in a package. You can type the packages alias (e.g. np in this case for the numpy package) followed by a ., and then hit Tab to see the available options.\nIt’s important to remember that, you won’t get auto-completion until the expressions that you’re looking for are known in your Python session. This means that, for example, unless you run import numpy as np, auto-completion won’t be available for any function belonging to the Numpy package."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#getting-help-when-writing-code-1",
    "href": "modules/module7/slides/module7_01.html#getting-help-when-writing-code-1",
    "title": "Jupyter notebooks",
    "section": "Getting help when writing code",
    "text": "Getting help when writing code\n\nContextual help:\nTo see a function’s docstring, press Shift + Tab while your cursor is anywhere inside a function’s name characters:\n\n\nWhen you’re writing code, you might not remember all arguments that a particular function accepts, or the type outputs. Sometimes it’s also very helpful to be able to see a few examples of how a function can be used.\nIn these situations, you might want to have a quick look at a function’s documentation (i.e. “docstring” in Python lingo).\nIn JupyterLab, you can press Shift + Tab while your cursor is anywhere inside a function’s name characters, to quickly make the function’s documentation appear as a pop-up window.\nKeep in mind that, the documentation pop-up content depends on the cursor location. If you move your cursor to a different function and hit Shift + Tab again, the helper pop-up would show the other function’s documentation."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#getting-help-when-writing-code-2",
    "href": "modules/module7/slides/module7_01.html#getting-help-when-writing-code-2",
    "title": "Jupyter notebooks",
    "section": "Getting help when writing code",
    "text": "Getting help when writing code\n\n\n\nAnother way of accessing the docstring for various functions is to open the “Contextual Help” window by right-clicking any cell and choosing “Show Contextual Help”.\nAs soon as you click on a function’s name, the contextual help window will update to show the help for that function. This can be super useful when working with a package that you are not very familiar with and we recommend that you have the contextual help open all the time in this scenario."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#jupyter-notebooks-reproducibility",
    "href": "modules/module7/slides/module7_01.html#jupyter-notebooks-reproducibility",
    "title": "Jupyter notebooks",
    "section": "Jupyter notebooks & reproducibility",
    "text": "Jupyter notebooks & reproducibility\n\n\nIn Jupyter notebooks, it is possible (and common) to execute code cells out of order. If not careful, this can lead to reproducibility issues.\nOnce you are done with your analysis, it’s a good idea to take the following steps to ensure that your results and outputs are reproducible:\n\nRestart your notebook kernel\n\nBy doing this, you would make sure that the Python engine is fresh and does not contain any variables, functions, etc. Sometimes, you might define a variable and then delete the cell containing that piece of code. If someone else runs your notebook, they will run into error. Make sure your notebook contains everything it needs to run properly by restarting your kernel, and testing everything fresh!\nTo restart the kernel, go to the “Kernel” menu and choose “Restart Kernel…”, or click the “Restart the kernel” button in your notebook’s toolbar (shown with a circular arrow icon).\n\nAfter restarting, run all cells from the top\n\nThis way, you would be sure that your out-of-order executions do not affect the reproducibility of your code.\nTo run all cells from the top, go to the “Run” menu and choose “Run All Cells”\n\n\nYou can do the above two steps; namely, restarting and running all cells, all in one go: just click the dedicated button in your notebook’s toolbar as shown in the screenshot here on the right.\nIt’s not a bad idea to explore other similar options in the “Kernel” and “Run” menus. For example, it’s also possible and sometimes helpful to run a notebook from the top, but up to a selected cell, or run a notebook beginning from a selected cell."
  },
  {
    "objectID": "modules/module7/slides/module7_01.html#the-command-palette",
    "href": "modules/module7/slides/module7_01.html#the-command-palette",
    "title": "Jupyter notebooks",
    "section": "The Command Palette",
    "text": "The Command Palette\n\n\n\nWhenever you happen to forget where a particular command is, you can take advantage of the Command Palette in JupyterLab.\nTo open the Command Palette, go to the “View” menu and choose “Activate Command Palette”, or use the corresponding keyboard shortcut.\nIn the search box that appears, you can type the name of the command you’re looking for. The nice thing is that, it works well even if you partially remember the command’s name!"
  },
  {
    "objectID": "modules/module7/module7-09-what_did_we_just_learn.html",
    "href": "modules/module7/module7-09-what_did_we_just_learn.html",
    "title": "5. What Did We Just Learn?",
    "section": "",
    "text": "5. What Did We Just Learn?\n\nVideoSlides",
    "crumbs": [
      "**M7. JupyterLab**",
      "5. What Did We Just Learn?"
    ]
  },
  {
    "objectID": "modules/module7/module7-07-advanced_jupyterlab_tips_and_tricks.html",
    "href": "modules/module7/module7-07-advanced_jupyterlab_tips_and_tricks.html",
    "title": "4. Advanced JupyterLab tips and tricks",
    "section": "",
    "text": "4. Advanced JupyterLab tips and tricks\n\nVideoSlides",
    "crumbs": [
      "**M7. JupyterLab**",
      "4. Advanced JupyterLab tips and tricks"
    ]
  },
  {
    "objectID": "modules/module7/module7-05-intermediate_jupyterlab_tips_and_tricks.html",
    "href": "modules/module7/module7-05-intermediate_jupyterlab_tips_and_tricks.html",
    "title": "3. Intermediate JupyterLab tips and tricks",
    "section": "",
    "text": "3. Intermediate JupyterLab tips and tricks\n\nVideoSlides",
    "crumbs": [
      "**M7. JupyterLab**",
      "3. Intermediate JupyterLab tips and tricks"
    ]
  },
  {
    "objectID": "modules/module7/module7-03-markdown_for_text_formatting.html",
    "href": "modules/module7/module7-03-markdown_for_text_formatting.html",
    "title": "2. Markdown for text formatting",
    "section": "",
    "text": "2. Markdown for text formatting\n\nVideoSlides",
    "crumbs": [
      "**M7. JupyterLab**",
      "2. Markdown for text formatting"
    ]
  },
  {
    "objectID": "modules/module7/module7-01-jupyter_notebooks.html",
    "href": "modules/module7/module7-01-jupyter_notebooks.html",
    "title": "1. Jupyter notebooks",
    "section": "",
    "text": "1. Jupyter notebooks\n\nVideoSlides",
    "crumbs": [
      "**M7. JupyterLab**",
      "1. Jupyter notebooks"
    ]
  },
  {
    "objectID": "modules/module6/slides/module6_07.html#module-learning-outcomes",
    "href": "modules/module6/slides/module6_07.html#module-learning-outcomes",
    "title": "What We Learned and What to Expect in Assignment 6",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nName files in a human- and machine-readable manner.\nOrganize projects with a meaningful folder hierarchy.\nInstall packages using the conda package manager.\nManage virtual environments with conda to keep track of project-specific package versions.\n\n\nIt is now time to put into practice everything we have learned!"
  },
  {
    "objectID": "modules/module6/slides/module6_03.html#the-importance-of-project-organization",
    "href": "modules/module6/slides/module6_03.html#the-importance-of-project-organization",
    "title": "Project Organization",
    "section": "The importance of project organization",
    "text": "The importance of project organization\nBenefits of a standard project structure:\n\nWell-organized code is self documenting!\nA new collaborator would immediately know where to look for specific things\nYour future self would find it much easier to reproduce your own results\n\n\nTherefore:\n\nThe code and data that produce the end result are as important as the final product.\nIt’s hard to change your mind once you’re halfway there, so it’s best to start with a standard project structure from the very beginning.\n\n\nIn the first part of this module, we talked about how using certain filename conventions makes finding and processing relevant information easier.\nWhen it comes to organizing an entire project, it’s even more important to structure files and folders in a logical and commonly accepted way. This is because there are several benefits to maintaining a standard project structure:\n\nWell-organized code is self documenting!\nA new collaborator would immediately know where to look for specific things\nYour future self would find it much easier to reproduce your own results\n\nTherefore:\n\nThe code and data that produce the end result are as important as the final product\nIt’s hard to change your mind once you’re halfway there, so it’s best to start with a standard project structure from the very beginning"
  },
  {
    "objectID": "modules/module6/slides/module6_03.html#example-of-a-good-project-structure",
    "href": "modules/module6/slides/module6_03.html#example-of-a-good-project-structure",
    "title": "Project Organization",
    "section": "Example of a good project structure",
    "text": "Example of a good project structure\nproject-name/\n├── .gitignore\n├── README.md\n├── environment.yaml\n├── LICENSE.md\n├── data/              *.csv        \n│   ├── processed/\n│   └── raw/\n├── docs/              *.md\n├── reports/           *.html, *.pdf, *.tex\n├── notebooks/         *.ipynb\n└── src/               *.py\n    ├── __init__.py\n    │\n    ├── data\n    │   └── make_dataset.py\n    │\n    ├── models\n    │   ├── predict_model.py\n    │   └── train_model.py\n    │\n    └── visualization\n        └── visualize.py\n\nIn this slide, you can see an example of what a well-organized project structure looks like.\nNote that each category of files has its own special folder.\nWhen I look at this repo, I would immediately know where to look to find the data or where reports are kept, even if I haven never seen this project repo before.\nWhen most people agree on using more or less the same structure for organizing their projects, good things will happen. It will also be much easier for people to collaborate with each other, and for yourself to manage your project as the size and complexity of the project grows over time.\nLet’s have a closer looks at each of these directories in the next slide."
  },
  {
    "objectID": "modules/module6/slides/module6_03.html#files-and-folders-in-a-standard-project-structure",
    "href": "modules/module6/slides/module6_03.html#files-and-folders-in-a-standard-project-structure",
    "title": "Project Organization",
    "section": "Files and folders in a standard project structure:",
    "text": "Files and folders in a standard project structure:\n\n\n.gitignore: List of files not to commit to your repo\nREADME.md: General explanations about the project\nenvironment.yaml: Information about packages/libraries needed to reproduce the computational environment\ndata/: This is where the raw and processed data lives. Since your data usually doesn’t need version control, you can add this folder in .gitignore.\ndocs/: Contains documentation about the project, which can sometimes be automatically generated\nnotebooks/: This is where Jupyter notebook files go, which are used for exploration and communication.\nsrc/: Code files are usually stored in this folder, which can itself have subfolders as needed.\n\n\nHere, I just want to tell you about the role of each file and folder in an example of a standard project repo.\nNote that the naming of particular folders might be slightly different between different projects. For example, one might choose to call their code-containing folder just code or script, instead of src. But it’s still fairly easy to see that such a folder hosts programming codes in the project folder, and not data or reports."
  },
  {
    "objectID": "modules/module6/slides/module6_00.html#module-learning-outcomes",
    "href": "modules/module6/slides/module6_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module students will learn how to\n\nName files in a human- and machine-readable manner.\nOrganize projects with a meaningful folder hierarchy.\nInstall packages using the conda package manager.\nManage virtual environments with conda to keep track of project-specific package versions.\n\n\nIn this module, we will be learning about the importance of effective and efficient organization of coding projects in terms of file names, folder structures, and virtual environments."
  },
  {
    "objectID": "modules/module6/module6-04-practice_tidy_desk_tidy_mind.html",
    "href": "modules/module6/module6-04-practice_tidy_desk_tidy_mind.html",
    "title": "2.1. Exercises",
    "section": "",
    "text": "sales-proj/\n├── .gitignore\n├── README.md\n├── proj-env.yaml\n├── data/\n├── reports/\n|   ├── figures/\n│   └── visualize.py\n│\n└── src/\n    ├── __init__.py\n    ├── make_dataset.py\n    │\n    ├── analysis\n    │   ├── stat_model.py\n    │   └── ml_model.py",
    "crumbs": [
      "**M6. File Names, Project Organization, Virtual Environments**",
      "&nbsp;&nbsp; 2.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module6/module6-04-practice_tidy_desk_tidy_mind.html#practice-tidy-desk-tidy-mind",
    "href": "modules/module6/module6-04-practice_tidy_desk_tidy_mind.html#practice-tidy-desk-tidy-mind",
    "title": "2.1. Exercises",
    "section": "",
    "text": "sales-proj/\n├── .gitignore\n├── README.md\n├── proj-env.yaml\n├── data/\n├── reports/\n|   ├── figures/\n│   └── visualize.py\n│\n└── src/\n    ├── __init__.py\n    ├── make_dataset.py\n    │\n    ├── analysis\n    │   ├── stat_model.py\n    │   └── ml_model.py",
    "crumbs": [
      "**M6. File Names, Project Organization, Virtual Environments**",
      "&nbsp;&nbsp; 2.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module6/module6-00-module_learning_outcomes.html",
    "href": "modules/module6/module6-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M6. File Names, Project Organization, Virtual Environments**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#collaborative-work",
    "href": "modules/module5/slides/module5_11.html#collaborative-work",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Collaborative work",
    "text": "Collaborative work\nThere are two main strategies we can use to work with others:\n\nBranching\n Forking \n\n\nWe have learned that if you create your repository on GitHub or you are part of a team with write access to a repo, then you can clone it to your computer, make changes and then push them back to this repository. We called this style of collaboration branching.\nIf you want the code from someone else’s repository but you are not an official collaborator, you can clone it and use it on your computer. However, you cannot push your changes back to the GitHub repository because you don’t have write permissions to the repository.\nIt would still be beneficial for the repository’s owners to receive your contributions if you make code enhancements, without having to grant you full access and run the risk of breaking something. Instead of working directly on the repository, you can fork (copy) someone else’s repository and work on a branch in your own copy."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#how-can-i-fork-a-repository",
    "href": "modules/module5/slides/module5_11.html#how-can-i-fork-a-repository",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "How can I fork a repository?",
    "text": "How can I fork a repository?\n\n\n\nGo to the GitHub page of the project that you want to fork. In the upper right corner, click the icon that says “fork”. That’s it! You just forked a repo!\n\nForks are copies of other’s repositories on GitHub that you own. You can do anything you want on your fork. If you make improvements, you can send a notification to the owner of the “upstream” repository (the one you forked from) and request that they pull the code from your repository (referred to as “origin”) into theirs. As we learned earlier, this is referred to as a “pull request”, and includes a review of the code from the maintainers of the upstream repository as we discussed in the last section.\nThe fork workflow is used in many open source projects where there is often a small team of core maintainers, but contributions from many more users. For example, the JupyterLab project has around 10 members in their team, but more than 300 people have contributed code to the project and almost 2 000 has forked it.\nIn the example, we are forking the repository of the project Glosario from The Carpentries, a multilingual glossary for computing and data science terms that is also an open-source project. As you can see in the image, this repository has been forked by 168 users so far.\n🙌 Go to the GitHub page of the project that you want to fork. In the upper right corner, click the icon that says “fork”. That’s it! You just forked a repo!"
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#developing-on-a-forked-repo",
    "href": "modules/module5/slides/module5_11.html#developing-on-a-forked-repo",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Developing on a forked repo",
    "text": "Developing on a forked repo\n\n\n\nTo start developing on a fork, first clone it to your computer (your fork, not the upstream repo). It is good practice to always create a branch when you are about to add changes to a fork, and in many projects this is required, so they will not accept a pull request that comes from your main branch. This is because it is easier to keep track of branches with descriptive names compared to having all pull request branches names main, but coming from different people.\nWhen you are working on a branch you have to push your changes to GitHub and ask for it to be merged via a pull request. Since you don’t have write access to the upstream repo, you have to request that the maintainer pull your code (remember that merging is part of what happens during a pull request, so this is similar to what we did with branches via git merge, just that the code first needs to be fetched from your forked repo)"
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#keeping-your-remote-origin-up-to-date-with-the-upstream-remote",
    "href": "modules/module5/slides/module5_11.html#keeping-your-remote-origin-up-to-date-with-the-upstream-remote",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Keeping your remote (origin) up to date with the upstream remote",
    "text": "Keeping your remote (origin) up to date with the upstream remote\n\n\n\nForking a repo happens via the GitHub web interface, but this is a one time operation. If there are changes made to the upstream repo that you want to sync to your forked repo (origin), you have to first pull them from the upstream remote to your forked remote (origin).\nTo solve this you can update your forked repository with the button Sync fork. Then you can pull this changes to continue working locally before opening the pull request. In the example there are not changes in the repository that I have just forked, but if this was the case I would have to select the option update branch."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#create-a-pull-request-from-the-forked-repository",
    "href": "modules/module5/slides/module5_11.html#create-a-pull-request-from-the-forked-repository",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Create a pull request from the forked repository",
    "text": "Create a pull request from the forked repository\n\n\n\nWhen you finish your local changes and you push to the fork that lives in your user’s account, you can create the pull request to the upstream repository if you click in the Contribute button. If you have added some commits, the Open pull request option will be available.\n⚠️ You should read the CONTRIBUTING.md file before making your first contribution to a new open-source project. There you will find relevant instructions on how to participate in the project. Another file you must read is the CODE_OF_CONDUCT.md. There, you will discover information on who to contact if you ever feel uncomfortable working on the project as well as other guidelines you should adhere to in order to foster a welcoming and supportive environment among the contributors.\nBoth files are typically located in the root of the repository."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#communicating-using-github-issues",
    "href": "modules/module5/slides/module5_11.html#communicating-using-github-issues",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Communicating using GitHub issues",
    "text": "Communicating using GitHub issues\nThe “Issues” tab on the GitHub web interface\n\n\n\nRegardless of whether you are collaborating with forks or using branches directly on the main repo, you don’t just want a historical record of who changed what file and when in the project. When working on a any collaborative project, you also want a record of decisions that were made, ideas that were floated, problems that were identified and addressed, and all other communication surrounding the project.\nEmail and messaging apps are both very popular for general communication, but are not designed for project-specific communication: they often lack functionality for organizing conversations by project subtopics, searching for conversations related to particular bugs or software versions, etc.\n🙌 To open a GitHub issue, first click on the “Issues” tab, and then click the green button that says “New Issue”."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#communicating-using-github-issues-1",
    "href": "modules/module5/slides/module5_11.html#communicating-using-github-issues-1",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Communicating using GitHub issues",
    "text": "Communicating using GitHub issues\nDialog boxes and submission button for creating new GitHub issues.\n\n\n\nGitHub issues are an alternative written communication medium to email and messaging apps, and were designed specifically to facilitate project-specific communication. Issues are opened from the “Issues” tab on the project’s GitHub page, and they persist there even after the conversation is over and the issue is closed (in contrast to email, issues are not usually deleted). One issue thread is usually created per topic, and they are easily searchable using GitHub’s search tools.\nAll issues are accessible to all project collaborators, so no one is left out of the conversation. If someone mention your name with the syntax @yourname, you will get a notification. If you want to be notified about all new issues and pull requests you can click the little eye icon in the top right corner that says “Watch”. Replying to issues from email is also possible. Given all of these advantages, we highly recommend the use of issues for project-related communication."
  },
  {
    "objectID": "modules/module5/slides/module5_11.html#communicating-using-github-issues-2",
    "href": "modules/module5/slides/module5_11.html#communicating-using-github-issues-2",
    "title": "Collaborative GitHub workflows: Forking",
    "section": "Communicating using GitHub issues",
    "text": "Communicating using GitHub issues\nThe “Closed” issues tab on the GitHub web interface.\n\n\n\n🙌 When a conversation is resolved, you can click “Close issue.” The closed issue can be later viewed by clicking the “Closed” header link in the “Issue” tab. Issues will be automatically closed if you merge a PR that refers to the issue.\nAlthough you might think that GitHub issues are mostly for collaborative projects, they are highly useful for individual projects too, as it is important to record ideas and decisions for yourself in the future.\nGitHub has recently also improved issues capabilities to be used for project management, so that you don’t need to use a separate program for that. It is beyond the scope of this course to go through this topic in detail, but you can find more information about GitHub issues on this page."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#when-merging-branches-goes-social",
    "href": "modules/module5/slides/module5_07.html#when-merging-branches-goes-social",
    "title": "When merging branches goes social: opening pull requests",
    "section": "When merging branches goes social",
    "text": "When merging branches goes social\n \n\nWhen I first started we all pushed to one branch, but the problem is you push and nobody knows what changes are going through and there is no chance for a review. Our current system is that you don’t make any changes without submitting a pull request[…]and then one or more members will review it and you need one thumbs up from another team member to merge it, otherwise it can’t go in.\n\n— Kalliamvakou, E. (2014). The Code-Centric Collaboration Perspective: Evidence from GitHub.\n\nPull requests involve merging someone else’s changes into your remote repository on GitHub. They are essential for team collaboration and proper pull request review is critical for for ensuring code quality.\nIn the previous part, we did not push our feature branch to GitHub. Instead, we finished the development of this branch locally and merged it into our main branch using JupyterLab GUI or the command git merge.\nWhen working as a team, it is recommended to push your code to GitHub first and then make a pull request so that others can review it and suggest any needed adjustments before merging it."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nTo create a pull request, you have to push the changes in your branch to GitHub. After doing so, a message will appear at the top of the repository interface on GitHub and you can click the green button that says “Compare and pull request”."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request-1",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request-1",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nAfter clicking “Compare and pull request”, you will be taken to a screen that looks like the screenshot in this slide. The dropdown menus on top indicate the branches the pull request is related to. As general rule you are going to be opening pull requests from your feature branch with the main branch as the “base”, but GitHub allows you to change the base branch (the leftmost arrow in the slide) and the branch to pull the changes from (the right most arrow in the slide).\nYou should include a descriptive title for your pull request and elaborate on your suggested changes in the comment section. Remember that you can use Markdown to format the message content and that you can use the tab Preview to view what the rendered Markdown will look like before creating the pull request.\nIn the body of the message you can also indicate if it is fixing a currently open issue by typing close #1 to close issue number 1 (pull requests and issues use the same numbering system, so if there is already an open issue, the first PR would be get the number 2)."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request-2",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request-2",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nThe next step is for the upstream repository maintainers to review your work and merge it in if they approve it. You have the option of assigning someone to a pull request and/or designating the parson as reviewer.\n\nReviewers: You can choose anyone who can help from the list of prior authors that GitHub will offer as reviewers for that code. A review request will be sent to the reviewers and you will obtain a notification and email once they have submitted their feedback. If you are working with a team you will probably define guidelines for which team member reviews which PRs.\n\nAnother useful thing that you can do is to label each pull request, they can help you by grouping similar pull requests together, e.g. “Bug fixes”, “Enhancements”, etc."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#opening-a-pull-request-3",
    "href": "modules/module5/slides/module5_07.html#opening-a-pull-request-3",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Opening a pull request",
    "text": "Opening a pull request\n\n\n\nOnce you have opened a pull request you can continue adding commits by pushing them to your feature branch on GitHub (the commits will appear in chronological order). This means that you can open the pull request before finishing the work and doing so is a way to communicate that you are preparing changes to merge in main (or another branch) that will need review.\nUntil the PR is ready for review, you can open it as a “Draft” by clicking the dropdown arrow on the green button that says “Create Pull Request” and mark it as “Ready for review” later."
  },
  {
    "objectID": "modules/module5/slides/module5_07.html#pull-request-successfully-merged-and-closed",
    "href": "modules/module5/slides/module5_07.html#pull-request-successfully-merged-and-closed",
    "title": "When merging branches goes social: opening pull requests",
    "section": "Pull request successfully merged and closed",
    "text": "Pull request successfully merged and closed\n\ngit push &lt;remote&gt; --delete &lt;branch&gt;\n\n\n\nAfter a collaborator has reviewed your changes and approved the pull request, they or you can click the Merge button and accept the pull request Then, GitHub will offer you to delete the branch via the web interface. To do this you should click Delete branch button.\nPay attention to the fact that deleting a remote branch won’t affect the local branch report in your local repository. Instead, the label origin/report will disappear from your git logor project history visualisation. You still have to delete the local version of report if you want to get rid of that branch as we learned some minutes ago.\nIt is possible to delete the remote branch from the terminal using the command git push &lt;remote&gt; --delete &lt;branch&gt;. For example, the command git push origin --delete report would allow you to perform the same action that we did on GitHub in the image.\nAlthough it is not necessary to remove a branch after merging it, doing so can help to keep your repository tidy."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#how-branches-are-related",
    "href": "modules/module5/slides/module5_03.html#how-branches-are-related",
    "title": "How branches are related?",
    "section": "How branches are related 🙌",
    "text": "How branches are related 🙌\n\n\nCreate and clone a Git repository to your computer.\nCreate 2 commits (e.g. modifying README file).\nPush to GitHub.\nStart a new branch using the terminal or JupyterLab.\nCreate 2 commits in the new branch.\nGo back to the main branch.\nCreate 2 commits in the main branch.\n\n\nBefore moving forward, let’s practice!\nRemember that after you create the branch you are always going to be working on that new branch. If you want to go back to your original branch you can (1) click the name of the branch you want to return in the Branches tab (JupyterLab) or (2) run git switch &lt;branch-name&gt; (terminal).\nWe will use the repository you just created as an example for the rest of this module."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-terminal",
    "href": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-terminal",
    "title": "How branches are related?",
    "section": "Seeing how branches are related (terminal)",
    "text": "Seeing how branches are related (terminal)\n\ngit log --oneline --all --graph\n\n\n\nFor this section we are going to simulate that we start working on a project. After cloning the repository for the first time we want to see what the branches look like. To see all branches as well as a graph indicating their relationship, we can type git log --oneline --all --graph in the terminal.\nYou can clone any repository on github.com and run this command to visualize the project history. For example, in the image we are visualizing the repository of the open source project Glosario using the History tab of JupyterLab and also the command git log --oneline --all --graph in the terminal. Glosario is an open source glossary of terms used in data science that is available online and also as a library in both R and Python.\nRemember that you can use space on your keyboard to page down through the commit history and b to page up. Press q to exit back out to the terminal."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-vs-code",
    "href": "modules/module5/slides/module5_03.html#seeing-how-branches-are-related-vs-code",
    "title": "How branches are related?",
    "section": "Seeing how branches are related (VS Code)",
    "text": "Seeing how branches are related (VS Code)\n\n\n\nEven if the branch representations that we can view in the terminal and JupyterLab are correct, it is not as detailed as the one we can get from VS Code.\nOpen the current folder in VS Code by typing code . inside your git folder (remember that . is a shortcut that means “current directory”). In VS Code, go to the extensions tab and search for “git history”, install the extension. Then go to View -&gt; Command Palette and start writing Git: View History (git log). A new tab will open with the Git History. If you want to display all the branches you will have to select them in one of the menus as you can see in the image.\nWhere it currently says main, change it to show “All branches” and you should now see a nice graphical overview looking like the one in the picture. If the Git history view hangs or looks strange, press “Refresh”. You’re free to use the one you prefer between VS Code and git log, but many of the commands are the easiest to run via terminal."
  },
  {
    "objectID": "modules/module5/slides/module5_03.html#observing-the-trees",
    "href": "modules/module5/slides/module5_03.html#observing-the-trees",
    "title": "How branches are related?",
    "section": "Observing the trees",
    "text": "Observing the trees\n\n\n\nDownloading a public GitHub repository from a project you like and observing the number of branches is an excellent exercise. For example you can try to determine how many branches exist that have not been merged and where the most recent modifications have occurred.\nUnderstanding these graph-based commit history visualizations is helpful to understand the relationships between branches, provides vital information about the structure of a project, and can help you fix problems if they arise.\nIn this slide, you can see the public repository of JupyterLab that has been cloned and opened using VS Code. Here we can see that there are three active branches:\n\nThe default master branch which is indicated on the topmost row. This is the orange line in the graphical representation to the left and there are five commits visible in this image on this branch (the black dots on the orange line).\nThe branch for version 3.4 which is indicated on the second row from the top. This is the middle red line in the graphical representation and there are three commits visible in this image on this branch.\nThe branch with a long name starting with 12758-snapshots at the third row from the bottom (commit message: “Update snapshots for challenger commit”). This is the red line in the graphical representation to the right, and it contains only a single commit."
  },
  {
    "objectID": "modules/module5/slides/module5_00.html#module-learning-outcomes",
    "href": "modules/module5/slides/module5_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nManage feature-based development efficiently with Git in JupyterLab and in the terminal.\nInfer a repository’s current status and collaboration pattern by looking at visualizations of the project history in VS Code.\nDifferentiate when to use forking or branching as a collaboration strategy.\nRecognize the essential components of a pull request.\nDetermine whether directly merging changes is preferable to first opening a pull request.\nExplain when GitHub issues are helpful and how to use them.\n\n\nIn this module you will discover how to efficiently collaborate with Git and GitHub by using branches, forks and pull requests."
  },
  {
    "objectID": "modules/module5/module5-00-module_learning_outcomes.html",
    "href": "modules/module5/module5-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams… Welcome to the Git nature walk!**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#unnecessary-untracked-files",
    "href": "modules/module4/slides/module4_11.html#unnecessary-untracked-files",
    "title": "What is .gitignore?",
    "section": "Unnecessary untracked files",
    "text": "Unnecessary untracked files\nYou may have encountered this before:\ngit status\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    .ipynb_checkpoints/\n    .DS_Store\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nAs we know, Git let us know about untracked files when we run the command git status. An untracked file or folder one that you didn’t have in the previous commit, and which hasn’t yet been staged. In the example on this slide, there is an untracked folder and file that are automatically saved:\n\n.ipynb_checkpoints contain old backup versions of our notebook which are saved by JupyterLab automatically.\n.DS_Store contains directory display options for the Finder application on MacOS.\n\nThe fact that they both start with a . means that they will be hidden in file browsers and in the output from ls in the terminal; an indication that they are not something that we need to work with manually, but are there for applications on our computer to use when needed.\nTherefore, we also don’t care about making these folders part of our version controlled project and we’d prefer not to have them clutter our view of the git status output, so that we instead can focus on the files we do want to track. How can we achieve this?"
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#create-a-.gitignore-file",
    "href": "modules/module4/slides/module4_11.html#create-a-.gitignore-file",
    "title": "What is .gitignore?",
    "section": "Create a .gitignore file",
    "text": "Create a .gitignore file\n\nUse a text editor of your choice (here we use VS Code) to create a file called .gitignore inside your Git repo:\ncode .gitignore\n\nInside the text file, list the files and folders you would like to ignore, one per line. For example:\n.ipynb_checkpoints/\n.DS_Store\n\nTo “hide” folders and files from Git we can create a file called .gitignore in the root/main directory of our repository (the same directory where the .git folder is located). These two slides describe how we can create this file using VS Code, and what we need to add to it in order to ignore the two files from the previous slide."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#create-a-.gitignore-file-1",
    "href": "modules/module4/slides/module4_11.html#create-a-.gitignore-file-1",
    "title": "What is .gitignore?",
    "section": "Create a .gitignore file",
    "text": "Create a .gitignore file\n \nSave the file, add it to the staging area, and commit the changes with Git.  Then try git status again. You should now see that the files are ignored by Git:\n\ngit status\nOn branch main\nnothing to commit, working tree clean"
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#gitignore-tips-and-tricks",
    "href": "modules/module4/slides/module4_11.html#gitignore-tips-and-tricks",
    "title": "What is .gitignore?",
    "section": ".gitignore tips and tricks",
    "text": ".gitignore tips and tricks\n \nHere are two useful tricks so that you can avoid doing unnecessary work when it comes to .gitignore:\n\n\nRecursively ignoring filename patterns\nUsing .gitignore_global to ignore certain patterns in every repository\n\n\nWhile we could list out every file we want to ignore in every project’s .gitignore, this can quickly become tedious to type.\nInstead, we can use filename pattern matching and global Git settings to simplify this process. We will look closer at each of these two approach in the next couple of slides."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns",
    "href": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns",
    "title": "What is .gitignore?",
    "section": "1. Recursively ignoring of filename patterns",
    "text": "1. Recursively ignoring of filename patterns\n \nWildcards can be used inside .gitignore to ignore multiple files with the same name:\n*.log\n\nPrepending **/ to filenames ignores those files in subdirectories as well:\n**/*.log\n\nThe .gitignore file accepts wildcards for matching pattern names, similar to what we learned about for the shell in Module 2. So say that we e.g. have a Git repository where a lot of log files files are created and they all end in .log. Instead of typing out the name of each file, we could add *.log to the .gitignore file and it would ignore all the log files in the root of the repository.\nIf we wanted to ignore the log files in every subdirectory of the project, we would need to use the **/ patterns, which means “in any folder”. The line in our .gitignore would now read **/*.log."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns-1",
    "href": "modules/module4/slides/module4_11.html#recursively-ignoring-of-filename-patterns-1",
    "title": "What is .gitignore?",
    "section": "1. Recursively ignoring of filename patterns",
    "text": "1. Recursively ignoring of filename patterns\n \nStarting with a ! tells git to not ignore a certain directory.\n**/*.log\n!important/*.log\n\nWhat if we wanted to ignore all the log files, except those inside a specific directory? Let’s imagine the directory of the log files we want to keep is called important. We would now need to add two lines to our .gitignore: one to ignore all log files, and a second to tell git to not ignore the log files in the important directory. It would look like this:\n**/*.log\n!important/*.log"
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#using-.gitignore_global",
    "href": "modules/module4/slides/module4_11.html#using-.gitignore_global",
    "title": "What is .gitignore?",
    "section": "2. Using .gitignore_global",
    "text": "2. Using .gitignore_global\n \nCreate a global .gitignore file in your home directory so that you do not have to create the same .gitignore for all your repos\ncode ~/.gitignore_global\n\nNow comes the second trick: There might be certain files that you’d like to always get ignored in all repos. In that case, you can add them once to a global .gitignore file called .gitignore_global which lives in your home directory."
  },
  {
    "objectID": "modules/module4/slides/module4_11.html#using-.gitignore_global-1",
    "href": "modules/module4/slides/module4_11.html#using-.gitignore_global-1",
    "title": "What is .gitignore?",
    "section": "2. Using .gitignore_global",
    "text": "2. Using .gitignore_global\n \n\nJust like for a regular .gitignore file, add a list of files and folders that you want to get ignored in all repos on your computer\nSave .gitignore_global file and configure Git to exclude the file for every Git repository in your computer.\n\ngit config --global core.excludesfile ~/.gitignore_global\n\nThis way, you’ll no longer need to add those particular files or folder names to the .gitignore file of each repo on your computer!\nYou can read more about ignoring files on the GitHub documentation"
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-jupyterlab",
    "href": "modules/module4/slides/module4_07.html#reversion-jupyterlab",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (JupyterLab)",
    "text": "Reversion (JupyterLab)\n\n\nAs we saw in the previous slide deck, it is troublesome to perform a hard reset when we are working together with collaborators online. Another approach for undoing some of your work is to create a new commit that reverts your changes. This means that nothing in your Git history is deleted, there is just a new commit added containing the reversions to each file.\nTo revert to a previous commit via JupyterLab, you can click the arrow icon in the commit you want to go back to in JupyterLab’s “History” tab, as seen in this slide."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-jupyterlab-1",
    "href": "modules/module4/slides/module4_07.html#reversion-jupyterlab-1",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (JupyterLab)",
    "text": "Reversion (JupyterLab)\n\n\nWhen you click the arrow, JupyterLab asks you for the commit title and description for the new reversion commit. You can either keep the preloaded name here or find a more meaningful one."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-jupyterlab-2",
    "href": "modules/module4/slides/module4_07.html#reversion-jupyterlab-2",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (JupyterLab)",
    "text": "Reversion (JupyterLab)\n\n\nNow you can see that you have a new commit, and the state of the your project is the same as it was previously, without deleting anything!\nRemember to push your changes if you want to keep your remote updated. In contrast to a hard reset, a reversion if more friendly for collaborating on GitHub, but it is still important to push big reversions soon and inform your collaborators, since some of them might be modifying the part that you reverted!"
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-terminal",
    "href": "modules/module4/slides/module4_07.html#reversion-terminal",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (Terminal)",
    "text": "Reversion (Terminal)\ngit revert &lt;commit hash&gt;\n\n\n\nIf you want to revert changes with the terminal you can use git revert together with the commit hash you want to revert to."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#reversion-terminal-1",
    "href": "modules/module4/slides/module4_07.html#reversion-terminal-1",
    "title": "Revert changes made to your Git project",
    "section": "Reversion (Terminal)",
    "text": "Reversion (Terminal)\n\n\n\nAfter running git revert, your default text editor will pop up so you can modify the final commit message. If you close it as it is, the message will be the default one.\nAfter closing the editor, you can view the new reversion in the project history tab or with git log. The number of files changed, insertions and deletions are informed when you are using the terminal or JupyterLab as you can see in the image."
  },
  {
    "objectID": "modules/module4/slides/module4_07.html#travelling-back-in-time",
    "href": "modules/module4/slides/module4_07.html#travelling-back-in-time",
    "title": "Revert changes made to your Git project",
    "section": "Travelling back in time 🕑",
    "text": "Travelling back in time 🕑\n \n\nDoing a hard reset ✔️\n\n\n\nReverting previous changes ✔️\n\n\nIn the last two slide decks, we have learned two ways of restoring our project to a previous point in time: hard reset and revert changes. One of the major differences is that when we select the option of doing a hard reset we are removing the previous commits we made and thereby modifying the Git history of the project. If we instead chose to revert our changes, we keep all our previous commits and add a new “reversion” commit that includes all the changes needed to make our repository identical to a previous points in time."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#comparing-commits",
    "href": "modules/module4/slides/module4_03.html#comparing-commits",
    "title": "Comparing commits",
    "section": "Comparing commits",
    "text": "Comparing commits\n\n\nWe have learned how to check the commit history of a project using GitHub, JupyterLab, and the terminal.\nWe can see some key information about each commit in the history view, such as when it was made and who made it.\nBut what if we want to examine the specific changes made between two commits in more detail? Which files had changes? Which lines exactly have been modified?"
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#comparing-commits-1",
    "href": "modules/module4/slides/module4_03.html#comparing-commits-1",
    "title": "Comparing commits",
    "section": "Comparing commits",
    "text": "Comparing commits\n  \n\n\nIn this slide you can see the comparison between two commits for a single file (README.md). The version of the file displayed on the left side is the older (commit d59b6bb) and the version on the right is more recent (commit aa2a019) The green and red highlights indicate the lines that have changed between the commits: In the example, the phrase “Hello world! has been introduced in line number four in the commit aa2a019.\nThis type of comparison is called the “diff” (difference) between commits. and it can be helpful to understand what has changed.\nLet’s explore how we can access this view in JupyterLab, the terminal, and GitHub."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#differences-between-commits-jupyterlab",
    "href": "modules/module4/slides/module4_03.html#differences-between-commits-jupyterlab",
    "title": "Comparing commits",
    "section": "🙌 Differences between commits: JupyterLab",
    "text": "🙌 Differences between commits: JupyterLab\n\n\n\nOpen the History tab in JupyterLab to see the differences between commits.\n\nOnce there, find the older commit you want to compare first and then click the file icon symbol with the left arrow. Repeat the process for the most recent commit that you want to compare, but this time you should click the file icon symbol with the right arrow. After doing so, a new section called Compare d59b6bb and aa2a019 will appear at the bottom of the History tab.\nIn that section you should choose the file for which you want to see the differences. In our example, we have only changed the README.md file. The next step is to click the file icon with the + and - symbols next to the name of the file. The differences between both commits will be displayed as a new file."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#differences-between-commits-terminal",
    "href": "modules/module4/slides/module4_03.html#differences-between-commits-terminal",
    "title": "Comparing commits",
    "section": "🙌 Differences between commits: Terminal",
    "text": "🙌 Differences between commits: Terminal\n\n\n\nAs we have seen before, the terminal is often more flexible than the graphical user interface and the same is true when comparing commits.\nLet’s first compare two commits the same way as we did with JupyterLab. For this we will use the command git diff &lt;commit 1 hash&gt; &lt;commit 2 hash&gt; as in the slide. We can read that a line including “Hello world!” was added to the README.md file.\nJust as in JupyterLab, the default is to compare the specified commit with the most recent one so what we wrote about would be equal to specifying only one commit hash (the oldest one) doing git diff d59b6bb, since aa2a019 is the most recent commit.\nNote that git diff is useful for comparing files outside Git repositories as well. You can use git diff &lt;file 1&gt; &lt;file 2&gt; to see all the differences between two text files."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#understanding-the-comparison",
    "href": "modules/module4/slides/module4_03.html#understanding-the-comparison",
    "title": "Comparing commits",
    "section": "Understanding the comparison",
    "text": "Understanding the comparison\n\n\n\nWhen visualizing differences, you can invert the commit order. As result, the output of git diff will be inverted as well. To avoid confusion, we recommend that you always use the same criteria to select the order of the commits to compare.\nYou must also pay attention to the - and + symbols. They are indicating the order in which the commits were chosen to be compared.\n\n- symbol is indicating changes in the first commit you have selected in JupyterLab or git diff first commit hash.\n+ symbol is indicating changes in the second commit you have selected in JupyterLab or git diff second commit hash.\n\nIn both cases, the phrase “Hello world!” has been added. What the - and + are showing you is in which commit is the addition! Which changes show up in red and which show up in green will also depend on which commit hash your write on the left and right side, so you cannot always rely on the color to indicate which change is the oldest.\nIf you want to understand in more detail what the git diff output you can find a more detailed description in this tutorial."
  },
  {
    "objectID": "modules/module4/slides/module4_03.html#differences-between-commits-github",
    "href": "modules/module4/slides/module4_03.html#differences-between-commits-github",
    "title": "Comparing commits",
    "section": "🙌 Differences between commits: GitHub",
    "text": "🙌 Differences between commits: GitHub\n\nhttps://github.com/flordandrea/toy_ds_project/compare/d59b6bb..aa2a019\n\n\n\nSo far we have seen how to compare commits locally in JupyterLab and via the terminal. What about visualizing the differences between commits directly on GitHub, is that possible?\nYes, it is! You can add the following line to your repository’s URL /compare/&lt;commit1&gt;..&lt;commit2&gt; (substituting in the commits hashes to compare) and you will access the view that you can see in this slide.\nRemember to use 7 characters for the commits id. Otherwise, it is not going to work! Give it a try in one of your repositories!\nAlso note that you could use ... instead of .. to compare commits, but double dot is the same as git diff &lt;commit1&gt; &lt;commit2&gt;. You can read more about the difference of two and three dots in this StackOverflow answer."
  },
  {
    "objectID": "modules/module4/slides/module4_00.html#module-learning-outcomes",
    "href": "modules/module4/slides/module4_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nExplore the Git history via git log in the terminal, and the equivalent functions in JupyterLab and GitHub.\nCompare commits using git diff in the terminal, and the equivalent functions in JupyterLab and GitHub.\nSolve merge conflicts at the command line and in VS Code.\nAvoid pushing certain local files by including a .gitignore file.\nDifferentiate between doing a revert and a hard reset of a commit when restoring an older version of a project.\n\n\nThis module covers the git history, travelling back in time, dealing with merge conflicts and other related topics."
  },
  {
    "objectID": "modules/module4/module4-10-practice_merge_with_care.html",
    "href": "modules/module4/module4-10-practice_merge_with_care.html",
    "title": "5.1. Exercises",
    "section": "",
    "text": "$ cat README.md\n\nIf you have questions, please\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nopen an issue\n=======\nask your question via email.\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; new_branch_to_merge_later",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 5.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/module4-10-practice_merge_with_care.html#practice-merge-with-care",
    "href": "modules/module4/module4-10-practice_merge_with_care.html#practice-merge-with-care",
    "title": "5.1. Exercises",
    "section": "",
    "text": "$ cat README.md\n\nIf you have questions, please\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nopen an issue\n=======\nask your question via email.\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; new_branch_to_merge_later",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 5.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/module4-02-practice_a_history_lesson.html",
    "href": "modules/module4/module4-02-practice_a_history_lesson.html",
    "title": "1.1. Exercises",
    "section": "",
    "text": "Clone the repo https://github.com/UBC-MDS/equine_numbers_value_canada, and answer the following questions.",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 1.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/module4-02-practice_a_history_lesson.html#practice-a-history-lesson",
    "href": "modules/module4/module4-02-practice_a_history_lesson.html#practice-a-history-lesson",
    "title": "1.1. Exercises",
    "section": "",
    "text": "Clone the repo https://github.com/UBC-MDS/equine_numbers_value_canada, and answer the following questions.",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "&nbsp;&nbsp; 1.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module4/module4-00-module_learning_outcomes.html",
    "href": "modules/module4/module4-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub",
    "text": "Pulling changes from GitHub\n\n\nIf you are working on a project with collaborators, they will also be making changes to files (e.g., to the analysis code in a Jupyter notebook and the project’s README file), committing them to their own local repository, and pushing to the remote GitHub repository to share their commits with you. When they push their changes, those changes will initially only exist in the remote GitHub repository and not in your local repository on your computer.\nTo obtain the new changes from the remote repository on GitHub, you will need to pull/download those changes to your own local repository. By pulling changes, you synchronize your local repository to what is present on GitHub. Additionally, until you pull changes from the remote repository, you will not be able to push any more changes yourself (though you will still be able to work and make commits in your local repository)."
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (JupyterLab IDE)",
    "text": "Pulling changes from GitHub (JupyterLab IDE)\n\n\n\nThe GitHub interface indicates the name of the last user to push a commit to the remote repository, a preview of the associated commit message, the unique commit hash, and how long ago the commit was made.\nIn this example, we can see that someone else has made a change to the repository. We can use Jupyter Lab to pull/download this change to our local Git repository."
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-1",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-1",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (JupyterLab IDE)",
    "text": "Pulling changes from GitHub (JupyterLab IDE)\n\n\n\n🙌 Practice\nTo pull from GitHub in JupyterLab, there are two steps:\nStep 1. Click the pull button in the Jupyter Lab Git extension.\nYou can tell Git to “pull” down any new changes from the remote repository at GitHub.com by clicking on the cloud icon with the down arrow in Jupyter Lab."
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-2",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-2",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (JupyterLab IDE)",
    "text": "Pulling changes from GitHub (JupyterLab IDE)\n\n\n\nIn some cases, JupyterLab can warn you about continue modyfing your files locally when there are changes in the branch you are working. It is better to always keep the files updated with the remote and pull the changes!"
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-3",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-3",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (JupyterLab IDE)",
    "text": "Pulling changes from GitHub (JupyterLab IDE)\n\n\n\n🙌 Practice\nStep 2. Refresh any open files that had changes pulled down.\nOnce the files are successfully pulled from GitHub, it is important that you refresh or reopen any files that had changes pulled down from GitHub. If you don’t, Jupyter Lab will keep displaying the old version of the file and it will be confusing if you make changes to this version instead of the newly pulled down version from GitHub.com.\nIn this slide, the red arrows are indicating the changes to the open notebook after pulling and refreshing."
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-4",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-jupyterlab-ide-4",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (JupyterLab IDE)",
    "text": "Pulling changes from GitHub (JupyterLab IDE)\n\n\n\n🙌 Practice\nThe newly pulled changes will also show up in the history tab, since they are now part of your local repository, just as any commit you made on your computer.\nIt is best practise to pull the changes at the start of each work session before you begin editing any files in your local repository."
  },
  {
    "objectID": "modules/module3/slides/module3_11.html#pulling-changes-from-github-terminal",
    "href": "modules/module3/slides/module3_11.html#pulling-changes-from-github-terminal",
    "title": "Pulling changes from a remote repository",
    "section": "Pulling changes from GitHub (Terminal)",
    "text": "Pulling changes from GitHub (Terminal)\n\n\n\n🙌 Practice\nIf you want to pull changes from GitHub.com via the terminal, you can use the command git pull. As you can see in this slide, Git will print a summary of what it changed when you run git pull (in the image one insertions/additions were made to eda.ipynb)."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#committing-the-modified-files-in-the-staging-area",
    "href": "modules/module3/slides/module3_07.html#committing-the-modified-files-in-the-staging-area",
    "title": "Committing changes to a local repository",
    "section": "Committing the modified files in the staging area",
    "text": "Committing the modified files in the staging area\n \n\n\nOnce the files we want to keep have been added to the staging area, we can “commit” them to the repository history. When we do this, we are required to include an informative message briefly describing the purpose of the changes we made.\nIn the screenshot, the commit message is \"Message about changes...\"; in your work you should make sure to replace this with an informative message about what you changed. It is also important to note that these changes are only being committed to the history of the local repository’s on your computer. The remote repository on GitHub has not changed, and collaborators would not yet be able to see your new changes online."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#committing-to-add-sections-to-your-project-history",
    "href": "modules/module3/slides/module3_07.html#committing-to-add-sections-to-your-project-history",
    "title": "Committing changes to a local repository",
    "section": "Committing to add sections to your project history",
    "text": "Committing to add sections to your project history\n \n\n\nimage source: xkcd.com\n\n\nWriting meaningful commit messages is really important. When commit messages are too vague (code additions or Add some stuff) it will be difficult to interpret for our collaborators, including ourselves in the future. Writing clear and descriptive commit messages increases the quality of your project and facilitates collaborative work."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (JupyterLab IDE)",
    "text": "Making the commit (JupyterLab IDE)\n\n\n\n🙌 Practice\nStep 3. Add a commit message into the Jupyter Git extension commit text box.\nTo commit the staged changes together with an associated commit message, you must write a message in the text box at the bottom of the Git pane and click on the blue “Commit” button (see image). It is highly recommended to write useful and meaningful messages about what was changed.\nThese commit messages, and the time stamp for a given commit, are the primary means to navigate through the project’s history in the event that you need to view or retrieve a past version of a file, or revert your project to an earlier state.\nWhen you click the “Commit” button for the very first time, you will be prompted to enter your name and email. This only needs to be done once for each machine you use Git on, and is added as author information to the commit message."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-1",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-1",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (JupyterLab IDE)",
    "text": "Making the commit (JupyterLab IDE)\n\n\n\n🙌 Practice\nStep 3 continued\nWhen committing changes, you need to include a title/summary for each message (the upper text box in JupyterLab). Optionally, you could also include a longer description for the commit in the next text box."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-2",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-2",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (JupyterLab IDE)",
    "text": "Making the commit (JupyterLab IDE)\n \nBad messages ❌ :\n\nfixes an error\nadded new code\n\n \nGood messages ✅ :\n\nReorder sections to make the README more welcoming\nFix notebook error to allow for export with images\n\n\nYou can see example of informative commit titles in this slide.\nThe general guideline for the title is to summarize the purpose of the commit as a short descriptive message. It is recommended to write your messages in imperative mood (imagine that your commit should complete the sentence “this commit will…”) and start with a capital letter."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-3",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-3",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (JupyterLab IDE)",
    "text": "Making the commit (JupyterLab IDE)\n\n\n\n🙌 Practice\nAfter recording a commit, the staging area should be empty and you will see that there are 0 staged files. You are now ready to push your changes to the remote repository on GitHub."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-4",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-jupyterlab-ide-4",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (JupyterLab IDE)",
    "text": "Making the commit (JupyterLab IDE)\n\n\n\n🙌 Practice\nAfter the changes have been successfully committed, you can view them in the History tab together with your message. You have now tracked this change and made it part of the history of your project!"
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-terminal",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-terminal",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (Terminal)",
    "text": "Making the commit (Terminal)\n\n\n\ngit commit\n\n🙌 Practice\nThe equivalent terminal command for making a commit with a title and long description, is to type git commit inside Bash and press enter. This will open your default text editor with a temporary file called COMMIT_EDITMSG where you can type in the commit message as shown in the next slide."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-terminal-1",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-terminal-1",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (Terminal)",
    "text": "Making the commit (Terminal)\n\n\n\n🙌 Practice\nYour default text editor should be VS Code if you followed the setup steps in the first assignment. If you didn’t, you might end up in a text editor called vim that runs inside the terminal as shown in this slide. vim is powerful, but has a steep learning curve, so in case this happens, you can exit vim by typing :q and then pressing Enter. Then you can go back and make sure that VS Code is your default editor by following the instructions in the first assignment."
  },
  {
    "objectID": "modules/module3/slides/module3_07.html#making-the-commit-terminal-2",
    "href": "modules/module3/slides/module3_07.html#making-the-commit-terminal-2",
    "title": "Committing changes to a local repository",
    "section": "Making the commit (Terminal)",
    "text": "Making the commit (Terminal)\n\n\n\nOften, a descriptive summary in the title field is sufficient and we don’t need to write out a long description. When this is the case, you can use the shorter version of the command git commit with the flag -m, which allows you to type in the title summary together with the command:\ngit commit -m \"Create an eda notebook\""
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#schematic-of-local-and-remote-version-control-repositories.",
    "href": "modules/module3/slides/module3_03.html#schematic-of-local-and-remote-version-control-repositories.",
    "title": "Version control repositories",
    "section": "Schematic of local and remote version control repositories.",
    "text": "Schematic of local and remote version control repositories.\n \n\n\nTypically, when we put a data analysis project under version control, we create two copies of the repository. One copy is used as our primary workspace where we create, edit, and delete files.\nThis copy is referred to as the local repository. The local repository most commonly exists on our computer or laptop, but can also exist within a workspace on a server (e.g., JupyterHub). The other copy is typically stored in a repository hosting service (e.g., GitHub), where we can easily share it with our collaborators. This copy is known as the remote repository.\nUnder the hood, Git only saves the changes between your versions rather than a complete version of the document each time, so it is also efficient in terms of disk space. Note that while Git works great for text files, such as code, it is not so great for binary files such as images because the changes between two versions of the same image cannot easily be expressed in plain text."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#tracking-the-repository-history-using-commit-messages",
    "href": "modules/module3/slides/module3_03.html#tracking-the-repository-history-using-commit-messages",
    "title": "Version control repositories",
    "section": "Tracking the repository history using commit messages",
    "text": "Tracking the repository history using commit messages\n\n\nBoth copies of the repository have a working directory where you can create, store, edit, and delete files (e.g., analysis.ipynb in the image).\nYou have probably noticed that in the local repository there is a staging area, which does not exist in the remote repository. We will soon learn more about the staging area, but for now imagine that it is a particular area in your local repository that will give you more flexibility to track your changes."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#tracking-the-repository-history-using-commit-messages-1",
    "href": "modules/module3/slides/module3_03.html#tracking-the-repository-history-using-commit-messages-1",
    "title": "Version control repositories",
    "section": "Tracking the repository history using commit messages",
    "text": "Tracking the repository history using commit messages\n\n\nBoth repositories also keep a complete project history. This history is a record of all versions of the project files that have been created. The repository history is not automatically generated; Git must be explicitly told when to record a version of the project. These records are called commits. They are a snapshot of the file contents and metadata about the repository at the time the record was created (a commit includes who made the commit, when it was made, etc.).\nIn the local and remote repositories shown in the image, there are two commits represented as gray circles. Each commit can be identified by a human-readable message, which you write when you create the commit, and a commit hash that Git automatically adds for you."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#commit-message",
    "href": "modules/module3/slides/module3_03.html#commit-message",
    "title": "Version control repositories",
    "section": "Commit message",
    "text": "Commit message\n \n\n\nThe purpose of the commit message is to contain a brief, rich description of what work was done since the last commit. Messages act as a very useful narrative of the changes to a project over its lifespan. If you ever want to view or revert to an earlier version of the project, the message can help you identify which commit to view or revert to. In this image, you can see two such messages, one for each commit: Created README.md and Added analysis draft.\nThe hash is a string of characters consisting of about 40 letters and numbers. The purpose of the hash is to serve as a unique identifier for the commit, and is used by Git to index project history. Although hashes are quite long — imagine having to type out 40 precise characters to view an old project version! — Git is able to work with shorter versions of hashes. In the image, you can see two of these shortened hashes, one for each commit: Daa29d6 and 884c7ce."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#how-can-you-create-your-repositories",
    "href": "modules/module3/slides/module3_03.html#how-can-you-create-your-repositories",
    "title": "Version control repositories",
    "section": "How can you create your repositories?",
    "text": "How can you create your repositories?\n  \n\nCreate the remote repository in www.github.com (GitHub)\nClone the repository to your local computer with the terminal OR JupyterLab IDE (Git)\n\n\nFirst, we are going to learn how to create a remote repository on GitHub and then to clone it locally using the terminal or JupyterLab.\nThere is another possible option to create a repository, that is creating it locally and then pushing it to GitHub, but we are not going to cover it in this course."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#how-can-you-create-your-repositories-1",
    "href": "modules/module3/slides/module3_03.html#how-can-you-create-your-repositories-1",
    "title": "Version control repositories",
    "section": "How can you create your repositories?",
    "text": "How can you create your repositories?\n  \n\n\nCloning a GitHub repository is not the same as downloading it to your computer. When you clone it you are downloading the files and all the project history including the commits and their associated messages. The information about your project that is not the files themselves is downloaded as a hidden folder called .git. Any folder that contains a hidden .git folder is considered a Git repository. By default, all your projects on GitHub are Git repositories.\nYou can clone your project to have a local copy using an integrated development environment (IDE) as JupyterLab or the terminal. The terminal will give you greater versatility since you can use a wide variety of commands, while the IDE will allow you to handle the basic commands in a more intuitive way.\nNext, we are going to learn more about both the steps in this slide, starting with how to create the remote repository!"
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#creating-a-remote-repository-on-github",
    "href": "modules/module3/slides/module3_03.html#creating-a-remote-repository-on-github",
    "title": "Version control repositories",
    "section": "1. Creating a remote repository on GitHub",
    "text": "1. Creating a remote repository on GitHub\n \n\n\n🙌 Practice\nBefore you can create remote repositories on GitHub, you will need a GitHub account; you can sign up for a free account at https://github.com. Once you have logged into your account, you can create a new repository to host your project by clicking on the + icon in the upper right-hand corner, and then on New Repository.\nAnother way to create a repository is by clicking the green button New on the left side of the screen."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#creating-a-remote-repository-on-github-1",
    "href": "modules/module3/slides/module3_03.html#creating-a-remote-repository-on-github-1",
    "title": "Version control repositories",
    "section": "1. Creating a remote repository on GitHub",
    "text": "1. Creating a remote repository on GitHub\n\n\n🙌 Practice\nRepositories can be set up with a variety of configurations, including a name, optional description, and the inclusion (or not) of several template files. One of the most important configuration items to choose is the visibility to the outside world, either public or private:\n\nPublic repositories can be viewed by anyone.\nPrivate repositories are only visible to you.\n\nBoth public and private repositories are only editable by you, but you can change that by giving access to other collaborators.\nTo get started with a public repository having a template README.md file, take the following steps:\n\nEnter the name of your project repository. In our example, we use canadian_languages.\nMost repositories follow a similar naming convention involving only lowercase letter words separated by either underscores or hyphens.\nChoose an option for the privacy of your repository.\nSelect the option Add a README file. This creates a placeholder README.md file in your repository’s root folder, which makes it possible to clone the repository to your computer directly.\nWhen you are happy with your repository name and configuration, click on the green Create Repository button.\n\nThat’s it! Now let’s clone it to get a local copy on your computer."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide",
    "href": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide",
    "title": "Version control repositories",
    "section": "2. Cloning a repository using Jupyter Lab (IDE)",
    "text": "2. Cloning a repository using Jupyter Lab (IDE)\n  \n\n\n🙌 Practice\nCloning a remote repository from GitHub to create a local repository results in a copy that is aware where it was obtained from, so that it knows where to send/receive new committed edits. In order to do this, first click the green button that says Code on your GitHub repo, and choose to copy the URL from the HTTPS tab.\nThe green “Code” drop-down menu contains the remote address (URL) corresponding to the location of the remote GitHub repository."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-1",
    "href": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-1",
    "title": "Version control repositories",
    "section": "2. Cloning a repository using Jupyter Lab (IDE)",
    "text": "2. Cloning a repository using Jupyter Lab (IDE)\n\n\n\n🙌 Practice\nNext, open JupyterLab and click the Jupyter Git Clone icon in the Files tab of the left side bar. We have marked this icon with a red circle in the screenshot in this slide.\nWhen you click this button a dialog box will show up, which we will explain in the next slide."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-2",
    "href": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-2",
    "title": "Version control repositories",
    "section": "2. Cloning a repository using Jupyter Lab (IDE)",
    "text": "2. Cloning a repository using Jupyter Lab (IDE)\n\n\n\n🙌 Practice\nOnce the dialog box pops up, you can paste the URL of the GitHub project repository you copied earlier and click the blue CLONE button. This will download the repository files to your computer.\nAnother way to do this is clicking on the Git icon on the side bar as you can see in the image\nIt is important to keep in mind where you want to locate your repository. Before cloning the repository, navigate to the desired folder using the File Browser button on the left sidebar.\nPay attention to not clone your repository inside another Git repository. This is not considered a good practice."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-3",
    "href": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-ide-3",
    "title": "Version control repositories",
    "section": "2. Cloning a repository using Jupyter Lab (IDE)",
    "text": "2. Cloning a repository using Jupyter Lab (IDE)\n\n\n\n🙌 Practice\nWhen the cloning is complete, you will now see a folder for the repository showing up in the file browser tab. Inside this folder are all the files that existed on your repository on GitHub."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-terminal",
    "href": "modules/module3/slides/module3_03.html#cloning-a-repository-using-jupyter-lab-terminal",
    "title": "Version control repositories",
    "section": "2. Cloning a repository using Jupyter Lab (Terminal)",
    "text": "2. Cloning a repository using Jupyter Lab (Terminal)\n  \n\n\n🙌 Practice\nIt is also possible to work with Git from the terminal instead of the JupyterLab Git client. We will later see that there are some advantages of working in the terminal for the more advanced commands. For now, let’s see how we can perform the same cloning steps in the terminal as we just did via the graphical Git client. Note that we will never need to clone a project both from the Git client and the terminal, so we are just doing this here to show you how it is done in both interfaces.\nTo clone a repository from the terminal, we will use the git clone command followed by the same URL we copied previously as can be seen in the screenshot on this slide. After the cloning has finished, you will see that the repository appears in the JupyterLab files tab, just as it did when we cloned it using the graphical Git client."
  },
  {
    "objectID": "modules/module3/slides/module3_03.html#how-do-you-know-if-youre-working-in-a-git-repository-terminal",
    "href": "modules/module3/slides/module3_03.html#how-do-you-know-if-youre-working-in-a-git-repository-terminal",
    "title": "Version control repositories",
    "section": "How do you know if you’re working in a Git repository? (Terminal)",
    "text": "How do you know if you’re working in a Git repository? (Terminal)\n  \n\n\n🙌 Practice\nAs we mentioned before, a Git repository stores all the necessary information for version control your project in a hidden folder called .git. If you want to know if you are working in a Git repository using the terminal you can use the bash command ls -a as you can see in the image. The -a flag will include into the lists of files displayed on the terminal the hidden folders. If the .git folder is present you are working in a Git repository.\nRemember to first double check that you are in the directory which the files have been cloned to. When you clone, the files will be downloaded to a subdirectory of the folder you are currently in, so you need to use cd to get to that folder before running ls -a. By cloning a repository from GitHub to your computer, you are automatically getting a copy of .git and thus, working in a Git repository."
  },
  {
    "objectID": "modules/module3/slides/module3_00.html#module-learning-outcomes",
    "href": "modules/module3/slides/module3_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nDifferentiate between the use of GitHub as a remote hosting service for version control and Git as a version control system.\nIdentify a Git repository.\nImplement Git’s clone, add, status, commit, pull, and push operations on the command line and their equivalent use in the JupyterLab IDE.\nUnderstand what it implies to use the staging area in a Git workflow.\nUse commits as the primary building block for storing a project versions together with an attached message and a unique identifier.\n\n\nThis module covers the basics of version control with Git and GitHub."
  },
  {
    "objectID": "modules/module3/module3-00-module_learning_outcomes.html",
    "href": "modules/module3/module3-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#searching-for-text-patterns-in-files",
    "href": "modules/module2/slides/module2_07.html#searching-for-text-patterns-in-files",
    "title": "Intermediate shell topics",
    "section": "Searching for text patterns in files",
    "text": "Searching for text patterns in files\ngrep \"the\" note_2022-06-22.md\nnote_2022-06-22.md:These are the first\nnote_2022-06-22.md:in the file.\n\nWe can use the grep command to search for text in files. To search for the word “the” in our notes file, we can type grep \"the\" note_2022-06-22.md. This will return every line in the file that contains the word “the”.\nWhen you have a longer command like this that you find annoying to re-type each time, you can use the up/down arrows on your keyboard to navigate the history of commands. This way you can go back to a long command easily and then just modify it a bit instead of retyping it from scratch. In a few slides we will learn about another technique to help with long commands by creating shorter aliases for them."
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#seeing-the-history-of-commands",
    "href": "modules/module2/slides/module2_07.html#seeing-the-history-of-commands",
    "title": "Intermediate shell topics",
    "section": "Seeing the history of commands",
    "text": "Seeing the history of commands\nhistory\n1  pwd\n2  ls\n3  cd Documents/\n4  cd\n5  ls -F -a\n6  history\n\nOccasionally, we might want to re-use a command that we used in the past, but don’t remember exactly what it was. The history command can help us with this as it lists all the previous commands we have run and in which order we ran them."
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#combining-commands-with-pipes",
    "href": "modules/module2/slides/module2_07.html#combining-commands-with-pipes",
    "title": "Intermediate shell topics",
    "section": "Combining commands with pipes",
    "text": "Combining commands with pipes\nhistory | grep \"ls\"\n2  ls\n5  cd ls -F -a\n7  history | grep \"ls\"\n\nAs you start using the shell more, you will realize that the history command quickly fills up and it becomes difficult to find any particular command we are looking for. In cases like these, it would be useful to be able to search in the list of commands, e.g. you might remember that your command included the word ls, but you don’t remember exactly which flags you used.\nWe just learned about grep for searching for text in files, so maybe there is someway we could use it to search the text output from the history command? In other words, could we redirect the output from the history command to grep before printing it on the screen?\nThis is exactly what a pipe (|) does, which we can use with the following syntax command1 | command2. In our case this would be history | grep \"ls\", which sends the output of ls to grep, which removes all the lines that don’t contain “ls”, before printing the remaining three lines to the screen."
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#a-complex-pipe",
    "href": "modules/module2/slides/module2_07.html#a-complex-pipe",
    "title": "Intermediate shell topics",
    "section": "A complex pipe",
    "text": "A complex pipe\nFruit Color\nkiwi green\nplum purple\napple red\napple green\nplum purple\napple red\nwatermelon red\n\ntail -n +2 fruit-colors.txt | cut -d ' ' -f2 | sort | uniq -c\n2 green\n2 purple\n3 red\n\nPipes allow us to create rather complex commands. Imagine that we have a text file containing a list of fruits and their colors as in the top of this slide. How can we count how many fruits there are of each color?\nWe need to break this down into several steps:\n\nWe don’t want to include the first line that says “Fruit Color” when we are counting. To show the entire file except this line we can use tail -n +2 to print everything from the second line to the end of the file.\nTo get only the colors, we need to cut out the second column. We can do this using the cut command, and specifying that the delimiter in this file is a space (-d ' '), and we are interesting in cutting out the second column/field (-f2).\nTo count the unique occurrences, we first need to sort the file so that all the same colors are adjacent to each other. On a sorted file, we can use the uniq command with the -c/--count flag to count the unique occurrences of words.\n\nThis is a rather complex pipe and we introduced a few new commands as well. You don’t need to worry about the details here, it is the principle that is important: With the shell you can find many useful small commands and if you string them together using a pipe, it is possible to perform rather advanced text processing directly in the shell."
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#creating-an-alias",
    "href": "modules/module2/slides/module2_07.html#creating-an-alias",
    "title": "Intermediate shell topics",
    "section": "Creating an alias",
    "text": "Creating an alias\nBefore creating the alias:\nl\nl: command not found\n\nAfter creating the alias:\nalias l=\"ls -aFltr\"\nl\ntotal 12\n-rw-rw-r-- 1 usergroup username   53 Jun 20 08:47 note_2022-06-22.md\ndrwxr-xr-x 4 usergroup username 4096 Jun 20 11:45 ../\n-rw-rw-r-- 1 usergroup username    0 Jun 20 11:53 note_2022-07-02.md.bkp\n-rw-rw-r-- 1 usergroup username    0 Jun 20 11:53 note_2022-07-02.md\n-rw-rw-r-- 1 usergroup username    0 Jun 20 11:53 note_2022-06-20.md.bkp\ndrwxrwxr-x 2 usergroup username 4096 Jun 20 14:54 ./\n\nIf you have a complex command that you run every so often, but is hard to remember, or just take a long time to type out, you can create a nickname for this command. This could e.g. be a command that uses many of option flags, or a long series of commands piped together.\nAn example of this could be to enhance the ls command, which is one we use very often and could be made more helpful by have a nickname for some of the commonly used options. Let’s say that we want to include the following options:\n\n-a list all files, including hidden ones\n-F append indicator characters to make the output easier to understand\n-l show the “long” format, which includes more information about each file (read the man page to find out more!)\n-t sort files by time instead of alphabetically\n-r sort in reverse order with the most recent file at the bottom\n\nWe could type out ls -aFltr each time, but that is cumbersome. If we instead type alias l=\"ls -aFltr\", we can use the shorter l as an “alias” for the longer command. If we want to keep this alias between reboots, we need to save it to file ~/.bash_profile (on Windows and Mac) or ~/.bashrc (on Linux) the same way we did during the setup in assignment 1."
  },
  {
    "objectID": "modules/module2/slides/module2_07.html#reading-the-manual",
    "href": "modules/module2/slides/module2_07.html#reading-the-manual",
    "title": "Intermediate shell topics",
    "section": "Reading the manual",
    "text": "Reading the manual\nman ls\nLS(1)                                                    User Commands\n \nNAME\n       ls - list directory contents\n \nSYNOPSIS\n       ls [OPTION]... [FILE]...\n \nDESCRIPTION\n       List  information  about the FILEs (the current directory by default).  Sort entries alphabetically if none of -cftuvSUX\n       nor --sort is specified.\n \n       Mandatory arguments to long options are mandatory for short options too.\n \n       -a, --all\n              do not ignore entries starting with .\n \n       -A, --almost-all\n              do not list implied . and ..\n \n       --author\n              with -l, print the author of each file\n \n       -b, --escape\n              print C-style escapes for nongraphic characters\n \n       --block-size=SIZE\n              with -l, scale sizes by SIZE when printing them; e.g., '--block-size=M'; see SIZE format below\n \n       -B, --ignore-backups\n              do not list implied entries ending with ~\n...\n\nHow can we find out what options like -t and -r do if we don’t know of them already? By reading the built-in help manual! Typing man ls brings up the manual help page for the ls command. You can navigate these pages with Space to go down and b to go Back up. q quits the manual and takes you back to the shell prompt.\nTyping / starts a search. Type in the search term and press Enter to be taken to the first hit. To continue to the next search hit, press n, and to go to the previous, press shift + n.\nTechnically, the manual pages are displayed inside a “pager” program called less, which you could use to add interactive navigation to any long piece of text. less is used widely by other shell programs, so these navigation keys are important to remember as they will be helpful to navigate other pages as well!\nNote that on Windows there is no built-in man command. Instead you can pipe the help pages into the less command manually via e.g. ls --help | less. We setup an alias for this called man during the setup in assignment one, so if you followed those instructions, you should be able to type man ls on Windows as well."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#our-file-structure",
    "href": "modules/module2/slides/module2_03.html#our-file-structure",
    "title": "Moving around",
    "section": "Our file structure",
    "text": "Our file structure\n/home/username\n├── Documents/\n│   ├── another-folder/\n│   └── my-document.pdf\n├── Downloads/\n├── Music/\n├── Pictures/\n├── .hidden-file\n├── my-program*\n└── todo.txt\n\nFor this slide deck, we will work with a file structure that looks like what is shown in this slide. We have four folders, a hidden file, and two regular files inside our user’s home directory (/home/username). Inside the Documents directory there is one additional file and one subfolder. Now let’s see how we can use different shell commands to move around in this structure."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#moving-around-in-the-shell",
    "href": "modules/module2/slides/module2_03.html#moving-around-in-the-shell",
    "title": "Moving around",
    "section": "Moving around in the shell",
    "text": "Moving around in the shell\nls -F\nDownloads/    Music/\nDocuments/    todo.txt\nPictures/     my_program*\n\nls -F Documents\nmy-document.pdf\nanother-folder/\n\nLet’s first run ls again to remind us about what the directory structure looks like.\nIf we want to see what’s in the Documents directory we can ask ls to list its contents, by passing the folder name as an argument to ls."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#absolute-and-relative-paths",
    "href": "modules/module2/slides/module2_03.html#absolute-and-relative-paths",
    "title": "Moving around",
    "section": "Absolute and relative paths",
    "text": "Absolute and relative paths\nRelative path\nDocuments/\n\nAbsolute path\n/home/username/Documents/\n\nNote that we can write paths in two separate ways. In the previous slide we used the position Documents relative to the directory we were already in. We could instead have written out it’s absolute position in the file system, starting with the root directory: /home/username/Documents. Absolute paths always start with a leading slash /.\nUsing a relative path is like telling someone to go two kilometers north and then half a kilometer east; using an absolute path is like giving them the latitude and longitude of their destination.\nThey both have different advantages: An absolute path will always be the same on your file system, whereas using relative paths makes it easier to work with collaborators across multiple computers."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#moving-to-a-directory",
    "href": "modules/module2/slides/module2_03.html#moving-to-a-directory",
    "title": "Moving around",
    "section": "Moving to a directory",
    "text": "Moving to a directory\ncd Documents\n\nThere is not output from the cd command so we use pwd to confirm where we are.\npwd\n/home/username/Documents/\n\nIf we are going to do a lot of work inside the Documents directory, the easiest thing would be to change our current working directory, so that we don’t have to type zips over and over again. The command to do this is cd, which stands for “Change Directory”, since it changes what directory we are currently inside.\ncd doesn’t print anything. This is normal: many shell commands run silently unless something goes wrong, on the theory that they should only ask for our attention when they need it. To confirm that cd has done what we asked, we can use pwd, to print the absolute path to the current directory."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#navigating-up-to-the-parent-directory",
    "href": "modules/module2/slides/module2_03.html#navigating-up-to-the-parent-directory",
    "title": "Moving around",
    "section": "Navigating up to the parent directory",
    "text": "Navigating up to the parent directory\nIncorrect command:\ncd username\ncd: username: No such file or directory\n\nCorrect command followed by pwd:\ncd ..\npwd\n/home/username\n\nWe now know how to navigate down the directory tree, but how do we go back up to our user’s home directory? It doesn’t work to simply type cd username since we are inside the Documents subdirectory.\nTo get back up, we could either type out the absolute path cd /home/username or use a special relative path called .. (two periods in a row with no spaces). This is a convenient shortcut that always means “the directory that contains the current one”, which is often called the “parent” directory of the current directory."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#listing-hidden-files",
    "href": "modules/module2/slides/module2_03.html#listing-hidden-files",
    "title": "Moving around",
    "section": "Listing hidden files",
    "text": "Listing hidden files\nls -F -a\n./             Downloads/    Music/\n../            Documents/    todo.txt\n.hidden-file   Pictures/     my_program*\n\nWhy didn’t we see the special parent directory symbol .., when we listed the directory content? ls usually doesn’t show us this special directory—since it’s always there, so displaying it every time would be a distraction.\nIn fact ls hides every file starting with ., since this is an indication that the creator of the file wanted it to be hidden (e.g. many configuration files start with .).\nWe can ask ls to include all files by using the -a option, which stands for “all”. You will see that this also includes a single dot .; this stands for the current directory.\nSome option also exist in a “long form”, in this case the -a option is equivalent to writing --all. It is also possible to combine options with a single hyphen, so ls -F -a is the same as ls -Fa."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#navigating-several-directories-at-a-time",
    "href": "modules/module2/slides/module2_03.html#navigating-several-directories-at-a-time",
    "title": "Moving around",
    "section": "Navigating several directories at a time",
    "text": "Navigating several directories at a time\nNavigate two folders down:\ncd Documents/another-folder\n\nNavigate two folders up:\ncd ../..\npwd\n/home/username\n\ncd allows us to navigate multiple directories at a time, by joining directory names with the path separator /. We can use this to navigate either down or up.\nFor example, typing cd Documents/another-folder would take us directly to the another-folder directory (in our example folder structure). Typing cd ../.. would take us two folders up: back to out home directory."
  },
  {
    "objectID": "modules/module2/slides/module2_03.html#home-directory-shortcut",
    "href": "modules/module2/slides/module2_03.html#home-directory-shortcut",
    "title": "Moving around",
    "section": "Home directory shortcut",
    "text": "Home directory shortcut\ncd ~/Documents\npwd\n/home/username/Documents\n\nThese two cd commands both return you to the home directory:\ncd ~\ncd\npwd\n/home/username\n\ncd also offers a few shortcuts for common operations, e.g. using ~ is a shortcut for typing /home/username, so no matter in which folder you are currently located, you can type cd ~/Documents to navigate to the documents folder in your home directory.\nLikewise, you could type cd ~ to navigate to your home directory, or even just cd without any path argument, since this is a special shortcut just for the home directory.\nAnother common shortcut is cd - (hyphen), which takes you back the most recent directory you visited."
  },
  {
    "objectID": "modules/module2/slides/module2_00.html#module-learning-outcomes",
    "href": "modules/module2/slides/module2_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nUse the shell to navigate the computer’s filesystem\nCreate new files and directories\nMove, copy, and delete files and directories\nUse “wildcards”\nDefine and distinguish between absolute file paths and relative file paths\nRead the shell’s built-in manual\nCombine commands with pipes\n\n\nIn this module we will learn to effectively communicate with the computer via a text-based shell."
  },
  {
    "objectID": "modules/module2/module2-00-module_learning_outcomes.html",
    "href": "modules/module2/module2-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#why-even-bother",
    "href": "modules/module1/slides/module1_05.html#why-even-bother",
    "title": "Asking Effective Questions",
    "section": "Why even bother?",
    "text": "Why even bother?\n\nYou will get help faster\nOthers will get help faster\n\n\nAsking questions effectively means that the person helping you will be able to answer your question better and quicker. Being able to answer a question quicker means more time to help others, including your future self.\nWhen questions require clarification, fewer people will be helped overall. Sometimes this in unavoidable because the question is complex, but all too often it if because the person trying to help is not given enough information to reproduce and troubleshoot the problem, or because the question is unclear."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#be-respectful-to-volunteers-helping-you",
    "href": "modules/module1/slides/module1_05.html#be-respectful-to-volunteers-helping-you",
    "title": "Asking Effective Questions",
    "section": "Be respectful to volunteers helping you",
    "text": "Be respectful to volunteers helping you\n\nPeople are often volunteering their help\nBe respectful and considerate\nDon’t ask unclear questions like this:\nWHY IS THIS CODE NOT WORKING??????\n\n\nWhen you are asking for help online, e.g. on StackOverflow or on GitHub, remember that you are often receiving help from people who are volunteering their time. So please make it as easy as possible for them to help you.\nYou might be frustrated by a problem to the point where you just want to ask something like.\n\nWHY IS THIS CODE NOT WORKING??????\n\nDon’t do this.\nNo one will help you.\nYou will get more frustrated."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#how-to-ask-effectively",
    "href": "modules/module1/slides/module1_05.html#how-to-ask-effectively",
    "title": "Asking Effective Questions",
    "section": "How to ask effectively",
    "text": "How to ask effectively\n\nMake your question easy to understand\nInclude a succinct description of the problem\nMention what you were expecting to happen and what went wrong\nInclude the minimal code to reproduce the problem\n\n\nThis slide outlines the high level parts that you want to include in an effective question. In essence, you want to make your question as easy to understand as possible and your specific problem as easy to reproduce as possible.\nIf you just include a screenshot and title your question “Help”, the person helping you has to spend time trying to figure out what you want help with instead of helping with the actual problem.\nTo avoid this, include a succinct and clear description of your problem together with the minimal code needed to reproduce it. Altogether, this is often called a “Minimal Reproducible Example” (or MRE for short), which we will learn more about on the next page."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#an-effective-question-with-a-minimal-reproducible-example",
    "href": "modules/module1/slides/module1_05.html#an-effective-question-with-a-minimal-reproducible-example",
    "title": "Asking Effective Questions",
    "section": "An effective question with a Minimal Reproducible Example",
    "text": "An effective question with a Minimal Reproducible Example\n\nSearch for other questions similar to yours.\nDescribe the issue clearly in the title and elaborate briefly in the text body.\nReduce the code to the minimum required to recreate your error, and paste it as text.\n\nIf your code includes functions or classes, include their definitions.\nCreate small toy dataset instead of using real data.\nUse triple backticks to create markdown code blocks with proper indentation and syntax highlighting.\n\nDescribe what you have tried so far, what you don’t understand or what went wrong, including any error messages and their full traceback.\n\n\nThis slide outlines the detailed steps of how to ask an effective question, starting with searching for other similar questions and also listing the key components of creating an MRE.\nIn essence, you want the person helping you to be able to copy your code and run it on their machine to reproduce the problem right away, so that they can focus on figuring out what has gone wrong.\nIf you are interested on more in-depth articles on how to create effective MRE’s, there have been several great articles written on what goes into an MRE. Here are some of the ones we recommend you to check out:\n\nhttps://stackoverflow.com/help/how-to-ask\nhttps://stackoverflow.com/help/minimal-reproducible-example\nhttps://community.rstudio.com/t/faq-whats-a-reproducible-example-reprex-and-how-do-i-do-one/5219\nhttps://reprex.tidyverse.org/ (an R package to help creating MREs from code)"
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#type-out-the-problem-for-yourself-before-asking-the-question",
    "href": "modules/module1/slides/module1_05.html#type-out-the-problem-for-yourself-before-asking-the-question",
    "title": "Asking Effective Questions",
    "section": "Type out the problem for yourself before asking the question",
    "text": "Type out the problem for yourself before asking the question\n\nType our a proper question for yourself\nSimplifying and formalizing your issue might even lead you to the solution!\n\n\nIt is easy to get frustrated by a problem, especially if you have been stuck at it for a while. When I feel this frustration myself I find it helpful and calming to put precise words on what the issue is.\nYou can start banging out words in the beginning, but as you slowly adhere to the format of asking properly, it will become like a meditative practice which calms you down and lays the foundation for posting your question online.\nIn addition to your mental well-being, writing down questions properly has another superb quality: they help you solve your own problems. The act of formalizing a question in either speech or text helps you slow down and uncover what you missed while the problem was a mere thought; it is easy to come to conclusions to quickly in our own heads and disregard possible solutions to quickly. We will look closer at this phenomena in the next slide."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#rubber-duck-debugging",
    "href": "modules/module1/slides/module1_05.html#rubber-duck-debugging",
    "title": "Asking Effective Questions",
    "section": "Rubber duck debugging",
    "text": "Rubber duck debugging\n\nImage from Tim Morris - Wikimedia Common\n\nRealizing the solution to your problem as you are verbalizing it is so common that it has a name: “Rubber duck debugging”. Allegedly, a software developer put a rubber duck on their desk and whenever they had a problem they couldn’t solve in their head, they starting talking to the toy duck, and often came upon the resolution while describing the problem for their toy duck."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#when-to-ask-for-help",
    "href": "modules/module1/slides/module1_05.html#when-to-ask-for-help",
    "title": "Asking Effective Questions",
    "section": "When to ask for help?",
    "text": "When to ask for help?\n\nArtwork by @allison_horst\n\nIt might be tempting to think of yourself as a “code hero” that can complete everything you need on your own. However, this mentality will ensure that you will get stuck and it would often be more beneficial to ask for help than to keep trying for another hour yourself.\nIt is also important to realize that there aren’t really any code heroes that excel from working all by themselves. Even people that appear to be super knowledgeable and have figured out everything on their own are in reality lifted up to where they are now by educators and developers, and supported by the community.\nIt is not a sign of weakness to ask for help, and since formulating your thoughts into a question might lead you to the correct answer, it is often beneficial to start doing this early after getting stuck."
  },
  {
    "objectID": "modules/module1/slides/module1_05.html#where-to-ask-for-help",
    "href": "modules/module1/slides/module1_05.html#where-to-ask-for-help",
    "title": "Asking Effective Questions",
    "section": "Where to ask for help",
    "text": "Where to ask for help\n\nhttps://stackoverflow.com/\n\n\n\nhttps://stats.stackexchange.com/\n\n\n\nWhen you have written down an effective question without finding the solution yourself in the process, then it is time to reach out to the data science community and ask for help.\nOne of the most common places to ask for help with programming questions is Stack Overflow. For data science questions, its sister site Cross Validated. Thousands of volunteers are answering questions on these sites everyday.\nIf you are asking your question on either of these sites, a tip is to use tags to categorize your question. These can then be used to search for an answer via the syntax [tag-name], and community members can choose to get notifications when a new question with a certain tag is asked.\nRemember, try to make your questions as easy to understand as possible!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#using-the-right-tool-for-the-job",
    "href": "modules/module1/slides/module1_01.html#using-the-right-tool-for-the-job",
    "title": "Introduction to the Data Science Toolbox",
    "section": "Using the right tool for the job",
    "text": "Using the right tool for the job\n\n\nKnowing which tools to use and how to use them effectively is a fundamental skill in many professions.\nFor example, imagine that you are trying to drive in a screw using a coin instead of a screwdriver. The process of driving in the screw would be less efficient and more laborious than it needs to be. Using a coin as a screwdriver might be acceptable in an emergency situation,but you would not want it to be part of your everyday workflow.\nNow imagine that instead of a coin, you were using a knife to drive in a screw. This will not only be inefficient, but slipping with the knife could cause significant personal injury!\nIn these examples, it is easy to see why using the right tool for the job is both the most efficient and safest option. Even when learning how to use the right tool could that take some time, the effort is worthwhile since it would give you increased efficiency and safety.\nFor tasks that are less hands-on or that does not give immediate negative feedback when something goes wrong, it can be harder to realize the negative consequences of a suboptimal tool choice. A prime example of this is when doing data analysis, where it can be tempting to reach for tools that are familiar instead of critically assessing which is the safest and most effective tool for the job. For a budding data scientist, it can be tricky to understand the long term consequences of using the wrong tool, but failing to do can lead to dire ramifications as we will see in the next slide."
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#the-consequences-of-using-the-wrong-tool",
    "href": "modules/module1/slides/module1_01.html#the-consequences-of-using-the-wrong-tool",
    "title": "Introduction to the Data Science Toolbox",
    "section": "The consequences of using the wrong tool",
    "text": "The consequences of using the wrong tool\n\n\nIn the most benign of cases, working with a less effective toolbox will be a waste of your and your employers time. A good example of this is when people repeatedly carry out tasks manually, instead of automating them which often happens when using a tool such as Excel for data analysis, instead of a programming language like Python.\nThe consequences of using the wrong tool in data science could also be more severe. A striking example of this is how cancer patients were put at risk in incorrectly administered clinical trials, based on research that had several errors introduced when using the wrong tools for data analysis. These errors were not discovered until several years later and they led to that the trials were terminated, around 25 scientific papers related to these trials were retracted, and the lead investigators were put under investigation for malpractice.\nAnother example from a couple of years ago is how the opening of a new expensive hospital was delayed because there had been an error when copying values between spreadsheet; something that could have been avoided if programmatic tools with automatic sanity checks would have been used instead (if you are interested in more details and examples on inappropriate tool use, refer to section 2.1 and 2.2 in one of our recently published papers).\nAlthough the use of improper tools and practices can lead to such negatively impactful real-life outcomes, there are few courses that focus on teaching toolbox skills to data scientists, and in many cases data scientists are expected to figure out what is effective for themselves. This is both inefficient and can lead to unfortunate and easily avoided mistakes.\nIn this course, we learn which tools to use and how to use them to facilitate they are necessary for efficient, reproducible, and collaborative data science practices, which are all important building blocks for a successful and sustained data science career.\nLet’s briefly introduce the tools in the toolbox, starting with the shell!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#the-shell-bash",
    "href": "modules/module1/slides/module1_01.html#the-shell-bash",
    "title": "Introduction to the Data Science Toolbox",
    "section": "The Shell (Bash)",
    "text": "The Shell (Bash)\n\n\n\nNavigate the filesystem\nLaunch programs\nAutomation of tasks\n\n\nThe first tool we will learn about is the shell. A shell can use to navigate our computers file system, launch programs, and automate tasks via the shell’s own programming language.\nYou can think of it as a much more powerful version of your default graphical file browser. The specific shell that we will learn more about in this course is called Bash. Bash stands for “The Bourne Again Shell”; the name was chosen as a pun to indicate that it was a rebirth with many new features compared to its predecessor “The Bourne Shell” (named after its creator Stephen Bourne).\nWe will learn more about the shell in Module 2!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#git-and-github",
    "href": "modules/module1/slides/module1_01.html#git-and-github",
    "title": "Introduction to the Data Science Toolbox",
    "section": "Git and GitHub",
    "text": "Git and GitHub\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVersion control\nCollaboration\nCommunication\n\n\nGit is a program that runs on your computer and allows you to keep track of historic versions of your files. This version control is similar to how “Track Changes” works in word processors, but much more elaborate and powerful.\nGitHub is an online platform where developers and data scientists can collaborate on their Git-based projects by raising issues, discuss features, and review code.\nGit and GitHub are used widely in both companies and hobby projects. They are the most common ways of collaborating on code and making sure that it easy to keep track of changes in code bases even as they grow large and are managed by multiple people.\nYou will learn more about Git and GitHub in modules 3-5!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#conda",
    "href": "modules/module1/slides/module1_01.html#conda",
    "title": "Introduction to the Data Science Toolbox",
    "section": "Conda",
    "text": "Conda\n\n\nInstalling programs and packages (Python, R, and more)\nManaging software versions\nSeparating software that requires different environments\n\n\nconda is a package manager, which provides a convenient way to install programs and packages. While there exist package managers that are tailor-made for programming language such as R and Python or for specific operating systems, Conda is the most widely use package manager that is both cross-platform (works on different operating systems) and allows you to install packages from many programming languages.\nConda also allows us to keep different programs separate, so that there are not conflicts when two programs requires different versions of the same software. This is called virtual environments, and we will learn more about it and other Conda features in Module 6!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#jupyterlab-and-vs-code",
    "href": "modules/module1/slides/module1_01.html#jupyterlab-and-vs-code",
    "title": "Introduction to the Data Science Toolbox",
    "section": "JupyterLab and VS Code",
    "text": "JupyterLab and VS Code\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEdit text and code files\nDevelop interactive notebooks\nCreate and view data visualizations\nGenerate reports\n\n\nAs a soft prerequisite for this course, we recommend you to already be familiar with using JupyterLab to edit Jupyter notebooks. Notebooks are powerful since they allow us to combine code, text, and rich output such as data visualizations.\nIn this course we will see some more advanced features of JupyterLab, such as how to use it with Git for version control, and also introduce you to another commonly used tool for programming: VS Code.\nVS Code is a more traditional programming environment than JupyterLab and in this course we will use it for editing text files and for some aspects of version control with Git.\nWe will learn more about VS Code during the shell and version control modules, and we will look closer at advanced JupyterLab features in Module 7!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#jupyter-book-and-markdown",
    "href": "modules/module1/slides/module1_01.html#jupyter-book-and-markdown",
    "title": "Introduction to the Data Science Toolbox",
    "section": "Jupyter Book and Markdown",
    "text": "Jupyter Book and Markdown\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate websites, books, and documentation\nAllows for code execution and interaction\nContent is written in Jupyter Notebooks and text files\n\n\nJupyter Book is an open source project for building beautiful, publication-quality books and documents. The books allow for code to be executed and for visualizations to be interacted with.\nContent for Jupter Book is written in Jupyter Notebooks and text files, using Markdown syntax. In this course, we will go beyond the simple examples of using Markdown for text formatting and extend that syntax to involve more advanced features which are helpful when authoring a book or web page with Jupyter Book.\nModule 8 will introduce you to how to use Jupyter Book!"
  },
  {
    "objectID": "modules/module1/slides/module1_01.html#a-commitment-to-open-source",
    "href": "modules/module1/slides/module1_01.html#a-commitment-to-open-source",
    "title": "Introduction to the Data Science Toolbox",
    "section": "A commitment to open source",
    "text": "A commitment to open source\n\n\nBeing able to use the software after leaving school without paying exorbitant amounts of money\nHaving access to the source code - you can learn and fix bugs\nOpen Source software is customizable and flexible\nIt’s becoming the standard in many tech companies\nYou are part of an awesome and active community!\n\n\nAll the programs mentioned in the previous slides have active development communities and are open source, which means that anyone can read the source code and contribute to these projects. Open source programs have many benefits, primarily including those that are listed on this slide.\nIt is worthwhile saying a few extra words about the second bullet point in the slide. At first, it might not sounds that great that you software has bugs, so it is worth pointing out that nearly all software has some bugs, including commercial software from multi-billion dollar companies. The difference is that when the software is open, you can report bugs yourself and even learn how to fix them together with helpful community members (if you want to)."
  },
  {
    "objectID": "modules/module1/module1-07-what_did_we_just_learn.html",
    "href": "modules/module1/module1-07-what_did_we_just_learn.html",
    "title": "4. What Did We Just Learn?",
    "section": "",
    "text": "4. What Did We Just Learn?\n\nVideoSlides",
    "crumbs": [
      "**M1. Introduction to the Data Science Toolbox**",
      "4. What Did We Just Learn?"
    ]
  },
  {
    "objectID": "modules/module1/module1-05-asking_effective_questions.html",
    "href": "modules/module1/module1-05-asking_effective_questions.html",
    "title": "3. Asking Effective Questions",
    "section": "",
    "text": "3. Asking Effective Questions\n\nVideoSlides",
    "crumbs": [
      "**M1. Introduction to the Data Science Toolbox**",
      "3. Asking Effective Questions"
    ]
  },
  {
    "objectID": "modules/module1/module1-03-how_to_use_jupyterlab.html",
    "href": "modules/module1/module1-03-how_to_use_jupyterlab.html",
    "title": "2. How to use JupyterLab",
    "section": "",
    "text": "2. How to use JupyterLab\n\nVideoSlides",
    "crumbs": [
      "**M1. Introduction to the Data Science Toolbox**",
      "2. How to use JupyterLab"
    ]
  },
  {
    "objectID": "modules/module1/module1-01-introduction_to_the_data_science_toolbox.html",
    "href": "modules/module1/module1-01-introduction_to_the_data_science_toolbox.html",
    "title": "1. Introduction to the Data Science Toolbox",
    "section": "",
    "text": "1. Introduction to the Data Science Toolbox\n\nVideoSlides",
    "crumbs": [
      "**M1. Introduction to the Data Science Toolbox**",
      "1. Introduction to the Data Science Toolbox"
    ]
  },
  {
    "objectID": "modules/module0/slides/module0_01.html#course-learning-outcomes",
    "href": "modules/module0/slides/module0_01.html#course-learning-outcomes",
    "title": "Welcome!",
    "section": "Course Learning Outcomes",
    "text": "Course Learning Outcomes\nBy the end of the course, students are expected to be able to:\n\nExplain why it is important to use the right tool for the job.\nCommunicate with the computer via a text-based shell.\nWork with projects under version control using Git and GitHub.\nUse additional version control features such as git history, reverting repositories to a previous state, and resolving with merge conflicts.\nCollaborate with Git and GitHub by using branches, forks and pull requests.\nOrganize coding projects with proper file names, folder structures, and virtual environments.\nWork more effectively with JupyterLab.\nBuild books and create websites using Jupyter Book."
  },
  {
    "objectID": "modules/module0/slides/module0_01.html#prerequisites",
    "href": "modules/module0/slides/module0_01.html#prerequisites",
    "title": "Welcome!",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nThis course does not have any formal prerequisites, but it is recommended that you have some experience with Jupyter Notebooks and JupyterLab, either from your own projects or the course Programming in Python for Data Science"
  },
  {
    "objectID": "modules/module0/module0-01-the_data_science_toolbox.html",
    "href": "modules/module0/module0-01-the_data_science_toolbox.html",
    "title": "1. The Data Science Toolbox",
    "section": "",
    "text": "1. The Data Science Toolbox\n\nVideoSlides",
    "crumbs": [
      "**M0. Welcome to The Data Science Toolbox!**",
      "1. The Data Science Toolbox"
    ]
  },
  {
    "objectID": "modules/index.html",
    "href": "modules/index.html",
    "title": "Welcome to The Data Science Toolbox!",
    "section": "",
    "text": "Welcome to The Data Science Toolbox!\nThis course is part of the Key Capabilities for Data Science program and covers topics related to workflows, plateforms and tools used in data analysis.\nIn this course, we will dive into the world of data science tools and utilities. While these are not strictly required for data analysis, they are necessary for efficient, reproducible, and collaborative data science practices, and are all important building blocks for a successful and sustained data science career.\nCourse prerequisites: Programming in Python for Data Science",
    "crumbs": [
      "**M0. Welcome to The Data Science Toolbox!**",
      "0. Welcome!"
    ]
  },
  {
    "objectID": "modules/module1/module1-00-module_learning_outcomes.html",
    "href": "modules/module1/module1-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M1. Introduction to the Data Science Toolbox**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module1/slides/module1_00.html#module-learning-outcomes",
    "href": "modules/module1/slides/module1_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you will learn how to\n\nExplain why it is important to use the right tool for the job.\nName the tools in the data science toolbox and explain their main purposes.\nDescribe the different components of the JupyterLab interface.\nAsk effective questions.\nCreate minimal reproducible code examples when asking for help.\n\n\nIn this module we will be introduced to the data science tools that we will be practicing with in this course and learn how to ask effective questions."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#project-jupyter",
    "href": "modules/module1/slides/module1_03.html#project-jupyter",
    "title": "How to use JupyterLab",
    "section": "Project Jupyter",
    "text": "Project Jupyter\n\nMain goals of Project Jupyter:\n\nProviding an ecosystem for interactive data science projects\nBeing language agnostic: support most popular programming languages\n\n\n\nThe name “Jupyter” -&gt; “Julia” + “Python” + “R”\n\n\nProject Jupyter’s foundation is the interactive Python project (“IPython”), which was started by a Colombian graduate student in physics back in 2001 with the goal of create an easier to use Python environment for scientific computing. In 2014, the notebook interface was first introduced and this part of the project was renamed to Jupyter to indicate that it supported more programming languages than just Python. The main goals of Project Jupyter are to provide an ecosystem for interactive data science projects and to support multiple popular programming languages.\nThe name “Jupyter” is a combination of “Julia” (popular scientific computing language), “Python”, and “R” (popular statistical analysis tool)."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#jupyterlab",
    "href": "modules/module1/slides/module1_03.html#jupyterlab",
    "title": "How to use JupyterLab",
    "section": "JupyterLab",
    "text": "JupyterLab\n\n\nJupyterLab is a browser-based interactive development environment\nYou can work with various types of documents in JupyterLab\nThe main document type used with JupyterLab is Jupyter notebook\n\n\nJupyterLab is an interactive development environment (IDE) that enables you to work with documents and activities such as Jupyter notebooks, text editors, terminals, and custom components in a flexible, integrated, and extensible manner.\nThe main document type that is most commonly used in JupyterLab is the Jupyter notebook.\nOne of the core strengths of Jupyter notebooks is that they enable you to combine narrative text with interactive, executable code and its output all in one place.\nWe’ll talk about Jupyter notebooks in more detail in Module 7."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#the-jupyterlab-interface",
    "href": "modules/module1/slides/module1_03.html#the-jupyterlab-interface",
    "title": "How to use JupyterLab",
    "section": "The JupyterLab interface",
    "text": "The JupyterLab interface\nAfter running jupyter lab, a browser window should open with JupyterLab’s interface:\n\n\nIn previous courses in this data science specialization, you have been running JupyterLab via a web server, without installing anything on your computer.\nAs part of assignment 1 in this course, you will be installing JupyterLab on your own machine. After you have installed it, you can launch JupyterLab by running the command jupyter lab from a terminal (more on terminals in the first assignment instructions and in Module 2).\nWhen JupyterLab launches, you’re going to see the “Launcher” tab, which allows you to create various new working environments."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#the-jupyterlab-interface-1",
    "href": "modules/module1/slides/module1_03.html#the-jupyterlab-interface-1",
    "title": "How to use JupyterLab",
    "section": "The JupyterLab interface",
    "text": "The JupyterLab interface\n\n\nJupyterLab is equipped with a lot of features in traditional IDE’s such as PyCharm and VS Code. However, JupyterLab is geared towards interactive and exploratory computations.\nThe JupyterLab interface mainly consists of a main work area, and a left sidebar which are marked out in this slide. You’ll spend most of your time using these two elements of the JupyterLab interface for various tasks and we will explore both of them in detail in the next slides."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#the-left-sidebar",
    "href": "modules/module1/slides/module1_03.html#the-left-sidebar",
    "title": "How to use JupyterLab",
    "section": "The left sidebar",
    "text": "The left sidebar\n\n\nHere you can see various tabs of the left sidebar:\n\n(1): This tab is the file explorer, which you can use to navigate your file system, open the files you’re looking for, or even create and rename files and much more. You can right-click on any file or folder to see available options.\n(2): This is the running terminals and kernels tab. Here you can see all open tabs in the working area, as well as all running kernels. A kernel is a running language engine connected to your notebooks. We’ll learn more about these later in the course.\n(3): This is the Git extension tab. You will be using this extensively in modules 3-5 to version-control your repositories.\n(4): This is your table of contents tab. Whenever you insert Markdown headings to your notebooks, they will automatically show up here and will help you easily jump to any specific section of your notebook. You can also show code cells in the table of contents and expand and collapse sections to get a quick overview of your notebook.\n\nThere is also an Extension Manager tab which we will talk about in more detail in Module 7."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#the-main-work-area",
    "href": "modules/module1/slides/module1_03.html#the-main-work-area",
    "title": "How to use JupyterLab",
    "section": "The main work area",
    "text": "The main work area\n\n\nThe main work area is where all your working windows reside. Here for example, we have opened:\n\na notebook,\nan image file,\nan IPython console, and\na terminal.\n\nThe content of each window, as well as the toolbars (and whether or not you get one!) depends on the type of the file you opened (e.g. notebook, image, PDF), and the type of the window (e.g. whether it’s a console or a terminal).\nYou can resize the windows as you wish and change their arrangement by dragging the grey margin area between them.\nYou can also drag and drop a tab to another window to make it part of that window, or you can do the reverse."
  },
  {
    "objectID": "modules/module1/slides/module1_03.html#simple-mode",
    "href": "modules/module1/slides/module1_03.html#simple-mode",
    "title": "How to use JupyterLab",
    "section": "Simple mode",
    "text": "Simple mode\n\n\nIf you want to maximize a particular open tab so that you can focus on it, you can do so by\n\nfirst clicking the tabs title bar to activate it (note the thin blue bar appearing at above the title when you activate a tab),\nthen clicking the “Simple” toggle button which is located on the lower left part of the JupyterLab’s interface in the status bar.\n\nHere, I have focused on my notebook tab."
  },
  {
    "objectID": "modules/module1/slides/module1_07.html#module-learning-outcomes",
    "href": "modules/module1/slides/module1_07.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 1",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nExplain why it is important to use the right tool for the job.\nName the tools in the data science toolbox and explain their main purposes.\nDescribe the different components of the JupyterLab interface.\nAsk effective questions.\nCreate minimal reproducible code examples when asking for help.\n\n\nThe assignment will concentrate on the learning objectives as well as building knowledge on existing concepts."
  },
  {
    "objectID": "modules/module2/module2-01-introduction_to_the_shell.html",
    "href": "modules/module2/module2-01-introduction_to_the_shell.html",
    "title": "1. Introduction to the shell",
    "section": "",
    "text": "1. Introduction to the shell\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "1. Introduction to the shell"
    ]
  },
  {
    "objectID": "modules/module2/module2-03-moving_around.html",
    "href": "modules/module2/module2-03-moving_around.html",
    "title": "2. Moving around",
    "section": "",
    "text": "2. Moving around\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "2. Moving around"
    ]
  },
  {
    "objectID": "modules/module2/module2-05-working_with_files_and_directories.html",
    "href": "modules/module2/module2-05-working_with_files_and_directories.html",
    "title": "3. Working with files and directories",
    "section": "",
    "text": "3. Working with files and directories\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "3. Working with files and directories"
    ]
  },
  {
    "objectID": "modules/module2/module2-07-intermediate_shell_topics.html",
    "href": "modules/module2/module2-07-intermediate_shell_topics.html",
    "title": "4. Intermediate shell topics",
    "section": "",
    "text": "4. Intermediate shell topics\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "4. Intermediate shell topics"
    ]
  },
  {
    "objectID": "modules/module2/module2-09-what_did_we_just_learn.html",
    "href": "modules/module2/module2-09-what_did_we_just_learn.html",
    "title": "5. What did we just learn?",
    "section": "",
    "text": "5. What did we just learn?\n\nVideoSlides",
    "crumbs": [
      "**M2. The shell**",
      "5. What did we just learn?"
    ]
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#what-is-a-computer",
    "href": "modules/module2/slides/module2_01.html#what-is-a-computer",
    "title": "Introduction to the shell",
    "section": "What is a computer?",
    "text": "What is a computer?\nA few of the world’s most prominent programmers of the time computing ballistic trajectories on the ENIAC computer during the second world war:\n\nUnidentified U.S. Army photographer, Public domain, Mike Muuss’ computer history archive\n\nEssentially, computing is about humans communicating with machines to modulate flows of current in the hardware. Early examples of human computer communication were quite primitive and included physically disconnecting a wire and connecting it again in a different spot.\nLuckily, we are not doing this anymore; instead we have graphical user interfaces with menus and buttons, which is what you are commonly using when interacting with a computer that runs an operating system such as MacOS, Linux, or Windows.\nThese graphical interface can be thought of as a layer (or a shell) around the internal components of your operating system. Shells exist as an intermediate between the human and the machine; they make it easy for us to express our commands, and for computers to interpret them."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#what-is-text-based-communication",
    "href": "modules/module2/slides/module2_01.html#what-is-text-based-communication",
    "title": "Introduction to the shell",
    "section": "What is text-based communication?",
    "text": "What is text-based communication?\nOpen a file from a graphical menu:\n\nOpening a file via a text-based interface:\n\nfile.open('filename.csv')\n\n\nIn this slide deck, we will learn how to communicate with a computer via a text-based shell, rather than a graphical one.\nUsing a text-based shell might at first seems counter-intuitive, since the reason for creating a shell in the first place was to facilitate user interaction with the computer. So now that we have these easy to use graphical user interfaces (GUIs), why would anyone in their right mind go back to using a text based interface?\nWell, this notion is partly a misconception; GUIs can be nice when you are new to something, but text-based interfaces are actually faster and easier to use when you become more experienced and know more precisely which commands you want the machine to execute.\nWe can compare this process to learning a language: in the beginning it’s nice to look things up in a dictionary (analogous to the menu on a computer), but once we know what we want to say, it is just easer to say or type it directly, instead of being forced to spend time on looking it up first.\nBy extension, it would be even faster to speak or even just think of what you want to do and have the appropriate commands executed by the computer. This is what speech-and brain-computer interfaces are concerned with, and once these becomes more refined and accessible they might take over as the main way for us to interact with computers."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#which-shell-will-we-be-using",
    "href": "modules/module2/slides/module2_01.html#which-shell-will-we-be-using",
    "title": "Introduction to the shell",
    "section": "Which shell will we be using?",
    "text": "Which shell will we be using?\nThe Bash logo:\n\n\nBash is the most commonly used text shell. You have it installed on your computer by default if you are using a Mac or Linux machine, and if you are on a Windows machine you downloaded Bash as part of the setup instructions.\nAs we mentioned in the introduction module, the abbreviation BASH stands for “Bourne Again SHell”. Other shells existed before Bash, and one of the most successful early shells was invented by Stephen Bourne at Bell Labs in 1977, which he called the Bourne Shell. In 1989, the Free Software Foundation improved the Bourne Shell and as a pun named it the Bourne Again Shell, to symbolize it was now “reborn” with new features.\nText-based shells are sometimes called command-line interfaces (CLI, or just “the command line”) and at the heart of every CLI is a read-evaluate-print loop (REPL). When we type a command and press Return (also called Enter) the CLI reads the command, evaluates it (i.e., executes it), prints the command’s output, and loops around to wait for another command.\nLet’s see how to do that next!"
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#how-do-we-open-bash-on-our-computer",
    "href": "modules/module2/slides/module2_01.html#how-do-we-open-bash-on-our-computer",
    "title": "Introduction to the shell",
    "section": "How do we open Bash on our computer?",
    "text": "How do we open Bash on our computer?\nExecuting the shell command jupyter lab:\n\n\nThe JupyterLab landing page:\n\n\nTo run a shell such a Bash, we need to use a Terminal Emulator, or just “Terminal” for short. Most operating systems have one built-in, on MacOS it is called Terminal.app, and on Linux it is usually just called Terminal. On Windows, you could use the terminal application that comes with Git Bash that you installed in Assignment 1, the “Anaconda Prompt” application, or the newer “Windows Terminal” application.\nOpen the respective terminal application for the operating system you are using by browsing your applications menu or searching for the name of the terminal application.\nOne common thing we can use the shell for is a launcher for other applications. The first thing we are going to do is to learn how to launch JupyterLab, which we will use for the rest of this course.\nTo launch JupyterLab, execute the jupyter lab command by typing it into your shell and pressing Enter. You will see some output similar to the screenshot at the top of this slide. After a few seconds, you should see a browser window open with the Jupyter Launcher page similar to the screenshot at the bottom of this slide."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#how-do-we-open-bash-from-jupyterlab",
    "href": "modules/module2/slides/module2_01.html#how-do-we-open-bash-from-jupyterlab",
    "title": "Introduction to the shell",
    "section": "How do we open Bash from JupyterLab",
    "text": "How do we open Bash from JupyterLab\nOpening a terminal from JupyterLab:\n\n\nAn open JupyterLab terminal with black background:\n\n\nSince there is a default terminal application on each operating system, we will be showing how to use Bash via the JupyterLab terminal in this course. Using the terminal application within JupyterLab gives us access to the same shell commands as if we would run the default terminal application on our operating system. The JupyterLab terminal also ensures that the experience is similar across all three operating systems, but you are free to use any terminal to follow along.\nTo open the JupyterLab terminal, go to File -&gt; New -&gt; Terminal as in the screenshot in this slide.\nThe JupyterLab terminal that opens will look slightly different depending on which operating system you are using and what its default terminal settings are. If you want to switch between dark and light backgrounds, you can go to Settings -&gt; Theme and chose either JupyterLab Light or JupyterLab Dark."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#your-first-words-in-bash",
    "href": "modules/module2/slides/module2_01.html#your-first-words-in-bash",
    "title": "Introduction to the shell",
    "section": "Your first words in Bash",
    "text": "Your first words in Bash\nThe default prompt character:\nusername@computer $\n\nTyping in the whoami command for showing your username and pressing enter to run it:\nwhoami\nusername\n\nNow that we know how to open the terminal and JupyterLab, let’s explore some commands in the Bash shell! Our first shell commands will let us explore our folders and files, and will also introduce us to several conventions that most command line tools follow.\nTo start, you will have noticed that when the Terminal with Bash launches it presents us with a blinking line or block. This is called the “prompt” because the blinking is prompting us to enter a command.\nThe default character that is used to represent the prompt is a dollar sign ($). However, different shells may use a different symbol: in particular, the zsh shell, which is the default on newer versions of MacOS, uses %.\nBefore the dollar sign, we can see our username and computer name printed, but this might look different for you depending on your operating systems and settings.\nLet’s run our first command! By typing in whoami and pressing Enter, the computer will tell us who we are by displaying our username.\nNext, let’s move on to something more useful and find out which directory we are in!"
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#where-are-we",
    "href": "modules/module2/slides/module2_01.html#where-are-we",
    "title": "Introduction to the shell",
    "section": "Where are we?",
    "text": "Where are we?\nThe pwd command stands for Print Working Directory.\npwd\n# Linux\n/home/username\n\n# MacOS\n/Users/username\n\n# Windows\n/c/Users/username\n\nThe shell is like a file browser in the sense that we are always inside a directory. When we launch the shell, it puts us inside our home directory by default. Each user on the computer has a separate home directory and the function and location of this directory differs a little bit between operating systems.\nTo view which directory we are currently in we can execute the command pwd (Print Working Directory). Since the home directory differs between operating system, what the shell return when we type pwd inside our home directory will depend on which operating system we are using.\nOn Linux the home directory is usually /home/username, on MacOS it is /Users/username, and on Windows it will show up as /c/Users/username (if you have Git Bash installed). Our examples in this module shows the Linux directory structure, but you will see that some of the other modules show what we would see on MacOS or Windows.\nIn general it is enough to be familiar with the directory structure on your machine, but if you ever work on a shared cloud computer to get access to more computing resources, it is important to also be familiar with the Linux directory structure since most cloud computers run Linux."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#exploring-the-filesystem",
    "href": "modules/module2/slides/module2_01.html#exploring-the-filesystem",
    "title": "Introduction to the shell",
    "section": "Exploring the filesystem",
    "text": "Exploring the filesystem\nls\nDownloads     Music\nDocuments     todo.txt\nPictures      my_program\n\nNow that we know where we are, let’s see what this directory contains by using the command ls (short for “listing”), which prints the names of the files and directories in the current directory. Again, our results may be different depending on our operating system and what files or directories we have created previously.\nIn our example in the slide, we have one file with a txt extension which indicates that this files contains text, and we have five files without an extension (some of these appear to be directories, but we can’t know for sure from this output)."
  },
  {
    "objectID": "modules/module2/slides/module2_01.html#using-commands-with-options",
    "href": "modules/module2/slides/module2_01.html#using-commands-with-options",
    "title": "Introduction to the shell",
    "section": "Using commands with options",
    "text": "Using commands with options\nls -F\nDownloads/    Music/\nDocuments/    todo.txt\nPictures/     my_program*\n\nWe can make the output of ls more informative by using the -F option (a command option is sometimes called a “switch” or a “flag”). Options modify the behavior of the command.\nIn this case, -F tells ls to decorate the printed output to indicate what type of file each entry is. A trailing / (“slash”) indicates a directory, while a trailing * (“asterisk”) tells us that the file is a runnable program. Depending on our setup, the shell might also use colors to indicate what type of file or directory each entry is."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#creating-a-directory",
    "href": "modules/module2/slides/module2_05.html#creating-a-directory",
    "title": "Working with files and directories",
    "section": "Creating a directory",
    "text": "Creating a directory\nCreate a directory called “notes”.\ncd ~/Documents\nmkdir notes\nNaming guidelines\n\nDon’t use spaces\nDon’t begin the name with a - (hyphen)\nStick to digits and letters (preferably lower case)\n\n\nLet’s go back to the ~/Documents directory and create a subfolder called notes. For this we first use the ~ home directory shortcut, and then the mkdir command (MaKe DIRectory).\nWe will talk more about useful naming conventions in Module 6. For now it is enough if you remember these three guidelines.\n\nDon’t use spaces\nDon’t begin the name with a - (hyphen)\nStick to digits and letters (preferably lower case)"
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#creating-a-file",
    "href": "modules/module2/slides/module2_05.html#creating-a-file",
    "title": "Working with files and directories",
    "section": "Creating a file",
    "text": "Creating a file\nls -F notes\n \n(The output is empty because there are no files in the newly created directory)\n\ncd notes\ncode my-first-note.md\n\nSince we just created the notes directory, ls doesn’t display anything when we ask for a listing of its contents.\nLet’s change our working directory to notes, then use the VS Code editor to create a file called my-first-note.md. The command to invoke VS Code from the command line is code, and if we pass it a filename as an argument, the file will be created in the current directory. Now try launching it yourself!\nThe .md syntax means that we want to create a markdown file. File extensions like .md and .py don’t change anything about the content of the file, but they are an indicator to other program such as VS Code what type of content we are going to put inside the file. These program can then activate special functions for certain files, such as using the appropriate colors to highlight headings and functions.\nLet’s move on to the next slide to see how it looks when we are editing file in VS Code."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#editing-a-file-in-vs-code",
    "href": "modules/module2/slides/module2_05.html#editing-a-file-in-vs-code",
    "title": "Working with files and directories",
    "section": "Editing a file in VS Code",
    "text": "Editing a file in VS Code\n\n\nThis is what it looks like to edit a text file in VS Code. You will see that there is a small white circle next to the file name. This is an indication that the file is not saved yet.\nWhen we are done adding our edits, we can hit Ctrl + s to save the file, which will make the white circle disappear. After saving the file, you can optionally close VS Code before returning to the terminal.\nWe are only using VS Code as a simple text editor here, but it is worth knowing that you can use use it as a powerful editor for code as well."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#viewing-the-content-of-a-file-in-the-terminal",
    "href": "modules/module2/slides/module2_05.html#viewing-the-content-of-a-file-in-the-terminal",
    "title": "Working with files and directories",
    "section": "Viewing the content of a file in the terminal",
    "text": "Viewing the content of a file in the terminal\nls\nmy-first-note.md\n\nhead my-first-note.md\nThese are the first\nfew lines of content\nin the file.\n\nIf we now type ls we will see the name of the file we just created in VS Code. To see the content of the file, we can use the head command. head show the first few lines of a file (just as when we use df.head() in pandas), and optionally takes an argument for how many lines to show: head -n 10 (the default is five).\nhead works with all plain text files, such as code and markdown files, but not with binary files such as word documents, spreadsheets, or images. To see the last few lines, you can use tail instead of head."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#moving-files-and-directories",
    "href": "modules/module2/slides/module2_05.html#moving-files-and-directories",
    "title": "Working with files and directories",
    "section": "Moving files and directories",
    "text": "Moving files and directories\nmv my-first-note.md ..\nls ..\nDownloads/    Music/        my-first-note.md\nDocuments/    todo.txt\nPictures/     my_program*\n\nmv ../my-fist-note.md .\nls\nmy-fist-note.md\n\nTo move a file around, we can use the mv command. For example, to move the text file we just created to the parent directory, we would type mv my-first-note.md ... This moves it to the parent directory, and keeps the name the same as we can see if we do ls ..\nIf we want to move the file back to the current directory, we can use the . shortcut: mv ../my-fist-note.md ."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#renaming-a-file",
    "href": "modules/module2/slides/module2_05.html#renaming-a-file",
    "title": "Working with files and directories",
    "section": "Renaming a file",
    "text": "Renaming a file\nmv my-fist-note.md note_2022-06-20.md\nls\nnote_2022-06-20.md\n\nThe -v option prints the name of the moved file\nmv -v notte_2022-06-20.md note_2022-06-20.md\nrenamed 'notte_2022-06-20.md' -&gt; 'note_2022-06-20.md'\n\nRenaming a file can be thought of as moving it to a new filename either in the same or a different directory. This might initially seem a bit different from a graphical file browser, where renaming and moving are two distinct functions, but the underlying operation is actually the same.\nTo give our file a more descriptive name that includes the date we created this file, we would type mv my-fist-note.md notte_2022-06-20.md. We intentionally made a typo here, let’s fix it while showing off the functionality of the -v (verbose) option, which prints what was moved/renamed so that it is easier to keep track of renamed 'notte_2022-06-20.md' -&gt; 'note_2022-06-20.md'.\nWe must be careful when specifying the destination because mv will overwrite existing files without warning. The option -i (“interactive”) makes mv ask us for confirmation before overwriting,. mv also works on directories where it renames the directory without changing its contents."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#copying-files-and-directories",
    "href": "modules/module2/slides/module2_05.html#copying-files-and-directories",
    "title": "Working with files and directories",
    "section": "Copying files and directories",
    "text": "Copying files and directories\nCopy the file to the parent directory:\ncp note_2022-06-20.md ..\n\nCreate a backup copy in the same directory:\ncp note_2022-06-20.md note_2022-06-20.md.bkp\nls\nnote_2022-06-20.md\nnote_2022-06-20.md.bkp\n\nThe cp command create a CoPy of a file. Just as with mv, we optionally rename the file as we are copying it.\nHere we first copy the note we created to the parent directory and then show how we could use cp to create a backup of our file in the same directory. Remember that the file extension does not change the content of the file, so this is just a visual indicator to us for what type of file this is.\nIf we ever wanted to copy a directory, we would have to specify the -r flag, which indicates that we want to copy the directory recursively, i.e. also making a copy of all the directory contents."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#deleting-files-and-directories",
    "href": "modules/module2/slides/module2_05.html#deleting-files-and-directories",
    "title": "Working with files and directories",
    "section": "Deleting files and directories",
    "text": "Deleting files and directories\nrm note_2022-06-20.md.bkp\nls\nnote_2022-06-20.md\n\nrm -iv ../note_2022-06-20.md\nrm: remove regular file '../note_2022-06-20.md'? y\nremoved '../note_2022-06-20.md'\n\nLet’s clean things up by removing our backup copy that we just created. The rm commands allows us to ReMove files and folders. In this case we would type rm note_2022-06-20.md.bkp.\nDeleting is forever: unlike most graphical file browsers, the Unix shell doesn’t have a trash bin that we can recover deleted files from. Just as with mv, we can use the -v to make rm a bit more informative.\nWe can also use the -i flag to make it a bit more safe and ask for confirmation before moving the file. If we want to confirm we type y (for “yes”) and then hit Enter. Let’s use these flags when removing the copy we placed in the parent directory rm -iv ../note_2022-06-20.md.\nAnd just as with cp, we would need to include the -r flag to recursively remove a directory and all its contents."
  },
  {
    "objectID": "modules/module2/slides/module2_05.html#wildcards",
    "href": "modules/module2/slides/module2_05.html#wildcards",
    "title": "Working with files and directories",
    "section": "Wildcards",
    "text": "Wildcards\ntouch note_2022-06-20.md.bkp note_2022-07-02.md note_2022-07-02.md.bkp\nls *.bkp\nnote_2022-06-20.md.bkp\nnote_2022-07-02.md.bkp\n\nls *07*\nnote_2022-07-02.md\nnote_2022-07-02.md.bkp\n\nWildcards (also called “globbing”) simplifies targeting multiple files with similar names in the same command. The most commonly used wildcard is * (a single asterisk). It matches zero or more characters, so typing ls *.md list all of the markdown files in the current directory.\nLet’s first create 3 empty files: note_2022-06-20.md.bkp, note_2022-07-02.md and note_2022-07-02.md.bkp using touch command. If we wanted to list all the files created in July (month 7), we would need to type ls ls *07*, which means that the filename can include anything before and after 07. If we would have left out the second * and type ls *07 we would not have seen any matches because there is not file that end in 07, they all have some characters after.\nUsing wildcards is helpful when we want to delete, move, or copy files with a predictable naming pattern."
  },
  {
    "objectID": "modules/module2/slides/module2_09.html#module-learning-outcomes",
    "href": "modules/module2/slides/module2_09.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 2",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nUse the shell to navigate the computer’s filesystem\nCreate new files and directories\nMove, copy, and delete files and directories\nUse “wildcards”\nDefine and distinguish between absolute file paths and relative file paths\nRead the shell’s built-in manual\nCombine commands with pipes\n\n\nThe assignment will concentrate on the learning objectives as well as building knowledge on existing concepts."
  },
  {
    "objectID": "modules/module3/module3-01-what_is_version_control_and_why_should_you_use_it.html",
    "href": "modules/module3/module3-01-what_is_version_control_and_why_should_you_use_it.html",
    "title": "1. What is version control, and why should you use it?",
    "section": "",
    "text": "1. What is version control, and why should you use it?\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "1. What is version control, and why should you use it?"
    ]
  },
  {
    "objectID": "modules/module3/module3-03-version_control_repositories.html",
    "href": "modules/module3/module3-03-version_control_repositories.html",
    "title": "2. Version control repositories",
    "section": "",
    "text": "2. Version control repositories\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "2. Version control repositories"
    ]
  },
  {
    "objectID": "modules/module3/module3-05-the_staging_area.html",
    "href": "modules/module3/module3-05-the_staging_area.html",
    "title": "3. The staging area",
    "section": "",
    "text": "3. The staging area\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "3. The staging area"
    ]
  },
  {
    "objectID": "modules/module3/module3-07-committing_changes_to_a_local_repository.html",
    "href": "modules/module3/module3-07-committing_changes_to_a_local_repository.html",
    "title": "4. Committing changes to a local repository",
    "section": "",
    "text": "4. Committing changes to a local repository\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "4. Committing changes to a local repository"
    ]
  },
  {
    "objectID": "modules/module3/module3-09-pushing_changes_to_a_remote_repository.html",
    "href": "modules/module3/module3-09-pushing_changes_to_a_remote_repository.html",
    "title": "5. PUSHing changes to a remote repository",
    "section": "",
    "text": "5. PUSHing changes to a remote repository\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "5. PUSHing changes to a remote repository"
    ]
  },
  {
    "objectID": "modules/module3/module3-11-pulling_changes_from_a_remote_repository.html",
    "href": "modules/module3/module3-11-pulling_changes_from_a_remote_repository.html",
    "title": "6. PULLing changes from a remote repository",
    "section": "",
    "text": "6. PULLing changes from a remote repository\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "6. PULLing changes from a remote repository"
    ]
  },
  {
    "objectID": "modules/module3/module3-13-what_did_we_just_learn.html",
    "href": "modules/module3/module3-13-what_did_we_just_learn.html",
    "title": "7. What did we just learn?",
    "section": "",
    "text": "7. What did we just learn?\n\nVideoSlides",
    "crumbs": [
      "**M3. Git and GitHub intro**",
      "7. What did we just learn?"
    ]
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-you-use-it",
    "href": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-you-use-it",
    "title": "What is version control, and why should you use it?",
    "section": "What is version control, and why should you use it?",
    "text": "What is version control, and why should you use it?\n\nimage source: “Piled Higher and Deeper” by Jorge Cham\n\nData analysis projects often require iteration and revision to move from an initial idea to a finished product ready for the intended audience. Without deliberate and conscious effort towards tracking changes made to the analysis, projects tend to become messy.\nThis mess can have serious, negative repercussions on an analysis project, including losing interesting results files that your code cannot reproduce, temporary files with snippets of ideas that are forgotten or not easy to find, mind-boggling file names that make it unclear which is the current working version of the file (e.g., document_final.txt, to_hand_in_final_v2.txt, etc.), and more.\nBeing able to record and view the history of a data analysis project is important for understanding how and why decisions to use one method or another were made, among other things."
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it",
    "href": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it",
    "title": "What is version control, and why should you use it?",
    "section": "What is version control, and why should I use it?",
    "text": "What is version control, and why should I use it?\n\n\n\nWhat does exactly mean to “record the history of a project”?\nInstead of creating a new copy for each version of a file with an unwieldy name (as in the image), version control allows you to have a single file and records the changes between the versions.\nMany of you might already have used version control software if you work with Google Docs, Dropbox, or TimeMachine on macOS. These programs, all automatically create versions of your documents and you can then browse through the history."
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it-1",
    "href": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it-1",
    "title": "What is version control, and why should you use it?",
    "section": "What is version control, and why should I use it?",
    "text": "What is version control, and why should I use it?\n\nThis image was created by Scriberia for The Turing Way community and is used under a CC-BY licence.\n\nAdditionally, data analyses are typically completed by teams. This means that files need to be shared across multiple computers, and multiple people often end up editing the project simultaneously. In such a situation, determining who has the latest version of the project and how to resolve conflicting edits—can be a real challenge.\nVersion control also facilitates collaboration via tools to share edits with others and resolve conflicting edits. But even if you’re working on a project alone, you should still use version control. It helps you keep track of what you’ve done, when you did it, and what you’re planning to do next!"
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it-2",
    "href": "modules/module3/slides/module3_01.html#what-is-version-control-and-why-should-i-use-it-2",
    "title": "What is version control, and why should you use it?",
    "section": "What is version control, and why should I use it?",
    "text": "What is version control, and why should I use it?\n  \n\nWe can define version control as the process of keeping a record of changes to documents, including when the changes were made and who made them, throughout the history of their development. It also provides the means both to view earlier versions of the project and to revert changes.\n\n\nWe can define version control as the process of keeping a record of changes to documents, including when the changes were made and who made them, throughout the history of their development. It also provides the means both to view earlier versions of the project and to revert changes.\nThe material of this module is based on the book by Timbers, T., Campbell, T., & Lee, M. (2022). Data science: A first introduction. CRC Press and the course DSCI 521: Computing Platforms for Data Science from the UBC Master of Data Science program"
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#git-and-github",
    "href": "modules/module3/slides/module3_01.html#git-and-github",
    "title": "What is version control, and why should you use it?",
    "section": "Git and GitHub",
    "text": "Git and GitHub\n\n\nGit - Version control system\n\n\n\n\n\n\n\nGitHub - Repository hosting service\n\n\n\n\n\n\n\nTo version control a project, you generally need two things: (1) a version control system and (2) a repository hosting service.\nThe version control system is the software responsible for tracking changes, sharing changes you make with others, obtaining changes from others, and resolving conflicting edits.\nThe repository hosting service is responsible for storing a copy of the version-controlled project online (a repository), where you and your collaborators can access it remotely, discuss issues and bugs, and distribute your final product. For both of these items, there is a wide variety of choices.\nIn this course, we’ll use Git for version control, and GitHub for repository hosting, because both are currently the most widely used platforms."
  },
  {
    "objectID": "modules/module3/slides/module3_01.html#when-should-you-use-a-repository-hosting-service",
    "href": "modules/module3/slides/module3_01.html#when-should-you-use-a-repository-hosting-service",
    "title": "What is version control, and why should you use it?",
    "section": "When should you use a repository hosting service?",
    "text": "When should you use a repository hosting service?\n\n\nGitHub - Repository hosting service\n\n\n\nTechnically you don’t have to use a repository hosting service. You can, for example, version control a project that is stored only in a folder on your computer— never sharing it on a repository hosting service.\nBut using a repository hosting service provides a few big benefits, including managing collaborator access permissions, tools to discuss and track bugs, and the ability to have external collaborators contribute work, not to mention the safety of having your work backed up in the cloud.\nSince most repository hosting services now offer free accounts, there are not many situations in which you wouldn’t want to use one for your project."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#version-control-workflows",
    "href": "modules/module3/slides/module3_05.html#version-control-workflows",
    "title": "The staging area",
    "section": "Version control workflows",
    "text": "Version control workflows\n\n\nMake a commit of your own changes in the local repository.\nSend your new commits to the remote GitHub repository.\nRetrieve any new changes (that others made) from the remote GitHub repository.\n\n\nWhen you work in a local version-controlled repository, there are generally three additional steps you must take as part of your regular workflow. In addition to working on your files creating, editing, and deleting them as you normally would do, you must also tell Git when to:\n\nMake a commit of your own changes in the local repository.\nSend your new commits to the remote GitHub repository.\nRetrieve any new changes (that others made) from the remote GitHub repository.\n\nIn this section will discuss the first step.\nMaking a commit is at the same time a two step process where you first add the changes to the staging area and then commit them, which saves the differences between the current and previous version of the file together with your message describing what you did. These changes are saved in the hidden .git directory in the Git repository.\nLet’s learn step by step how to make a commit in your local repository"
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#local-repository-with-changes-to-files",
    "href": "modules/module3/slides/module3_05.html#local-repository-with-changes-to-files",
    "title": "The staging area",
    "section": "Local repository with changes to files",
    "text": "Local repository with changes to files\n\n\nWhen working on files in your local version control repository (e.g., using JupyterLab) and saving your work, these changes will only initially exist in the working directory of the local repository on your computer."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#committing-changes-to-a-local-repository",
    "href": "modules/module3/slides/module3_05.html#committing-changes-to-a-local-repository",
    "title": "The staging area",
    "section": "Committing changes to a local repository",
    "text": "Committing changes to a local repository\n \n\n\nOnce you reach a point that you want Git to keep a record of the current version of your work, you need to commit (i.e., snapshot) your changes. A prerequisite to this is telling Git which files should be included in that snapshot. We call this step adding the files to the staging area.\nNote that the staging area is not a meaningful location on your computer; it is instead a temporary placeholder for these files until they are committed. The benefit of the Git version control system using a staging area is that you can choose to commit changes in only certain files. For example, we could add only the two files that are important to the analysis project (analysis.ipynb and README.md) and not the changes we made to our personal scratch notes for the project (notes.txt)."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#open-git-jupyterlab-ide",
    "href": "modules/module3/slides/module3_05.html#open-git-jupyterlab-ide",
    "title": "The staging area",
    "section": "Open Git (JupyterLab IDE)",
    "text": "Open Git (JupyterLab IDE)\n  \n\n\n🙌 Practice\nLet’s commit the files that are in the staging area\nStep 1. Click Jupyter Git extension icon (circled in red).\nAfter you have cloned the remote repository from GitHub to create a local repository, you can get to work editing, creating, and deleting files. For example, suppose you created a new file named eda.ipynb that you would like to commit to the project history. Our next step is to “add” this modified file to the staging area (i.e., flag that this is a file with changes we would like to commit). To do this first you have to click the Jupyter Git extension icon on the far left-hand side of JupyterLab."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#specifying-files-to-commit-jupyter-lab-ide",
    "href": "modules/module3/slides/module3_05.html#specifying-files-to-commit-jupyter-lab-ide",
    "title": "The staging area",
    "section": "Specifying files to commit (Jupyter Lab IDE)",
    "text": "Specifying files to commit (Jupyter Lab IDE)\n\n\n\n🙌 Practice\nStep 2. Add the files you want to commit to the staging area.\nWe can use the small plus sign (+) to add changes we’ve made to a file to the staging area via JupyterLab. In this screenshot, we are adding the notebook file eda.ipynb to our project’s staging area (“eda” stands for “Exploratory Data Analysis”, and is something we often do at the beginning of our project in order to familiarize ourselves with our dataset).\nNote that if this was the first change we ever made to this file, it would have shown up under the Untracked heading in the side panel, indicating that Git is not yet keeping track of this file. However, in this example, we had already made a previous commit to eda.ipynb, which is why it showed up under the Changed heading in the side panel."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#specifying-files-to-commit-jupyter-lab-ide-1",
    "href": "modules/module3/slides/module3_05.html#specifying-files-to-commit-jupyter-lab-ide-1",
    "title": "The staging area",
    "section": "Specifying files to commit (Jupyter Lab IDE)",
    "text": "Specifying files to commit (Jupyter Lab IDE)\n\n\n\n🙌 Practice\nClicking the plus sign (+) moves the file from the Changed heading to the Staged heading, so that Git knows you want a snapshot of its current state as a commit (see image). Now you are ready to commit the changes. When committing it is important to include a (clear and helpful!) message about what was changed so that your collaborators (and future you) know what happened in this commit, something we will learn more about in the next slide deck.\nYou will also notice a eda-checkpoint.ipynb file in the side panel under the Untracked heading. This is a temporary “checkpoint file” created by Jupyter when you work on eda.ipynb. You generally do not want to add auto-generated files like this one to Git repositories; only add the files you directly create and edit."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#specifying-files-to-commit-terminal",
    "href": "modules/module3/slides/module3_05.html#specifying-files-to-commit-terminal",
    "title": "The staging area",
    "section": "Specifying files to commit (Terminal)",
    "text": "Specifying files to commit (Terminal)\n\n\n\nTo check the status of the files using the terminal (Untracked / Changed / Staged) you can use the command git status.\n\n🙌 Practice\nIf you would be using the terminal outside Jupyter Lab, you would not have access to the side panel that shows which files are Untracked, Changed, and Staged. To check the status of all files in your repository using the terminal you can instead use the command git status. In this slide you can see how the different parts of the output from git status corresponds to the Jupyter Lab side panel.\nAn advantage of using this command if you are working in the terminal is that it gives you information on which commands to use to continue your workflow. For example, for files that are under the Changes not staged for commit area, it is suggesred to use the command git add &lt;file&gt; to include them into the staging area.\nChanges not staged for commit:\n   (use \"git add &lt;file&gt;...\" to update what will be committed)\nWe recommend using git status to check the staging area before each commit to ensure you are committing what you think you are."
  },
  {
    "objectID": "modules/module3/slides/module3_05.html#specifying-files-to-commit-terminal-1",
    "href": "modules/module3/slides/module3_05.html#specifying-files-to-commit-terminal-1",
    "title": "The staging area",
    "section": "Specifying files to commit (Terminal)",
    "text": "Specifying files to commit (Terminal)\n\n\n\nYou can add multiple files to the staging area with the command git add\n\n🙌 Practice\nWhen working in the terminal, you can add multiple files at once by listing them after git add.\nAnother command to use in the terminal is git add -p. This allows you to interactively choose which part of each file to add by answering either y (yes) or n (no) to the messages that prompts you about which parts you want to add to the staging area. This way you can add just some changes in a file, which is helpful when trying to include only the relevant changes in each commit and ensuring that you can describe all your changes in a short commit message."
  },
  {
    "objectID": "modules/module3/slides/module3_09.html#pushing-the-changes-to-github",
    "href": "modules/module3/slides/module3_09.html#pushing-the-changes-to-github",
    "title": "Pushing changes to a remote repository",
    "section": "Pushing the changes to GitHub",
    "text": "Pushing the changes to GitHub\n  \n\n\nOnce you have made one or more commits that you want to share with your collaborators, you need to push (i.e., send/upload) those commits back to GitHub. This updates the history in the remote repository (i.e., GitHub) to match what you have in your local repository. Now when collaborators interact with the remote repository, they will be able to see the changes you made. You can also take comfort in the fact that your work is now backed up in the cloud!"
  },
  {
    "objectID": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-jupyter-lab-ide",
    "href": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-jupyter-lab-ide",
    "title": "Pushing changes to a remote repository",
    "section": "Pushing the commits to GitHub (Jupyter Lab IDE)",
    "text": "Pushing the commits to GitHub (Jupyter Lab IDE)\n  \n\n\n🙌 Practice\nClick the “Push” button\nTo push your staged and committed changes to GitHub, first open the Git extension in Jupyter Lab and press push button (click on the cloud icon with the up arrow on the Jupyter Git tab which is circled in red in this slide).\nIf everything went well, you will read a message on the screen informing you that the push was successful."
  },
  {
    "objectID": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-jupyter-lab-ide-1",
    "href": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-jupyter-lab-ide-1",
    "title": "Pushing changes to a remote repository",
    "section": "Pushing the commits to GitHub (Jupyter Lab IDE)",
    "text": "Pushing the commits to GitHub (Jupyter Lab IDE)\n\n\n\n🙌 Practice\nYou can now navigate to the GitHub web interface to see that your changes have been uploaded. There you will see a preview of the commit message, and the time of the most recently pushed commit for each file."
  },
  {
    "objectID": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-terminal",
    "href": "modules/module3/slides/module3_09.html#pushing-the-commits-to-github-terminal",
    "title": "Pushing changes to a remote repository",
    "section": "Pushing the commits to GitHub (Terminal)",
    "text": "Pushing the commits to GitHub (Terminal)\n\n\n\n🙌 Practice\nWe could also push from the terminal instead of from the Jupyter Lab Git extension. If you would like to push from the terminal you can execute the command git push."
  },
  {
    "objectID": "modules/module3/slides/module3_13.html#module-learning-outcomes",
    "href": "modules/module3/slides/module3_13.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 3",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nDifferentiate between the use of GitHub as a remote hosting service for version control and Git as a version control system.\nIdentify a Git repository.\nImplement Git’s clone, add, status, commit, pull, and push operations on the command line and their equivalent use in the JupyterLab IDE.\nUnderstand what it implies to use the staging area in a Git workflow.\nUse commits as the primary building block for storing project versions together with an attached message and a unique identifier.\n\n\nIt is now time to put into practice everything we have learned!"
  },
  {
    "objectID": "modules/module4/module4-01-viewieng_the_history_of_your_project.html",
    "href": "modules/module4/module4-01-viewieng_the_history_of_your_project.html",
    "title": "1. Viewieng the history of your project",
    "section": "",
    "text": "1. Viewieng the history of your project\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "1. Viewieng the history of your project"
    ]
  },
  {
    "objectID": "modules/module4/module4-03-comparing_commits.html",
    "href": "modules/module4/module4-03-comparing_commits.html",
    "title": "2. Comparing commits",
    "section": "",
    "text": "2. Comparing commits\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "2. Comparing commits"
    ]
  },
  {
    "objectID": "modules/module4/module4-05-reset_your_git_project_to_an_earlier_state.html",
    "href": "modules/module4/module4-05-reset_your_git_project_to_an_earlier_state.html",
    "title": "3. Reset your Git project to an earlier state",
    "section": "",
    "text": "3. Reset your Git project to an earlier state\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "3. Reset your Git project to an earlier state"
    ]
  },
  {
    "objectID": "modules/module4/module4-07-revert_changes_made_to_your_git_project.html",
    "href": "modules/module4/module4-07-revert_changes_made_to_your_git_project.html",
    "title": "4. Revert changes made to your Git project",
    "section": "",
    "text": "4. Revert changes made to your Git project\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "4. Revert changes made to your Git project"
    ]
  },
  {
    "objectID": "modules/module4/module4-09-deal_with_merge_conflicts.html",
    "href": "modules/module4/module4-09-deal_with_merge_conflicts.html",
    "title": "5. Deal with merge conflicts",
    "section": "",
    "text": "5. Deal with merge conflicts\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "5. Deal with merge conflicts"
    ]
  },
  {
    "objectID": "modules/module4/module4-11-.gitgnore.html",
    "href": "modules/module4/module4-11-.gitgnore.html",
    "title": "6. .gitgnore",
    "section": "",
    "text": "6. .gitgnore\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "6. .gitgnore"
    ]
  },
  {
    "objectID": "modules/module4/module4-13-what_did_we_just_learn.html",
    "href": "modules/module4/module4-13-what_did_we_just_learn.html",
    "title": "7. What did we just learn?",
    "section": "",
    "text": "7. What did we just learn?\n\nVideoSlides",
    "crumbs": [
      "**M4. Getting groovy with Git and GitHub**",
      "7. What did we just learn?"
    ]
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project",
    "title": "Viewing the history of your project",
    "section": "Viewing the history of a project",
    "text": "Viewing the history of a project\n\nThere are three ways you can view the Git history of a project:\n\nOn GitHub\n\nIn the GitHub web interface through the repo’s code commit view\n\nOn your computer\n\nIn Jupyter Lab, through the repo’s code commit view\nIn the terminal, using git log\n\n\nDo you remember the commit messages we learned about in module 3? When reviewing the history of our repository, the commit messages are useful since they help us remember what was modified in each commit. We will outline three alternative ways to look at the history of the entire project.\nLet’s look closer at each one in the next few slides.\n\nThe material of this chapter is based the course DSCI 521: Computing Platforms for Data Science from the UBC Master of Data Science program."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github",
    "title": "Viewing the history of your project",
    "section": "1. Viewing the history of a project: GitHub",
    "text": "1. Viewing the history of a project: GitHub\n\n\n\nFirst, we will view the history of our project on github.com. On the repository’s landing page on GitHub, you can click the “N commits” link marked in red in the slide (where N is the number of commits made on the repo)."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github-1",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-github-1",
    "title": "Viewing the history of your project",
    "section": "1. Viewing the history of a project: GitHub",
    "text": "1. Viewing the history of a project: GitHub\n\n\n\nAfter clicking the “N commits” link, we can see that there are only three commits in this project. You can identify all parts of each commit, including the day it was made, its author, and hash. You can also go back to browse the state of the repository at the time of this commit by clicking the &lt;&gt; button."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-jupyter-lab",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-jupyter-lab",
    "title": "Viewing the history of your project",
    "section": "2. Viewing the history of a project: Jupyter Lab",
    "text": "2. Viewing the history of a project: Jupyter Lab\n\n\n\nIn JupyterLab, you can access the history of your project by looking in the “History” tab within the Git extension side panel (as we did in the previous module). In this view, we can see the same information as we could online: the time when the commit was made, its author, and hash."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal",
    "title": "Viewing the history of your project",
    "section": "3. Viewing the history of a project: the Terminal",
    "text": "3. Viewing the history of a project: the Terminal\n\n\n\nYou can use the command git log to view your project’s history in the terminal. In this slide, we’ve indicated with a red line how the three commits in the git log output correspond to the information in Jupyter Lab’s “History” tab.\nIt is important to note that git log output shows the long version of the commit hash, not the 7-character version that is displayed by default in Jupyter Lab or GitHub. Except your project is extremely large, Git won’t require more than 7 characters to identify the commit. In consequence, if you need the commit hash and you are using the terminal, you can only copy and paste the first 7 hash characters of the commit."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal-1",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-the-terminal-1",
    "title": "Viewing the history of your project",
    "section": "3. Viewing the history of a project: the Terminal",
    "text": "3. Viewing the history of a project: the Terminal\n\n\n\nAnother option is adding the flag --oneline to the command git log. The command git log --oneline will provide a more succinct version of the information in each commit. This is often more convenient as it is easier to digest and get an overview of the project history, but it can be tedious to type out each time. Here it would be good to create a shell alias, which we learned about in module 2! Executing alias gl=\"git log --oneline\" means that we can simply type gl each time we want to view the git log output. Refer to module 2 for more details around aliases and how to make them persist through reboots.\nThe terminal allows greater flexibility when it comes to displaying the history of the project. If you would like to know what other possibilities you have for using the git log command, you can access the help by typing the command git log --help (any operating system) or man git log (MacOS and Linux)."
  },
  {
    "objectID": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-1",
    "href": "modules/module4/slides/module4_01.html#viewing-the-history-of-a-project-1",
    "title": "Viewing the history of your project",
    "section": "Viewing the history of a project",
    "text": "Viewing the history of a project\n\nOn GitHub\n\nOn GitHub through the repo’s code commit view ✔️\n\nOn your computer\n\nIn Jupyter Lab through the repo’s code commit view ✔️\nIn the terminal using git log ✔️\n\n\nWe have covered three distinct methods for viewing your project’s history. Prior to starting the multiple choice questions below, give these commands a try yourself in an example Git repository!"
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#time-travelling",
    "href": "modules/module4/slides/module4_05.html#time-travelling",
    "title": "Reset your Git project to an earlier state",
    "section": "Time travelling",
    "text": "Time travelling\n\nWe are going to learn two ways to travel back in time to a previous commit:\n\n\nDoing a hard reset\nReverting previous changes\n\n\nIt’s not uncommon to realize that we made a mistake when viewing the history! Maybe we didn’t mean to delete an important file and we want to undo our latest commit. Don’t worry, we can now take advantage of tracking our files using version control to retrieve a previous state of a file and replace the current version.\nThere are two ways of traveling back in time to an earlier state of the repo:\n\nRemove commits from the Git history (a “hard reset”).\nCreate a new commit to undo previous changes (a “reversion”).\n\nIn this slide deck we will look into git reset and in the next one we will cover git revert."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab",
    "href": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (JupyterLab)",
    "text": "Hard reset (JupyterLab)\n\n\nA hard reset deletes your changes AND the history of your project by removing the commits from your current branch. To perform a hard reset in JupyterLab, you should click the clock icon next to the commit you would like to travel back to."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-1",
    "href": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-1",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (JupyterLab)",
    "text": "Hard reset (JupyterLab)\n\n\nBe careful! This action can’t be undone and JupyterLab will display a dialog box to confirm that you are sure that you want to discard your commits."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-2",
    "href": "modules/module4/slides/module4_05.html#hard-reset-jupyterlab-2",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (JupyterLab)",
    "text": "Hard reset (JupyterLab)\n\n\nAfter doing a hard reset on your local Git repository, you would need to push your changes to the remote repository for them to be visible online. However, because you have changed the Git history by removing some commits, this would lead to issues for your colleagues who still have these commits on their computers. Therefore, it is not recommended to use a hard reset when working with collaborators, unless there are extraordinary circumstances requiring it.\nIf you have performed a hard reset locally, but you change your mind you could use the backup on the remote repository to undo your local changes by pulling back the commits from the remote repository."
  },
  {
    "objectID": "modules/module4/slides/module4_05.html#hard-reset-terminal",
    "href": "modules/module4/slides/module4_05.html#hard-reset-terminal",
    "title": "Reset your Git project to an earlier state",
    "section": "Hard reset (Terminal)",
    "text": "Hard reset (Terminal)\ngit reset --hard &lt;commit hash&gt;\ngit push -f/--force\n\n\n\nIn the terminal, you can look at the git log output to find the commit hash we want to reset our project to. Then we can use the command git reset --hard &lt;commit hash&gt;.\nGit by default protects from unintentionally pushing after a hard reset. If you really want to delete the commits and remove them from GitHub, you must use the command git push -f to “force” the push in the terminal, regardless of whether you choose to execute the hard reset using the JupyterLab IDE or the terminal.\nAfter doing a hard reset, JupyterLab will offer you to pull the locally deleted commits from the remote. You shouldn’t pull if you want to preserve the deletion of commits you made with the hard reset!\nExtra\nIf we want to make a new commit with the changes since the reset point, we can perform a “soft” reset with git reset --soft. This command will not discard the information on the deleted commits as git reset --hard, if not will save all in the staging area in case you would like to create a new commit with those changes. This command is useful if you want to combine a series of local commits into one. Note that git reset --soft is only available in the terminal, and not via JupyterLab."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise",
    "href": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise",
    "title": "Handling merge conflicts",
    "section": "When does a merge conflict arise?",
    "text": "When does a merge conflict arise?\n\n\n\nAs we mentioned a few slide decks ago, it is good practice to pull any changes at the start of every work session before you start working on your local copy. If you forget to do this you might end up in a situation where your collaborators have pushed some changes to the remote that you don’t have locally.\nThe solution to this situation is usually simple: you pull down the remote changes to your computer and let Git automatically merge the changes for you, which often works well even if you and your collaborators were working on different parts of the same file!\nHowever, if you and your collaborators made changes to the same line(s) of the same file(s), Git will not be able to automatically merge the changes since it doesn’t know whether to keep your version of the line(s), your collaborator’s version of the line(s), or some blend of the two. When this happens, Git will inform you that you have a “merge conflict” in certain file(s) and let you decide how to solve the issue."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise-1",
    "href": "modules/module4/slides/module4_09.html#when-does-a-merge-conflict-arise-1",
    "title": "Handling merge conflicts",
    "section": "When does a merge conflict arise?",
    "text": "When does a merge conflict arise?\n\n\n\nYou also can visualize the merge conflict as an error when you try to push your local changes to GitHub.\nImagine that at least one commit in the remote repository and one in your local repository are incompatible to combine without overwriting a portion of the work. This is why attempting to pull or push modifications will result in an error. Git is unable to merge the remote and the local version."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: Terminal",
    "text": "Handling merge conflicts: Terminal\ngit status\nOn branch main\nYour branch and 'origin/main' have diverged,\nand have 2 and 1 different commits each, respectively.\n  (use \"git pull\" to merge the remote branch into yours)\n\nYou have unmerged paths.\n  (fix conflicts and run \"git commit\")\n  (use \"git merge --abort\" to abort the merge)\n\nUnmerged paths:\n  (use \"git add &lt;file&gt;...\" to mark resolution)\n        both modified:   README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nIf you are using the terminal, you can detect which files are affected in the merge conflict with the command git status.\nEvery file affected by a merge conflict will be listed in the “Unmerged paths”, in the example we can see that there is a merge conflict on the README.md file."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-1",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-1",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: Terminal",
    "text": "Handling merge conflicts: Terminal\n\n\n\nIn a merge conflict, Git will create marks in the affected files that indicate which areas it is unsure how to handle. To resolve a merge conflict, you need to open the indicated file in a plain text editor and edit the marked up content in a way so that Git knows which changes you want to keep.\nYou can click on the file and select the Option Open With Editor -&gt; Editor"
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-2",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-terminal-2",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: Terminal",
    "text": "Handling merge conflicts: Terminal\n\n\n\nOnce you open the file, you have to find the merge conflict. The beginning of the merge conflict is preceded by &lt;&lt;&lt;&lt;&lt;&lt;&lt; and the end of the merge conflict is marked by &gt;&gt;&gt;&gt;&gt;&gt;&gt;. Between these markings, Git also inserts a separator (=======). The version of the change before the separator is your change (marked with HEAD), and the version that follows the separator was the change that existed on GitHub (marked with the commit hash). In the image, you can see that in your local repository the README.md title is Canadian languages. It looks like your collaborator made an edit to that line too, but the name selected for the title is slightly different: Data Science project: Canadian languages !\nTo resolve the merge conflict, we can do anything we want:\n\nKeep the change made in the local repository,\nKeep the change made in the remote repository,\nWrite something new to replace both, or get rid of the change entirely.\n\nOnce you have decided which option you prefer, you must remove any separators and unwanted text/code from the file and leave only the information you want to include in the new version of the file. After you made your changes, the file must first be saved, then added to the staging area, and finally committed before you will be able to push your changes to GitHub."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: JupyterLab",
    "text": "Handling merge conflicts: JupyterLab\n\n\n\nJupyterLab makes it easier to detect and resolve merge conflicts. In the Git tab, a new section called Conflicted will appear below Changes.\nThere you can visualize all the files that have a merge conflict. In the example, the issue is only affecting the README.md file."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab-1",
    "href": "modules/module4/slides/module4_09.html#handling-merge-conflicts-jupyterlab-1",
    "title": "Handling merge conflicts",
    "section": "Handling merge conflicts: JupyterLab",
    "text": "Handling merge conflicts: JupyterLab\n\n\n\nOnce you click the file with the merge conflict, you will be able to select to accept your current local change or the incoming changes from the remote. In this case, I accepted the current changes by clicking the arrow next to the change. After that, click Mark as resolved, stage the changes, and create a new commit to resolve the conflict.\nYou will now be able to push or pull changes without error!"
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks",
    "href": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks",
    "title": "Handling merge conflicts",
    "section": "Special case: Version control and Jupyter Notebooks",
    "text": "Special case: Version control and Jupyter Notebooks\nJSON format\n{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Canadian Languages\\n\",\n    \"\\n\",\n    \"This project aims to understand what languages Canadian residents speak, and where they speak them.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 3,\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"import pandas as pd\\n\",\n    \"import altair as alt\"\n   ]\n  },\n\nFirst - a bit about what a Jupyter notebook are “plain” text files, and we can view them in a plain text editor.\nHowever, the contents of the notebook are encoded in JSON format, which means that there are many brackets in the file, which can make it hard to read for humans (but easy for machines)."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-1",
    "href": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-1",
    "title": "Handling merge conflicts",
    "section": "Special case: Version control and Jupyter Notebooks",
    "text": "Special case: Version control and Jupyter Notebooks\n\n\n\nBecause the notebooks are stored as plain text, we can use them for version control, but this is not without issues, since the JSON format can make it difficult to interpret difference between files and to manually fix conflicts.\nIn this situation is better to use JupyterLab than any other editor. The same as we explained before, to solve the merge conflict you have to click in this case in the notebook eda.ipynb that show up in the section called Conflicted."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-2",
    "href": "modules/module4/slides/module4_09.html#special-case-version-control-and-jupyter-notebooks-2",
    "title": "Handling merge conflicts",
    "section": "Special case: Version control and Jupyter Notebooks",
    "text": "Special case: Version control and Jupyter Notebooks\n\n\n\nA new tab will appear, displaying the current local changes and incoming remote changes that are incompatible. JupyterLab displays the .ipynb files as notebooks even during the merge conflicts and the conflicting lines are highlighted in red as you can see in the image. You can choose to keep the current changes, the incoming changes, or go back to the commit before the project’s history diverged. The last option is known as “Common ancestor” In the example, I decided to keep the current changes, so you should click the small arrow next to the selected option. Finally, you should click the Mark as solved button. Remember that you need to stage and commit the changes after solving the conflict.\nWe recommend using JupyterLab rather than the terminal to resolve merge conflicts in Jupyter Notebooks."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal",
    "href": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal",
    "title": "Handling merge conflicts",
    "section": "Extra: Stashing local non-committed changes before pulling (Terminal)",
    "text": "Extra: Stashing local non-committed changes before pulling (Terminal)\nerror: Your local changes to the following files would be overwritten by merge:\n        README.md\nPlease commit your changes or stash them before you merge.\nAborting\n\nWe have learned that if there are changes in your remote repo on GitHub and you already have locally committed changes, you will need to pull before you can push. If the local and remote changes are in the same lines, you will have to resolve the resulting merge conflict, otherwise Git will merge automatically.\nBut what if you have just started to make changes to a file when you realize that you forgot to pull before you started to work? The first thing to do is to try to pull, if you’re lucky there are either no new changes or they are not in the same file you modified. If they are in the same file, you will get an error message like the one in the slide."
  },
  {
    "objectID": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal-1",
    "href": "modules/module4/slides/module4_09.html#extra-stashing-local-non-committed-changes-before-pulling-terminal-1",
    "title": "Handling merge conflicts",
    "section": "Extra: Stashing local non-committed changes before pulling (Terminal)",
    "text": "Extra: Stashing local non-committed changes before pulling (Terminal)\ngit stash\nSaved working directory and index state WIP on main: d59b6bb Add MIT license\n\nTo solve this error in the previous slide, we can use a command called git stash, which removes your local changes from the working area and saves them in another location (you can think of this as a secrete pocket which Git does not care about when pulling from the remote repo, and from which you can take out the changes again when you need them). You can then do git pull, and follow up with a git stash apply to bring your changes back from the stash to the working area, and then carry on working.\nThis workflow can save you from running into merge conflicts, as long as you have not already made modifications to the same lines as you are pulling down. If you have already modified the same file that was updated remotely, you will still run into a merge conflict when you do git stash apply.\nStashing is also great when you are working on one feature but realize that you should actually work on another unrelated feature first, you can stash your existing work (instead of manually saving it elsewhere) and finish working on the most urgent feature first."
  },
  {
    "objectID": "modules/module4/slides/module4_13.html#module-learning-outcomes",
    "href": "modules/module4/slides/module4_13.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 4",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nExplore the Git history via git log in the terminal, and the equivalent functions in JupyterLab and GitHub.\nCompare commits using git diff in the terminal, and the equivalent functions in JupyterLab and GitHub.\nSolve merge conflicts at the command line and in VS Code.\nAvoid pushing certain local files by including a .gitignore file.\nDifferentiate between doing a revert and a hard reset of a commit when restoring an older version of a project.\n\n\nThe assignment will concentrate on the learning objectives as well as building knowledge on existing concepts."
  },
  {
    "objectID": "modules/module5/module5-01-the_role_of_branches.html",
    "href": "modules/module5/module5-01-the_role_of_branches.html",
    "title": "1. The role of branches",
    "section": "",
    "text": "1. The role of branches\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams… Welcome to the Git nature walk!**",
      "1. The role of branches"
    ]
  },
  {
    "objectID": "modules/module5/module5-03-how_branches_are_related.html",
    "href": "modules/module5/module5-03-how_branches_are_related.html",
    "title": "2. How branches are related?",
    "section": "",
    "text": "2. How branches are related?\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams… Welcome to the Git nature walk!**",
      "2. How branches are related?"
    ]
  },
  {
    "objectID": "modules/module5/module5-05-merging_branches.html",
    "href": "modules/module5/module5-05-merging_branches.html",
    "title": "3. Merging branches",
    "section": "",
    "text": "3. Merging branches\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams… Welcome to the Git nature walk!**",
      "3. Merging branches"
    ]
  },
  {
    "objectID": "modules/module5/module5-07-when_merging_branches_goes_social:_opening_pull_requests.html",
    "href": "modules/module5/module5-07-when_merging_branches_goes_social:_opening_pull_requests.html",
    "title": "4. When merging branches goes social: opening pull requests",
    "section": "",
    "text": "4. When merging branches goes social: opening pull requests\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams… Welcome to the Git nature walk!**",
      "4. When merging branches goes social: opening pull requests"
    ]
  },
  {
    "objectID": "modules/module5/module5-09-collaborative_github_workflows:_branching.html",
    "href": "modules/module5/module5-09-collaborative_github_workflows:_branching.html",
    "title": "5. Collaborative GitHub workflows: Branching",
    "section": "",
    "text": "5. Collaborative GitHub workflows: Branching\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams… Welcome to the Git nature walk!**",
      "5. Collaborative GitHub workflows: Branching"
    ]
  },
  {
    "objectID": "modules/module5/module5-11-collaborative_github_workflows:_forking.html",
    "href": "modules/module5/module5-11-collaborative_github_workflows:_forking.html",
    "title": "6. Collaborative GitHub workflows: Forking",
    "section": "",
    "text": "6. Collaborative GitHub workflows: Forking\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams… Welcome to the Git nature walk!**",
      "6. Collaborative GitHub workflows: Forking"
    ]
  },
  {
    "objectID": "modules/module5/module5-13-what_did_we_just_learn.html",
    "href": "modules/module5/module5-13-what_did_we_just_learn.html",
    "title": "7. What Did We Just Learn?",
    "section": "",
    "text": "7. What Did We Just Learn?\n\nVideoSlides",
    "crumbs": [
      "**M5. Branches, forks, and streams… Welcome to the Git nature walk!**",
      "7. What Did We Just Learn?"
    ]
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#what-is-a-branch",
    "href": "modules/module5/slides/module5_01.html#what-is-a-branch",
    "title": "The role of branches",
    "section": "What is a branch?",
    "text": "What is a branch?\n\n\nIn Git, a branch represents an isolated line of commits in a repository. By default, you will always start working on the so called main branch. Creating a new branch allows you to work on a series of commits in isolation from the main branch.\nThis is beneficial since you don’t want the repository’s default branch to be updated with every commit of a half-finished feature. Instead, new features are developed on separate branches that will be “merged” into the main branch once the development of that feature is finished. The separation of feature branches from the main branch facilitates parallel development where progress can be made on multiple independent features simultaneously.\nTo illustrate feature-based development with a practical example, we can use the construction of a house as you can see in this slide (each dot represent a commit). First, you need to build the foundation. Since everything depends on the foundation being built, this would be developed on the main branch. When the foundation is finished the construction of other parts of the house that don’t depend on each other could take place in parallel, e.g. some contributors might start working on the walls and others on the floor. When either of these features is finished, it can be added back to the house (what would be similar to merged into main)."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#when-should-a-new-branch-be-opened",
    "href": "modules/module5/slides/module5_01.html#when-should-a-new-branch-be-opened",
    "title": "The role of branches",
    "section": "When should a new branch be opened?",
    "text": "When should a new branch be opened?\n\nWhen we initiate a repository by default we start working on the main branch, but we can be working in parallel in other features.\n\nIn the image we can see that two branches were created from main. The first one, feat-trained-model, is based on the state of the repository at the third commit to the main branch. The second branch is called fix-eda-plot and was initiated from the fourth commit of the main branch to fix one of the exploratory analysis plots. At the end we merge all these branches to main so the isolated modifications are included in the principal branch of our repository.\nWhen should a new branch be opened? Generally speaking, you can assume that every modification that has the potential to break the original code is suitable to be developed in its own feature branch to avoid the risk of it changing how the code in the main branch works.\nNote that the name main for the default branch is just a convention and in some old repositories the default branch could be called master instead of main."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab",
    "title": "The role of branches",
    "section": "How to create a branch? (JupyterLab)",
    "text": "How to create a branch? (JupyterLab)\n\n\n\nTo create a branch in JupyterLab you have to go to Branches &gt; New branch and then write the name of the branch there. If you want to create the new branch based on another branch than main you can click and select it in the menu. You can always switch easily between branches on the Branches tab in the side bar.\nIn this slide, the options available are to create a branch from main, from origin/HEAD and origin/main. We already know that main is the default branch, but what about origin and HEAD?\nThe material of this module is based on the book by Timbers, T., Campbell, T., & Lee, M. (2022). Data science: A first introduction. CRC Press and the course DSCI 521: Computing Platforms for Data Science from the UBC Master of Data Science."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab-1",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-jupyterlab-1",
    "title": "The role of branches",
    "section": "How to create a branch? (JupyterLab)",
    "text": "How to create a branch? (JupyterLab)\n\n\n\nIn the terminal, you can use git log --oneline to check the history of your project, and see which commits correspond to the names origin/HEAD, origin/main and main. You can also see that the currently active branch is shown in cyan at the end of the terminal prompt.\n\nmain is your default local branch.\nHEAD is pointing where you currently are (in this case, on the main branch)\norigin is a nickname for your remote repo on GitHub (instead of showing the full URL), so origin/main is the main branch of the version of the repo you pushed to GitHub.com.\n\nYou don’t need to care about origin/HEAD, it just point to the default remote branch, which will always be main unless you mess around with the settings on the GitHub webpage.\nIn JupyterLab you can see this information as labels under the tab Changes in the sidebar.\n⚠️ Here we added a new synonym for a GitHub repository. Previously, we were using remote as a way to refer to any GitHub repository. Here Git refers to the default remote in which we are working on with the nickname origin."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal",
    "title": "The role of branches",
    "section": "How to create a branch? (Terminal)",
    "text": "How to create a branch? (Terminal)\n\ngit switch -c &lt;branch-name&gt; &lt;commit-hash&gt;\n\n\n\nThe git switch command can be used to alternate between existing branches. If a branch does not yet exist, you can append the -c flag to create the branch as you switch to it. Let’s create a new branch! Type git switch -c &lt;branch-name&gt;, to create and switch to this branch. If you want to create a branch starting in a particular commit you should add the commit hash as another argument. In the example, the branch is created from the last commit, that is the default behaviour when a commit hash is not included.\nAfter creating the branch, you will switch to working on there. In the terminal, you’ll notice that the name of the new branch, in this case report, appears now in parenthesis in the terminal. Also, the Current branch tab in JupyterLab is updated, and the new branch is now listed there.\n🙌\nTo practice working with branches, let’s try adding a commit to one of your example repositories and check what happens in JupyterLab (tab Changes) and with the command line (running the command git log --oneline):\n\nBefore and after doing a commit.\nBefore and after pushing to the remote."
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal-1",
    "href": "modules/module5/slides/module5_01.html#how-to-create-a-branch-terminal-1",
    "title": "The role of branches",
    "section": "How to create a branch? (Terminal)",
    "text": "How to create a branch? (Terminal)\n\n\n\nLet’s see what happens when we make a commit locally.\n\nEdit your README to append one more line of your choice, then add it to the staging area and commit it.\nRun git log --oneline\n\nAs expected, only the reference to where we are currently (HEAD) and the report branch moved, because we have not pushed the changes to our GitHub remote (origin). If you push your changes, the GitHub main branch (origin/main) will also be updated with the latest commit. To confirm this, you can run git log --oneline after pushing the new commit to GitHub.\nBut how can we push a local branch to GitHub?"
  },
  {
    "objectID": "modules/module5/slides/module5_01.html#pushing-a-new-branch",
    "href": "modules/module5/slides/module5_01.html#pushing-a-new-branch",
    "title": "The role of branches",
    "section": "Pushing a new branch",
    "text": "Pushing a new branch\n\ngit push --set-upstream origin &lt;new-branch-name&gt;\n\n\n\nPushing a new branch using JupyterLab is exactly the same as you are used to with the “push” button. However, there is a slight change in the command when you are pushing a branch you created locally with the terminal. Instead of git push you will have to write:\ngit push --set-upstream origin &lt;new-branch-name&gt;\nThis command decides what the new branch will be called on the remote GitHub repo. It is recommended that you use the same name as you use locally, and using a different name is rarely necessary. You don’t need to worry about remembering this command, because git will remind you in the case you forget to specify it as you can see in the image.\nAfter pushing the new branch report to the remote you will notice that the local branch report and the remote branch origin/report are placed in the same commit when you read the history of the project. This means that your remote repository is synchronized with your local repository."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#merging-branches",
    "href": "modules/module5/slides/module5_05.html#merging-branches",
    "title": "Merging branches",
    "section": "Merging branches",
    "text": "Merging branches\n\n\n\nOnce you have finished your modifications in the branch you are working on, it is time to merge your changes to the main branch!\nUpon merging, the changes you were working on in a particular branch are combined with the content of the main branch (or any other branch that you decide to merge your changes with).\nWhen you merge two branches you are creating a new commit with the combined changes. In the image, these commits are represented by yellow circles."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#merging-branches-jupyterlab",
    "href": "modules/module5/slides/module5_05.html#merging-branches-jupyterlab",
    "title": "Merging branches",
    "section": "Merging branches (JupyterLab)",
    "text": "Merging branches (JupyterLab)\n\n\n\nTo merge a branch using JupyterLab, you have to click on the tab Branches and then on the name of the branch you want to merge your current work into. For example, if you are working on the branch main, you can click next to the report branch in the side panel and select “Merge this branch into the current branch”.\nNotice that after doing this, the report branch is not deleted automatically, so you can still access it if you need to."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#merging-branches-terminal",
    "href": "modules/module5/slides/module5_05.html#merging-branches-terminal",
    "title": "Merging branches",
    "section": "Merging branches (Terminal)",
    "text": "Merging branches (Terminal)\n\ngit merge &lt;branch&gt;\n\n\n\nIf you want to use the terminal to merge the branches and you are currently working on the main branch, you can type git merge &lt;branch&gt; to merge the commits from the branch with the new feature into the main branch. In this slide, we merged in the changes of the branched named report into main by typing git merge report while having the main branch active."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#visualizing-merged-branches",
    "href": "modules/module5/slides/module5_05.html#visualizing-merged-branches",
    "title": "Merging branches",
    "section": "Visualizing merged branches",
    "text": "Visualizing merged branches\n\n\n\nLet’s see how VS Code’s graphical representation of the Git history changed when we merged the branches together. Remember that you can open VS Code from the terminal using the command code .. Then go to View &gt; Command Palette and start writing Git: View History (git log). A new tab will open with the Git History. If you want to display all the branches you will have to select them in one of the menus. In this view, we can see that the line for our branch has re-connected to the main branch with a merge commit."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#deleting-branches-jupyterlab",
    "href": "modules/module5/slides/module5_05.html#deleting-branches-jupyterlab",
    "title": "Merging branches",
    "section": "Deleting branches (JupyterLab)",
    "text": "Deleting branches (JupyterLab)\n\n\n\nYou will notice that merging the branch will not automatically delete it. If you are not going to be developing that feature anymore you can delete the branch after merging it by clicking on the small garbage bin icon in the Branches tab.\nYou can only delete a branch when you are not working on it (it is not highlighted in blue in the JupyterLab UI) and although it can be difficult to recover the information after it is deleted, you can safely do so after successfully merging the changes into another branch."
  },
  {
    "objectID": "modules/module5/slides/module5_05.html#deleting-branches-terminal",
    "href": "modules/module5/slides/module5_05.html#deleting-branches-terminal",
    "title": "Merging branches",
    "section": "Deleting branches (terminal)",
    "text": "Deleting branches (terminal)\n\ngit branch -d &lt;branch-name&gt;\n\n\n\nIf you want to delete the branches using the terminal you can use the command git branch -d &lt;branch-name&gt;. Be careful! You should use -d and NOT -D. If you write the flag with a capital -D it will force the deletion, even if the branch has not been merged yet, what could be dangerous. If you add the d flag, it will only delete the branch after it has been merged.\nNow that you have a better grip on how to read the Git history and how to merge branches, it will be easier to work with both branches and forks!"
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#lets-work-together",
    "href": "modules/module5/slides/module5_09.html#lets-work-together",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Let’s work together!",
    "text": "Let’s work together!\n\n\n\nArtwork by @allison_horst\n\nWe have already seen some ways in which Git and GitHub allow collaboration with others. Here we will dive more in depth into which collaborative workflows are the most effective when multiple people are contributing code to the same repository.\nArtwork by @allison_horst"
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#branching-and-forking",
    "href": "modules/module5/slides/module5_09.html#branching-and-forking",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Branching and forking",
    "text": "Branching and forking\nThere are two main strategies we can use to work with others:\n\nBranching\nForking\n\n\nThere are two major ways to work in a collaborative basis using Git and GitHub:\n\nWorking with colleagues in a repository where all of you are members with permission to push code. We call this strategy branching.\n\nIf you start a new repository with some coworkers and you add them as collaborators, you can all contribute to it using branching.\n\nContributing to a repository that you don’t have access to using a GitHub tool called forking.\n\nThe use of forks is common when collaborating on online repositories where you don’t have write access, such as open source projects led by someone else.\nAs an example imagine that you want to contribute to this multilingual glossary for computing and data science terms created by The Carpentries, an inclusive community willing to teach data and coding skills.\nIf you explore the GitHub repo of the project (https://github.com/carpentries/glosario) you will see a file called CONTRIBUTING.md where it is explained how someone can add new terms to the glossary.\nIn general, when you want to contribute to a public repository as this one, you will have to fork the repository first because you don’t have write access. Forking it allow you to create a copy in your GitHub account of the repository at that moment."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#collaborative-work",
    "href": "modules/module5/slides/module5_09.html#collaborative-work",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Collaborative work",
    "text": "Collaborative work\nThere are two main strategies we can use to work with others:\n\n Branching \nForking\n\n\nIn the next slide deck we will focus on forking, but let’s start by learning about the branching strategy first!\nBefore we dive in, remember that regardless of whether you are collaborating via branching or forking, the most common practice before accepting contributions to the main branch involves opening a pull request with the proposed changes and ask for a review before merging those changes."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project",
    "href": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Giving collaborators access to your project",
    "text": "Giving collaborators access to your project\nThe “Invite a collaborator” button on the GitHub web interface.\n\n\nWhen working with a branching workflow, all collaborators need to have “write access” to the remote repository so that they can push up their branches to GitHub. As mentioned earlier, GitHub allows you to control who has access to your project. The default of both public and private projects are that only the creator of the GitHub repository has permissions to create, edit and delete files (write access). Go to the “Settings” tab if your repostiroy on GitHub and select “Collaborators” There, you must click the green “Add people” button."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project-1",
    "href": "modules/module5/slides/module5_09.html#giving-collaborators-access-to-your-project-1",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Giving collaborators access to your project",
    "text": "Giving collaborators access to your project\n\n\n\nThen type in the collaborator’s GitHub username or email, and select their name when it appears.\nAfter this, you should see your newly added collaborator listed under the “Manage access” tab. They should receive an email invitation to join the GitHub repository as a collaborator. They need to accept this invitation to enable write access."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#branch-protection-rules",
    "href": "modules/module5/slides/module5_09.html#branch-protection-rules",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Branch protection rules",
    "text": "Branch protection rules\nUnder “Branch name pattern”, type the branch name or pattern you want to protect.\n\n\n\nNow that everyone has access, they can clone the repository and create a branch using a meaningful name with the feature they are willing to work on. If some of the collaborators push to main without communicating it to the other team members first could it create merging problems. To reduce that risk, you can set up a branch protection rule in the repository, which requires a pull request before merging any code into the protected branch.\n🙌 To add a branch protection rule you can go to Settings &gt; Code and Automation (sidebar) &gt; Branch protection rules and click “Add rule”.\n🙌 Under “Branch name pattern”, type the branch name or pattern you want to protect. Notice that you can create protect branches different to main but we will not cover those use cases in this tutorial."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#branch-protection-rules-1",
    "href": "modules/module5/slides/module5_09.html#branch-protection-rules-1",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "Branch protection rules",
    "text": "Branch protection rules\n\n\n\nIf you think in the analogy of the house, protecting the main branch would be similar to avoid creating modifications in the foundation of the house meanwhile each member is working in different sections. This makes sense since any changes in the house’s foundation could give rise to problems when combining the parts, including the risk of collapsing the house.\nIn your repository, this means that you should be sure that code in main, also called the production branch, is high quality code without bugs or other run problems. Each time you accept merging a contribution of another team member in main be sure that the code is doing what is expected and it is well documented. This way you will always have stable and well build code that runs propoperly in your main branch. This ensures that you are producing code in an organized way.\nUsing branch protection rules is a team decision that could prevent the error of pushing to the main branch without notifying your colleagues. If you made only minor edits the team might let you merge these to main locally and then push up the updated main branch (or even let you not create a branch in the first place).\n⚠️ Remember to get the input from other team members before deciding to implement branch protection, so that everyone in your team is on the same page."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#how-pull-requests-look-like-after-you-protect-the-branch",
    "href": "modules/module5/slides/module5_09.html#how-pull-requests-look-like-after-you-protect-the-branch",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "How pull requests look like after you protect the branch",
    "text": "How pull requests look like after you protect the branch\n\n\n\nThis is how pull requests look like after you protect the branch. You will need the approval of a team member before you can merge the pull request."
  },
  {
    "objectID": "modules/module5/slides/module5_09.html#a-basic-branching-workflow",
    "href": "modules/module5/slides/module5_09.html#a-basic-branching-workflow",
    "title": "Collaborative GitHub workflows: Branching",
    "section": "A basic branching workflow",
    "text": "A basic branching workflow\n\nClone the project - To work locally.\nCreate your branch - Create code or apply your changes.\nMake the desired modifications - Adding a new feature, fixing a bug, etc.\nPush your changes - This will upload your branch to GitHub\nCreate a pull request - So that your changes can be reviewed by another team member.\n\nRemember to pull the changes before starting to work in the repository\n\nGiving your collaborators access to your repository is mandatory to collaborate using branches. Protecting the main branch is considered good practice but experienced users that are very familiar with the workflow could opt to not use this strategy.\nThe workflow will be the same that we have learned before, cloning, adding to the staging area, committing the changes and pushing to the repo with the only difference being that you will have to create a pull request. Merge conflicts could happen and you can use the strategies you have learned in the past modules to resolve them.\nWe are ready to start collaborating!"
  },
  {
    "objectID": "modules/module5/slides/module5_13.html#module-learning-outcomes",
    "href": "modules/module5/slides/module5_13.html#module-learning-outcomes",
    "title": "What Did we Learn and What to Expect in Assignment 5",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nIn this module you learned how to\n\nManage feature-based development efficiently with Git in JupyterLab and in the terminal.\nInfer a repository’s current status and collaboration pattern by looking at visualizations of the project history in VS Code.\nDifferentiate when to use forking or branching as a collaboration strategy.\nRecognize the essential components of a pull request.\nDetermine whether directly merging changes is preferable to first opening a pull request.\nExplain when GitHub issues are helpful and how to use them.\n\n\nNow is time to work!"
  },
  {
    "objectID": "modules/module6/module6-01-file_names:_best_practices.html",
    "href": "modules/module6/module6-01-file_names:_best_practices.html",
    "title": "1. File Names: Best Practices",
    "section": "",
    "text": "1. File Names: Best Practices\n\nVideoSlides",
    "crumbs": [
      "**M6. File Names, Project Organization, Virtual Environments**",
      "1. File Names: Best Practices"
    ]
  },
  {
    "objectID": "modules/module6/module6-03-project_organization.html",
    "href": "modules/module6/module6-03-project_organization.html",
    "title": "2. Project Organization",
    "section": "",
    "text": "2. Project Organization\n\nVideoSlides",
    "crumbs": [
      "**M6. File Names, Project Organization, Virtual Environments**",
      "2. Project Organization"
    ]
  },
  {
    "objectID": "modules/module6/module6-05-virtual_environments.html",
    "href": "modules/module6/module6-05-virtual_environments.html",
    "title": "3. Virtual Environments",
    "section": "",
    "text": "3. Virtual Environments\n\nVideoSlides",
    "crumbs": [
      "**M6. File Names, Project Organization, Virtual Environments**",
      "3. Virtual Environments"
    ]
  },
  {
    "objectID": "modules/module6/module6-07-what_did_we_just_learn.html",
    "href": "modules/module6/module6-07-what_did_we_just_learn.html",
    "title": "4. What Did We Just Learn?",
    "section": "",
    "text": "4. What Did We Just Learn?\n\nVideoSlides",
    "crumbs": [
      "**M6. File Names, Project Organization, Virtual Environments**",
      "4. What Did We Just Learn?"
    ]
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#examples-of-bad-filenames",
    "href": "modules/module6/slides/module6_01.html#examples-of-bad-filenames",
    "title": "File Names: Best Practices",
    "section": "Examples of bad filenames",
    "text": "Examples of bad filenames\n\nmy-figure.png\nfigure1-scatterplot-*-vs-&.png\nFigure 1 scatterplot of asterisks vs ampersands.png\n\nHere are a few examples of filenames that are not recommended to use. Pause here for a minute and study these examples; Can you point out a few problems with the examples in this slide?\nWe will come back to these and show examples of more effective filenames in the next few slides."
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#three-principles-for-effective-filenames",
    "href": "modules/module6/slides/module6_01.html#three-principles-for-effective-filenames",
    "title": "File Names: Best Practices",
    "section": "Three principles for effective filenames",
    "text": "Three principles for effective filenames\n\n\nBe easy to read and informative to a human\nBe machine-readable\nPlay well with default ordering\n\n\nIn general, we’d like filenames to be easy to process by the computer and easy to read and explore by a human. This means that a filename should ideally include both an easily readable human description of what is in the file, and metadata such as dates or tags that make it easy to parse for a computer. It’s also very helpful to have files show up in a logical order when viewed in a file explorer or when listed in the terminal.\nLet’s look closer at each one of these in the next few slides."
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#human-readable-filenames",
    "href": "modules/module6/slides/module6_01.html#human-readable-filenames",
    "title": "File Names: Best Practices",
    "section": "1. Human-readable filenames",
    "text": "1. Human-readable filenames\n\n\nName contains info on content\nConnects to the concept of a slug from semantic URLs\n\n\nExample:\nWhich set of filenames do you want to see at 3 a.m. before a deadline?\n\n\nFilenames provide an opportunity to describe what a file contains so that we don’t have to open each file in order to know what is in it (imagine how tedious this would be!).\nTherefore, it is important to write filenames in a way that makes them easy to interpret for a human reader. It is always preferred to use filenames that reflect something important about the content of the files.\nThe informative part of a filename is often called a “slug”. This is similar to how the last part of a URL is also called a “slug” and is supposed to be relevant to the content of the webpage it points to. If it nicely matches the content of the webpage and is easy to read, chances are more people will click on it, and mention it in other places. It will also help search engines identify the content of a webpage."
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#human-readable-filenames-1",
    "href": "modules/module6/slides/module6_01.html#human-readable-filenames-1",
    "title": "File Names: Best Practices",
    "section": "1. Human-readable filenames",
    "text": "1. Human-readable filenames\n\nAn uninformative filename:\nmy-figure.png\n\nA filename that is not human-readable:\n1_scat_len_int.png\n\nAn easy to read and informative filename:\nfig1_scatterplot-length-vs-interest.png\n\nIn this slide, the name my-figure.png does not contain much information about what this file contains.\nWhat if you created multiple figures for different purposes? Then they would all have the same name.\nThe name 1_scat_len_int.png does seem to provide some information, but it is not easy for a human to understand the file contents just from reading the filename.\nA more effective name for this file would be something like fig1_scatterplot-length-vs-interest.png. This name is easy to parse for a human and includes relevant information about the content of the file."
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#machine-readable-filenames-special-characters-and-spaces",
    "href": "modules/module6/slides/module6_01.html#machine-readable-filenames-special-characters-and-spaces",
    "title": "File Names: Best Practices",
    "section": "2. Machine-readable filenames: Special characters and spaces",
    "text": "2. Machine-readable filenames: Special characters and spaces\n\nAn ineffective name that contains the special characters * and &:\nfigure1-scatterplot-*-vs-&.png\n\nAn ineffective name that contains spaces:\nFigure 1 scatterplot of asterisks vs ampersands.png\n\nA name that is easy to parse for a computer:\nfig1_scatterplot-asterisks-vs-ampersands.png\n\nIn a data science project, we usually read files using a script or inside the terminal environment. Therefore, it is critical to use filenames that are both machine friendly and consistent across files with similar or related content.\nFor example, spaces and punctuation should be avoided in filenames. The reason is that these characters carry special meaning in most programming languages and in Bash. So working with a filename that contains these characters requires special treatment to prevent a script or the terminal from misinterpreting it.\nReturning to our example in the first slide, figure1-scatterplot-*-vs-&.png is not an effective file name. This is because it contains special characters, some of which have special meanings in the shell and will therefore be hard to type in (e.g. *, which we learned is a wildcard matching any sequence of characters in Bash).\nThe second name, Figure 1 scatterplot of asterisks vs ampersands.png, might initially look like a suitable filename because it is easy for us humans to read and it does not appear to contain any special characters.\nHowever, it does contain spaces, and these are often hard to work with, both in Bash and in programming languages like Python. It is therefore recommended to use hyphens instead of spaces to separate words.\nThe words in the filename are also not separated in a way that is easy for a human to read, and they are not descriptive for the contents of the file. The name 1986-01-28_raw-data-from-challenger-o-rings.txt addresses all these issues."
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#machine-readable-filenames-deliberate-use-of-delimiters",
    "href": "modules/module6/slides/module6_01.html#machine-readable-filenames-deliberate-use-of-delimiters",
    "title": "File Names: Best Practices",
    "section": "2. Machine-readable filenames: Deliberate use of delimiters",
    "text": "2. Machine-readable filenames: Deliberate use of delimiters\nDeliberate use of - and _ allows recovery of metadata from filenames:\n\n_ underscore used to delimit units of metadata we want later\n- hyphen used to delimit words so reading becomes easier\n\n\nAn ineffective name without delimiters:\nJun6th Figure 1 scatterplot of asterisks vs ampersands.png\n\nA name where metadata fields are separated by _:\nfig1_2022-06-20_scatterplot-asterisks-vs-ampersands.png\n\nConsistent use of delimiters for files with similar content:\n\n\nAlthough filenames should never contain punctuation characters such as * or ?, we can use underscores or hyphens to separate meaningful parts of a filename such as metadata or tags.\nUsing an extended example from our previous slide, we can see that Jun6th Figure 1 scatterplot of asterisks vs ampersands.png is an ineffective name where it is hard for a machine to figure out the different distinct metadata contained within the filename (e.g., date, figure number, and description).\nA better name would be fig1_2022-06-20_scatterplot-asterisks-vs-ampersands.png, where the format of the name is &lt;figure number&gt;_&lt;date&gt;_&lt;description&gt;, which can easily be parsed programmatically by using underscore as a separator for the different parts.\nThis also avoid using upper-case letters, which can be confusing since filenames are case sensitive on MacOS and Linux, but not on Windows.\nWhen using delimiters to separate metadata fields, it is important to be consistent across files with similar content as we can see an example of in the screenshot in this slide.\nDeliberate and consistent use of delimiters makes it easy to recover all metadata in our filenames in the future, using pattern matching via globbing or using regular expressions as we will see in the next slide."
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#machine-readable-filenames-pattern-matching-in-the-terminal",
    "href": "modules/module6/slides/module6_01.html#machine-readable-filenames-pattern-matching-in-the-terminal",
    "title": "File Names: Best Practices",
    "section": "2. Machine-readable filenames: Pattern matching in the terminal",
    "text": "2. Machine-readable filenames: Pattern matching in the terminal\nFiles in the directory:\n\n\nExample: Globbing with lsto narrow file listing:\n\n\nMachine-readable filenames make it easy to find a group of desired filenames by using special patterns to match parts of the filenames. These patterns are called “glob”s, and finding filenames using this method is called “globbing”.\nIn this example here, we have specified a particular pattern, namely *Plasmid* to find all filenames that contain this word. This is an example of “globbing” using the * wildcard as you might remember from Module 2.\nIf we’ve already been careful to include Plasmid in the name of all files with related content, then finding those files using a script or in the terminal would have been be very easy."
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#machine-readable-filenames-pattern-matching-in-the-file-browser",
    "href": "modules/module6/slides/module6_01.html#machine-readable-filenames-pattern-matching-in-the-file-browser",
    "title": "File Names: Best Practices",
    "section": "2. Machine-readable filenames: Pattern matching in the file browser",
    "text": "2. Machine-readable filenames: Pattern matching in the file browser\nExample: Using MacOS Finder search\n\n\n\nUsing these filename conventions are not only useful in the terminal, but they also make it easy to find the files you need in file browser on Linux, MacOS, or Windows, as can be seen in this slide."
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#machine-readable-filenames-pattern-matching-in-a-programming-language",
    "href": "modules/module6/slides/module6_01.html#machine-readable-filenames-pattern-matching-in-a-programming-language",
    "title": "File Names: Best Practices",
    "section": "2. Machine-readable filenames: Pattern matching in a programming language",
    "text": "2. Machine-readable filenames: Pattern matching in a programming language\nExample: Using regex in Python\n\n\n\nThe same goes for when you want to find those files using a Python or R script. In this case, you have a similar pattern matching mechanism available to you called “regular expressions” or “regex”. Regular expressions are simply search patterns for finding desired strings of characters that we can use in a programming language like Python. They work similarly to globbing, but have a more advanced functionality.\nThe takeaway here is that, if you consistently use machine-readable filenames, you can easily find what you want later, whether it be in the terminal, in a file explorer or using a script!"
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#works-well-with-default-ordering",
    "href": "modules/module6/slides/module6_01.html#works-well-with-default-ordering",
    "title": "File Names: Best Practices",
    "section": "3. Works well with default ordering",
    "text": "3. Works well with default ordering\n\n\nPut something numeric first\nLeft-pad numbers with zeros or display files in “natural” order\nUse the YYYY-MM-DD format for dates\n\n\nLet’s see some examples.\n\nOne other helpful convention to consider is to use filenames that will be ordered in a preferable way by default.\nDepending on the context, we should practice:\n\nPutting something numeric first\nLeft-pad numbers with zeros or display files in “natural” order\nUsing the YYYY-MM-DD format for dates"
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#works-well-with-default-ordering-1",
    "href": "modules/module6/slides/module6_01.html#works-well-with-default-ordering-1",
    "title": "File Names: Best Practices",
    "section": "3. Works well with default ordering",
    "text": "3. Works well with default ordering\n\nLogical order:\n\n\n\nIn this example, we have reason to have the first 5 files in a particular order, and the next 4 in another order. To make sure this happens by default, we can use numbers in the beginning of filenames in a particular order.\nNote the zero-left-padding of the numbers. We’ll see an example of why this is important in the next slide."
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#works-well-with-default-ordering-2",
    "href": "modules/module6/slides/module6_01.html#works-well-with-default-ordering-2",
    "title": "File Names: Best Practices",
    "section": "3. Works well with default ordering",
    "text": "3. Works well with default ordering\n\nls\nfigure02.png\nfigure12.png\nfigure2.png\n\nls -v\nfigure02.png\nfigure2.png\nfigure12.png\n\nIt is good to name files so that they show up in the expected order when viewing them in the terminal or in a file browser.\nBy default, figure12.png would appear before figure2.png because 1 comes before 2.\nTo avoid this, we can number files with a leading zero (e.g. 01, 02, etc) or use the -v option with ls in the terminal. The -v option is called “natural” sort and is available for some graphical file browsers as well."
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#works-well-with-default-ordering-3",
    "href": "modules/module6/slides/module6_01.html#works-well-with-default-ordering-3",
    "title": "File Names: Best Practices",
    "section": "3. Works well with default ordering",
    "text": "3. Works well with default ordering\nChronological order:\n\nAlways use the YYYY-MM-DD format (that is, the ISO 8601 standard) for dates:\n\n\n\nFor ordering based on date and time, we need to use a formatting that computers understand.\nWe encourage you to always use the YYYY-MM-DD format, also known as the ISO 8601 standard.\nComputer environments understand this format well, and it is also nicely readable by humans."
  },
  {
    "objectID": "modules/module6/slides/module6_01.html#recap",
    "href": "modules/module6/slides/module6_01.html#recap",
    "title": "File Names: Best Practices",
    "section": "Recap",
    "text": "Recap\n\nRemember these three principles for filenames:\n\nBeing machine-readable\nBeing human-readable\nPlaying well with default ordering\n\n\nSome more examples of effective filenames:\n\n\n\nAdopting these basic principles is recommended as soon as you start working on a project because:\n\nThey are easy to implement now\nPayoffs accumulate as projects grow more complex"
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#why-use-virtual-environments",
    "href": "modules/module6/slides/module6_05.html#why-use-virtual-environments",
    "title": "Virtual Environments",
    "section": "Why use virtual environments?",
    "text": "Why use virtual environments?\n\n\nMore often than not, you work on multiple projects on your computer.\n\nThat means you need the projects’ computational environments to be isolated from each other.\n\n\n\n\nIsolated environments are also a first step towards reproducibility.\n\nYou need to have the right versions of packages to ensure that everything works great together.\n\n\n\nVirtual environments accomplishes exactly this:\n\n\n\nIt lets you have multiple versions of packages on the same computer without causing conflict.\n\n\n\nJust like we don’t store files and folders of different projects in the same place, we also often don’t want different projects to be run in the same computing environment.\nFor example, what if we need to run the code in a project with pandas 1.1, and another project with pandas 1.4?\nWell, we probably shouldn’t uninstall and reinstall different versions of pandas each time we switch between the two projects.\nWhat can we do then? The solution is to use different virtual computing environments! Being able to simultaneously run different versions of the same packages is highly useful when working on multiple projects on the same computer.\nUsing virtual environments is also critical for reproducibility. Why?\nThe reason is that we want to run each project using the same version of packages with which the project is developed. Failing to do this could result in many problems. For example, a newer version of a package might introduce breaking changes that could prevent our project from running properly. Also, an older version of a package might not yet have the required functionalities used in a project."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#conda",
    "href": "modules/module6/slides/module6_05.html#conda",
    "title": "Virtual Environments",
    "section": "Conda",
    "text": "Conda\n\n\nLogo source\n\n\nConda is an open source package and environment management system for any programming language\nIt is the most popular in the Python community\n\n\nAlright, I hope you’re convinced that using virtual environments is a terrific idea. So, how can we create and use virtual environments?\nThere are several tools to do this, including virtualenv, venv, pipenv and conda.\nHere we use Conda, which is an open source package and environment management system for any programming language; although it’s most popular in the Python community."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#managing-conda-environments",
    "href": "modules/module6/slides/module6_05.html#managing-conda-environments",
    "title": "Virtual Environments",
    "section": "Managing Conda environments",
    "text": "Managing Conda environments\nWhat is a Conda environment and why is it so useful?\n\nConda environment: a set of packages that can be used in one or multiple projects\nCreate an isolated Python environment for your project\n\n\nBenefits of using environments:\n\nReproducibility\nEasily manage different versions\nCreate isolated environments\n\n\nWhat is a Conda environment and why is it so useful to use?\n\nA Conda environment is a set of packages that can be used in one or multiple projects.\nUsing Conda environments, you can create an isolated Python environment for your project.\n\n\nThere are several major benefits to using environments:\n\nReproducibility: You can guarantee that someone else can reproduce your project by specifying which package versions you used, making it easy for others to install the same versions.\nEasily manage different versions: If two of your projects rely on different versions of the same package, you can install these in different environments.\nCreate isolated environments: If you want to play around with a new package, you don’t have to change the packages you use for your data analysis and risk messing something up."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#creating-a-conda-environment",
    "href": "modules/module6/slides/module6_05.html#creating-a-conda-environment",
    "title": "Virtual Environments",
    "section": "Creating a Conda environment",
    "text": "Creating a Conda environment\n\nThere are two ways of setting up a Conda environment:\n\nCreating the environment and installing packages manually\nCreating the environment using a file in .yaml format\n\n\nThere are two ways of creating a Conda environment:\n\nCreating an environment and then installing packages manually\n\nThis can be done either at the time of environment creation or after creating the environment\n\nCreating the environment using a file in .yaml format (e.g. environment.yaml)"
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#creating-environments-manually",
    "href": "modules/module6/slides/module6_05.html#creating-environments-manually",
    "title": "Virtual Environments",
    "section": "Creating environments manually",
    "text": "Creating environments manually\n\n\nconda create -n test_env creates a new environment called test_env\n\n\n\nAt the time of creation, we can also specify:\n\nwhat packages to install in the new environment and\nthe channel from which to download the packages\n\n\n\nconda create -n test_env -c conda-forge python=3.9 jupyterlab pandas=1.3.2\n\nWe can create test_env Conda environment by running conda -n test_env. When you see the prompt Proceed ([y]/n)?, press Enter to continue.\nIt is also often useful to specify more than just the name of the environment, e.g. the channel from which to install packages, the Python version, and a list of packages to install into the new env.\nIn the example below, I am creating the test_env environment that uses:\n\nPython 3.9,\nthe right (usually the latest) version of jupyterlab,\nand pandas version 1.3.2\n\nConda will solve any dependencies between the packages and will create a new environment with those packages.\nUsually we don’t need to specify the channel. But in this case, let’s suppose that I want to get the latest version of these packages I can use the flag -c together with the channel name conda-forge in order to install packages from this particular channel."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#activating-a-conda-environment",
    "href": "modules/module6/slides/module6_05.html#activating-a-conda-environment",
    "title": "Virtual Environments",
    "section": "Activating a Conda environment",
    "text": "Activating a Conda environment\n\n\nThe default Conda environment is called base.\nTo activate a new environment, run conda activate followed by the name of the environment:\n\n\nNoticed how your shell prompt changed?\n\n\nTo see all environments, run conda env list:\n\n\n\nThe default Conda environment is the base environment, which contains only the essential packages from Miniconda. Your shell’s prompt string is prefixed with (base) when you are inside this environment.\nTo activate the new environment we just created, you can type conda activate test_env (and conda deactivate for deactivating).\nNote how the prefix of the prompt string in your shell changes from (base) to (test_env), which helps to show you which environment is active.\nTo see all your environments, you can type conda env list. You can see that I have a few environments for my work other than (base).\nNote how the currently active environment—(test_env) in this case—is denoted with an *."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#sharing-environments-with-others",
    "href": "modules/module6/slides/module6_05.html#sharing-environments-with-others",
    "title": "Virtual Environments",
    "section": "Sharing environments with others",
    "text": "Sharing environments with others\n\nEnvironments can be shared by exporting to an environment file:\nconda env export -f environment.yaml\nwhich list each package and its version in the format package=version=build.\n\nLet’s look inside environment.yaml:\n\n\nTo share an environment, you can export your Conda environment to an environment file, which will list all packages and their versions in this format: package=version=build.\nThe environment file is named environment.yaml here, but it could be called anything we want. This is just a conventional name, and using it makes it easy for others to recognize that this is a Conda environment file. Also, the extension can be either .yaml or .yml. Remember that .yaml files are plain text files, so you can use a text editor such as VS Code to open them.\nIf you open the environment file, you will realize that it contains many more packages than just jupyterlab and pandas. This is because the default behavior is to also list the dependencies that were installed together with these packages. For example, pandas depends on numpy and numpy will be installed along with pandas, even if we don’t explicitly add numpy to our installation command. This is good in the sense that an exact copy of all packages in in your environment will be listed."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#sharing-environments-with-others-1",
    "href": "modules/module6/slides/module6_05.html#sharing-environments-with-others-1",
    "title": "Virtual Environments",
    "section": "Sharing environments with others",
    "text": "Sharing environments with others\nIf you want to only list the packages you explicitly installed, you should use the --from-history flag:\nconda env export --from-history -f environment.yaml\n\nThis time, the environment file will look like this:\n\n\nSometimes package dependencies might differ between operating systems, so exporting an environment file with exact package specifications might not work for someone on a different operating system. To remedy this, you can append the --from-history flag, which looks at the history of the packages you explicitly told Conda to install. This tells Conda to include only explicitly installed packages in the export.\nThe required dependencies will then be handled in an OS-specific manner during installation, which guarantees that they will work across different OSes. The environment.yaml file will be much shorter as a result.\nImportantly, this method will not include package versions unless you’ve done the installation with the package=version syntax. For an environment to be reproducible, you need to explicitly tell Conda which specific versions of packages you need to be installed."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#use-conda-environments-with-jupyterlab",
    "href": "modules/module6/slides/module6_05.html#use-conda-environments-with-jupyterlab",
    "title": "Virtual Environments",
    "section": "Use Conda environments with JupyterLab",
    "text": "Use Conda environments with JupyterLab\nBy default, JupyterLab only sees the Conda environment where it is installed.\n\nFollow these steps to access your Conda environments in JupyterLab:\n\n\nInstall nb_conda_kernels in your base environment\n\nconda install nb_conda_kernels\n\n\nInstall ipykernel in your dstoolbox environment\n\nconda install ipykernel\n\n\nBy default, JupyterLab only sees the Conda environment where it is installed.\nBut there is no need to install JupyterLab in each and every new environment!\nInstead we can use a package called nb_conda_kernels\n\nThis makes it possible to have a single installation of JupyterLab, and access all other Conda environments.\n\n\n\nSuppose that you created a new Conda environment called dstoolbox. To access your dstoolbox environment from JupyterLab, you need to:\n\nInstall nb_conda_kernels in your base environment by running\n\nconda install nb_conda_kernels\n\nInstall ipykernel in your dstoolbox environment by running\n\nconda install ipykernel\nOnce you’ve done that, you’ll be able to see your desired environment in the Launcher tab when you run JupyterLab, and also access its kernel in a notebook (we’ll learn about this later)."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#launching-a-notebook-with-a-specific-conda-environment",
    "href": "modules/module6/slides/module6_05.html#launching-a-notebook-with-a-specific-conda-environment",
    "title": "Virtual Environments",
    "section": "Launching a notebook with a specific Conda environment",
    "text": "Launching a notebook with a specific Conda environment\n\n\nAfter following the steps in the previous slide, you can see that the dstoolbox environment has shown up in JupyterLab’s Launcher tab. Clicking this icon would launch a new Jupyter Notebook with the dstoolbox environment.\nIn the slide, we can see that after following these steps, launching JupyterLab from the (base) environment still shows all available Conda environments, including a newly created environment called (test_env), which is marked in the slide."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#listing-installed-packages",
    "href": "modules/module6/slides/module6_05.html#listing-installed-packages",
    "title": "Virtual Environments",
    "section": "Listing installed packages",
    "text": "Listing installed packages\nconda list\n# packages in environment at //miniconda/envs/test_env:\n#\nUsing Anaconda Cloud api site https://api.anaconda.org\nblas                      1.1                    openblas    conda-forge\nca-certificates           2016.9.26                     0    conda-forge\ncertifi                   2016.9.26                py27_0    conda-forge\ncycler                    0.10.0                   py27_0    conda-forge\nfreetype                  2.6.3                         1    conda-forge\nfunctools32               3.2.3.2                  py27_1    conda-forge\nlibgfortran               3.0.0                         0    conda-forge\n\nWe can get the list of installed packages in the currently active environment using the following command:\nconda list\n\nThe list will include\n\nversions of installed packages\nthe specific build, and\nthe channel that the package was downloaded from."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#searching-packages",
    "href": "modules/module6/slides/module6_05.html#searching-packages",
    "title": "Virtual Environments",
    "section": "Searching packages",
    "text": "Searching packages\nconda search rasterio\nUsing Anaconda Cloud api site https://api.anaconda.org\nRun 'anaconda show &lt;USER/PACKAGE&gt;' to get more details:\nPackages:\n     Name                      |  Version | Package Types   | Platforms      \n     ------------------------- |   ------ | --------------- | ---------------\n     IOOS/rasterio             |    1.0a2 | conda           | linux-64, win-32, win-64, osx-64\n     Terradue/rasterio         |   0.32.0 | conda           | linux-64       \n                                          : Fast and direct raster I/O for use with Numpy and SciPy\n     anaconda/rasterio         |   0.36.0 | conda           | linux-64, win-32, win-64, linux-32, osx-64\n     conda-forge/rasterio      |    1.0a2 | conda           | linux-64, win-32, win-64, osx-64\n                                          : Rasterio reads and writes geospatial raster datasets\n     dharhas/rasterio          |   0.23.0 | conda           | win-64         \n                                          : Rasterio reads and writes geospatial raster datasets.\n     krisvanneste/rasterio     |   0.26.0 | conda           | win-64         \n     ocefpaf/rasterio          |   0.19.1 | conda           | linux-64, osx-64\n     omgarcia/rasterio         |   0.25.0 | conda           | linux-64       \n     pypi/rasterio             |   0.13.2 | pypi            |                \n                                          : Fast and direct raster I/O for Python programmers who use Numpy\nFound 15 packages\n\nYou can also search to see if a particular package can be installed using conda or pypi using the following command. For example, here we look for a package named rasterio:\nconda search rasterio\nThe Anaconda cloud page for rasterio will show how to install the package, compatible OS, individual files for that package, etc."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#installing-packages",
    "href": "modules/module6/slides/module6_05.html#installing-packages",
    "title": "Virtual Environments",
    "section": "Installing packages",
    "text": "Installing packages\n\n\nThe first column of the output of conda search shows the channel/package-name.\n\n\n\nYou can use this information to install a desired package in the active environment.\n\n\nInstall version 0.35 of the package rasterio from the conda-forge channel using:\nconda install -c conda-forge rasterio=0.35\n\nAdd preferred channels to Conda using:\nconda config --add channels conda-forge\n\n\nThe first column of the output of conda search shows channel/package-name\nYou can use this information to install a desired package in the active environment\nFor example, to install version 0.35 of the package rasterio from the conda-forge channel, you can run:\n\nconda install -c conda-forge rasterio=0.35\n\n\nIf you want the latest version, simply avoid providing the version, i.e. simply run conda install -c conda-forge rasterio.\nIf this package depends on other packages to function, Conda will automatically install its dependencies.\nIf you have a few preferred channels, you can make them known to Conda so that you don’t need to explicitly declare the channel every time you want to install a package. This is done using the this command:\n\nconda config --add channels conda-forge"
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#removing-a-package",
    "href": "modules/module6/slides/module6_05.html#removing-a-package",
    "title": "Virtual Environments",
    "section": "Removing a package",
    "text": "Removing a package\n\nRemove rasterio package from test_env using:\nconda remove -n test_env rasterio\n\nSuppose that you decided that you no longer need the package rasterio. To remove this package from the currently active environment, you can run:\nconda remove -n test_env rasterio\n\n\nNote that this will remove rasterio and its dependencies, unless:\n\na dependency was installed explicitly at an earlier point in time or,\na dependency is required by another package."
  },
  {
    "objectID": "modules/module6/slides/module6_05.html#learning-more-about-conda",
    "href": "modules/module6/slides/module6_05.html#learning-more-about-conda",
    "title": "Virtual Environments",
    "section": "Learning more about Conda",
    "text": "Learning more about Conda\n\nAvailable Conda commands:\n\n\n\nFull documentation of a command:\n\nconda update --help\n\nConda version:\n\n\n\n\nTo see which Conda commands are available, you can run conda --help\n\n\n\n\nTo see the full documentation of a command, you can type the command followed by --help:\n\nconda update --help\n\nThe Conda version you have installed can be seen by running conda --version in Bash:"
  },
  {
    "objectID": "modules/module7/module7-00-module_learning_outcomes.html",
    "href": "modules/module7/module7-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M7. JupyterLab**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module7/module7-02-practice_keeping_a_notebook.html",
    "href": "modules/module7/module7-02-practice_keeping_a_notebook.html",
    "title": "1.1. Exercises",
    "section": "",
    "text": "Suppose that you have just opened a notebook with the following cells:\n\n\n\n\n\n\n\n\n\nWe have a notebook like the following:",
    "crumbs": [
      "**M7. JupyterLab**",
      "&nbsp;&nbsp; 1.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module7/module7-02-practice_keeping_a_notebook.html#practice-keeping-a-notebook",
    "href": "modules/module7/module7-02-practice_keeping_a_notebook.html#practice-keeping-a-notebook",
    "title": "1.1. Exercises",
    "section": "",
    "text": "Suppose that you have just opened a notebook with the following cells:\n\n\n\n\n\n\n\n\n\nWe have a notebook like the following:",
    "crumbs": [
      "**M7. JupyterLab**",
      "&nbsp;&nbsp; 1.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module7/slides/module7_00.html#module-learning-outcomes",
    "href": "modules/module7/slides/module7_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nBy the end of this module, you will be able to\n\nPerform literate data science programming using Jupyter Notebooks.\nUse Markdown to efficiently produce formatted text.\nEnhance productivity via advanced JupyterLab features.\nExport notebooks to various formats for sharing your work.\n\n\nIn this module, you will learn how to work more effectively with JupyterLab."
  },
  {
    "objectID": "modules/module7/slides/module7_03.html#what-is-markdown",
    "href": "modules/module7/slides/module7_03.html#what-is-markdown",
    "title": "Markdown for text formatting",
    "section": "What is Markdown?",
    "text": "What is Markdown?\n\n\nLogo source\n\nMarkdown is a fast and easy way to format plain text.\nMost important features:\n\nQuickly write text that can be nicely formatted upon rendering\nA Markdown file is nothing but a plain text file!\n\nMarkdown is supported on various platforms, including GitHub (remember README.md files?) and even Google Doc!\n\nSo far we’ve only talked about code cells, which are responsible for the computational part of a Jupyter notebook. The other major type of cell in a Jupyter notebook is what’s known as a Markdown cell, which allows you to write formatted text. This is where you can store the narrative part of your Jupyter notebook.\nMarkdown provides a fast and easy way to format plain text, without the need to have a graphical interface to manipulate the looks of your document, or needing any special file format.\nIf you’re familiar with HTML or Latex, you’ll notice a lot of similarities. But using Markdown is much simpler and geared towards applications where you need to write a formatted document with convenience, and you don’t need super advanced typographical elements in your document.\nMarkdown can either be used inside stand-alone text files (usually with the .md format, e.g. README.md), or as a part of a framework such as Jupyter notebooks.\nMost important features of the Markdown format are:\n\nIt lets you quickly write text that can be nicely formatted upon rendering.\nThe content of a Markdown file is nothing but plain text, and can be stored as a plain text file."
  },
  {
    "objectID": "modules/module7/slides/module7_03.html#markdown-cells",
    "href": "modules/module7/slides/module7_03.html#markdown-cells",
    "title": "Markdown for text formatting",
    "section": "Markdown cells",
    "text": "Markdown cells\n\n\n\nHere is an example of a Markdown cell. On the left, you see the Markdown source itself, and on the right, you see how it looks when it’s rendered by Jupyter Lab after executing the cell (e.g. by pressing Ctrl + Enter).\nWhen you execute a Markdown cell, Jupyter interprets its content and renders it accordingly.\nIt’s nice to be able to format the text to look that nice just by following simple conventions!"
  },
  {
    "objectID": "modules/module7/slides/module7_03.html#markdown-cells-1",
    "href": "modules/module7/slides/module7_03.html#markdown-cells-1",
    "title": "Markdown for text formatting",
    "section": "Markdown cells",
    "text": "Markdown cells\n\n\nWhenever you create a new cell in a Jupyter Notebook, by default it will be a code cell. So if you write regular text in it, you won’t get Markdown output.\nIn order to convert a code (or raw) cell to a Markdown cell, you can do either of the following:\n\nIn command mode, press M on your keyboard to convert the currently selected cell to a Markdown cell\nThe current cell type is also shown in the toolbar of your notebook as seen in the picture. You can click on the dropdown menu that shows the text “Code”, and then from the menu select “Markdown” to convert the selected cell to a Markdown cell."
  },
  {
    "objectID": "modules/module7/slides/module7_03.html#the-markdown-syntax-headings",
    "href": "modules/module7/slides/module7_03.html#the-markdown-syntax-headings",
    "title": "Markdown for text formatting",
    "section": "The Markdown syntax: Headings",
    "text": "The Markdown syntax: Headings\n\n\n\nLet’s learn a few most commonly used formatting rules in Markdown. In this slide we can see how headings are created by prepending the pound sign (#) to the heading text.\nOne pound sign indicates the top level heading of the document (this is usually your title), and two pound signs indicate the first level of subheadings.\nYou can have as many levels of subheadings as you see fit, and they will all show up hierarchically in the table-of-contents tab in the left side bar, which we introduced in Module 1."
  },
  {
    "objectID": "modules/module7/slides/module7_03.html#the-markdown-syntax-lists-and-quotes",
    "href": "modules/module7/slides/module7_03.html#the-markdown-syntax-lists-and-quotes",
    "title": "Markdown for text formatting",
    "section": "The Markdown syntax: Lists and quotes",
    "text": "The Markdown syntax: Lists and quotes\n\n\n\nNow’s the time to create a bullet-point style list:\n- Item 1\n- Item 2\n- Item 3\n  - Sub-item 1\n    - Sub-sub-item 1\nYou can also create numbered lists. Regardless which number you put in, JupyterLab will automatically number the list in consecutive order:\n1. One\n1. Two\n5. Three\nOne other useful formatting syntax is the block quote for quoting or calling special attention to longer sections of text:\n&gt; Here is a block quote!\n&gt;\n&gt; You can have multiple paragraphs in block quotes."
  },
  {
    "objectID": "modules/module7/slides/module7_03.html#the-markdown-syntax-links-and-images",
    "href": "modules/module7/slides/module7_03.html#the-markdown-syntax-links-and-images",
    "title": "Markdown for text formatting",
    "section": "The Markdown syntax: Links and images",
    "text": "The Markdown syntax: Links and images\n\n\n\nYou can insert a link into your markdown cell by following this syntax:\n[Link text](https://masterdatascience.ubc.ca/)\nInserting images is also very easy and has a syntax similar to inserting links, except that you also have to remember to put an exclamation mark at the beginning:\n![UBC Master of data science logo](https://ubc-mds.github.io/img/mdslogopad.png)\nThe text inside the [] is often called “alt text” and will show up if the image can’t be display for some reason, and it is also helpful for people who rely on accessibility features, so it is important that you include a descriptive message here. This article describes how to write an effective alt text, in case you are interested to learn more about this topic."
  },
  {
    "objectID": "modules/module7/slides/module7_03.html#the-markdown-syntax-formatted-code",
    "href": "modules/module7/slides/module7_03.html#the-markdown-syntax-formatted-code",
    "title": "Markdown for text formatting",
    "section": "The Markdown syntax: Formatted code",
    "text": "The Markdown syntax: Formatted code\n\n\n\nCode is usually formatted with a mono-space font, just as it usually appears in any IDE. For example, anything you write in a code cell inside Jupyter Lab shows up with a mono-space font and has Python syntax highlighting.\nIn Markdown, we can easily format any code to be rendered in mono-space font using backticks like the word this that you can see here in the picture.\nYou can type a backtick by pressing the key under Esc on your keyboard (which is the key with the ` and ~ symbols on it). For example, what you can see here on the picture, import numpy as np, looks like Python code, right?\nAnother way to write code is to have a code block by enclosing text inside a pair of 3 backticks:\n```\narr = np.zeros((2, 2))\nresult = arr + 10\n```\nWe can also enable colorful syntax highlighting by specifying the language in front of the first set of the 3 backticks:\n```python\narr = np.zeros((2, 2))\nresult = arr + np.pi\n```"
  },
  {
    "objectID": "modules/module7/slides/module7_03.html#the-markdown-syntax-math-formulas",
    "href": "modules/module7/slides/module7_03.html#the-markdown-syntax-math-formulas",
    "title": "Markdown for text formatting",
    "section": "The Markdown syntax: Math formulas",
    "text": "The Markdown syntax: Math formulas\n\n\n\nMarkdown supports \\(\\LaTeX\\) math formulas, which are a powerful and commonly used way to write mathematical expressions.\nIf you have never seen \\(\\LaTeX\\) before, it can look a bit intimidating, especially for the more complex formulas. But you can quickly pick up the syntax for basic expressions, and then look up the more advanced functionality whenever needed.\nTo write an “inline” math formula in a paragraph of text, we can surround the expression with a pair of dollar signs: Here is an inline math formula $ F = ma $.\nLonger formulas can be written in a math “block”, which you can create by surrounding the math expression by a pair of double dollar signs, as shown at the bottom of the screenshot."
  },
  {
    "objectID": "modules/module7/slides/module7_03.html#pro-tips-for-markdown-formatting",
    "href": "modules/module7/slides/module7_03.html#pro-tips-for-markdown-formatting",
    "title": "Markdown for text formatting",
    "section": "Pro tips for Markdown formatting",
    "text": "Pro tips for Markdown formatting\n\n\nMarkdown provides limited formatting styles that are often enough, but not always.\nSometimes, we just need more!\n\n\nYou can use HTML inside Markdown text to enable advanced formatting, such as\n\nChange the displayed size of an image\nChange text size and color\n\n\nSince Markdown renderers use HTML under the hood to format a Markdown text document, explicit HTML tags will be rendered when used inside a Markdown document.\nSometimes it might be helpful to borrow a few tricks from HTML to achieve certain formatting styles that are not available in standard Markdown.\nHere are a few things you can’t do with standard Markdown, but you can do with HTML tags:\n\nChange the displayed size of an image\nChange text size and color"
  },
  {
    "objectID": "modules/module7/slides/module7_03.html#pro-tip-1-change-image-size",
    "href": "modules/module7/slides/module7_03.html#pro-tip-1-change-image-size",
    "title": "Markdown for text formatting",
    "section": "Pro tip 1: Change image size",
    "text": "Pro tip 1: Change image size\nYou can use the following HTML tag to change the displayed size of an image:\n&lt;img src=\"&lt;PATH_TO_FILE&gt;\" width=\"400px\"&gt;&lt;/img&gt;\n\n\n\nYou can use the HTML tag that you see in the slide to change the displayed size of an image:\n&lt;img src=\"&lt;PATH_TO_FILE&gt;\" width=\"400px\"&gt;&lt;/img&gt;\nNote that in width=400px, px is optional. Instead of px (which stands for “pixel”), you can also use % to specify the width relative to the original width of the image. For example, the image HTML tag with width=\"150%\"\n&lt;img src=\"&lt;PATH_TO_FILE&gt;\" width=\"150%\"&gt;&lt;/img&gt;\nenlarges the displayed image by a factor of 1.5."
  },
  {
    "objectID": "modules/module7/slides/module7_03.html#pro-tip-2-change-text-size-color",
    "href": "modules/module7/slides/module7_03.html#pro-tip-2-change-text-size-color",
    "title": "Markdown for text formatting",
    "section": "Pro tip 2: Change text size & color",
    "text": "Pro tip 2: Change text size & color\nYou can also use the following HTML tag to change the size and color of a piece of text:\n&lt;p style=\"color:black; font-size:120%\"&gt;\nSome text you want to show in a different color or size\n&lt;/p&gt;\n\n\n\nIn this slide, you can see how we can also style a paragraph using the HTML paragraph tags (&lt;p&gt;) together with the style attribute. The style attribute allows us to specify CSS properties that we want to style our text with.\nLearning HTML and CSS is beyond the scope of this course, but the excellent Khan academy has a helpful introduction to both HTML and CSS in case you are interested to learn more about these topics.\nKeep in mind that you can do much more than just changing the size of an image or the color of text in HTML. However, since the whole idea of Markdown is its readability, and that it can be written without the usual complexity of markup languages such as HTML, try to use HTML tags sparingly and only if you absolutely need to achieve a particular formatting."
  },
  {
    "objectID": "modules/module7/slides/module7_07.html#running-shell-commands-in-jupyter-notebooks",
    "href": "modules/module7/slides/module7_07.html#running-shell-commands-in-jupyter-notebooks",
    "title": "Advanced JupyterLab tips and tricks",
    "section": "Running shell commands in Jupyter notebooks",
    "text": "Running shell commands in Jupyter notebooks\n\nIn order to run a shell command in a cell, prefix it with a !:\n\n\nSometimes it is very handy to be able to quickly run shell commands from within a Jupyter notebook. You can run any shell command by prefixing it with a !, and run it inside a computational cell just like any other code cell.\nYou cannot interact with the output from shell commands as you would in a terminal. Therefore, if you want to install something with Conda, you will not be able to respond y/n on the confirmation prompt and instead need to append the -y option to the original command to automatically accept the confirmation prompt."
  },
  {
    "objectID": "modules/module7/slides/module7_07.html#running-shell-commands-in-jupyter-notebooks-1",
    "href": "modules/module7/slides/module7_07.html#running-shell-commands-in-jupyter-notebooks-1",
    "title": "Advanced JupyterLab tips and tricks",
    "section": "Running shell commands in Jupyter notebooks",
    "text": "Running shell commands in Jupyter notebooks\nA common action: exporting a notebook without code cells\n\n\nOne common use of an ! command in a notebook cell is to export a notebook without its code cells by using the nbconvert command directly, instead of using the export menu in JupyterLab—which also calls nbconvert under the hood.\nTo do this, copy and paste the command below into a code cell in your notebook. Then replace this-notebooks-name.ipynb with an appropriate notebook filename, and finally run the code cell:\n!jupyter nbconvert this-notebooks-name.ipynb \\\n    --to html \\\n    --output=output-filename.html \\\n    --no-input\nOf course you can run this command using a terminal, but it could be much more convenient if you just want to quickly run a shell command in the folder in which the notebook resides.\nIf you put it in the last cell in your notebook, you will always have an updated HTML export file when you click “Run all” in JupyterLab."
  },
  {
    "objectID": "modules/module7/slides/module7_07.html#magic-commands",
    "href": "modules/module7/slides/module7_07.html#magic-commands",
    "title": "Advanced JupyterLab tips and tricks",
    "section": "Magic commands",
    "text": "Magic commands\n\nMagic commands provide useful functionalities in a convenient and concise way.\n\n\n\nMagic commands introduced here are provided by and specific to IPython. Other languages may have their own set of magic commands, or none at all.\n\n\nMagic commands are special commands which implement a particular functionality that might not be doable or straight-forward using Python code.\nFor example, you can measure the amount of time it takes on average to run a code cell, or run a .py Python script file directly using the notebook’s kernel.\nA magic command can be run either in line or cell mode:\n\nLine mode only applies to one line of code, and is activated by prefixing a relevant command with %. For example, %reset -f removes all variable names defined by the user without restarting the kernel.\nCell mode applies to an entire cell, and is activated by prefixing a relevant command with %% at the beginning of a code cell. For example, the %%timeit cell magic in the following code runs the cell multiple times to compute an average running time:\n\n%%timeit\nfor i in range(1_000_000):\n    (i - 0.1)**2\nNote that magic commands are only available in notebooks running a Python kernel. If you want to see a full list of available magic commands, you can run %lsmagic (which itself is a magic command). Also check out this link to find more information about magic commands."
  },
  {
    "objectID": "modules/module7/slides/module7_07.html#magic-commands-post-mortem-debugging",
    "href": "modules/module7/slides/module7_07.html#magic-commands-post-mortem-debugging",
    "title": "Advanced JupyterLab tips and tricks",
    "section": "Magic commands: Post-mortem debugging",
    "text": "Magic commands: Post-mortem debugging\n\nPost-mortem debugging:\n\n\n\nWe’ve already seen how we can reset the Python namespace using %reset -f and how to time code execution using %%timeit.\nThere is another useful magic command which allows us to perform “post-mortem” (literally meaning “after death”) debugging. If you run a cell and happen to get an error, you can investigate what happened post mortem; that is, after the error was thrown, by running %debug in a different cell. Here, you can see an example of a syntax error, and the follow-up investigation using %debug.\nWhen an error is thrown, the traceback shows that several files are affected.\nWhen you enter into debugging mode, you might not be in the right file from the beginning. If this is the case, you can use U and D keys on your keboard to navigate up and down, respectively, in the files hierarchy.\nTwo other useful keyboard shortcuts are C for continuing execution until the next error, and Q to quit the debugger and go back to working with your code cells. Note that the rest of your notebook will be unresponsive until you quit the debugger by pressing Q.\nThe debugger that is used by JupyterLab is the standard Python debugger pdb, so you can read more about all the options and commands in the Python documentation."
  },
  {
    "objectID": "modules/module7/slides/module7_07.html#magic-commands-searching-code-cell-history",
    "href": "modules/module7/slides/module7_07.html#magic-commands-searching-code-cell-history",
    "title": "Advanced JupyterLab tips and tricks",
    "section": "Magic commands: Searching code cell history",
    "text": "Magic commands: Searching code cell history\n\nSearching code cell history:\n\n\n\nAnother useful magic command is %hist which displays the history for all the input cells you have executed. This is a bit overwhelming on its own, but it is very useful with the -g option.\nIn JupyterLab, you can use %hist -g &lt;search_pattern&gt; to search through all code cells you have ever executed. This also includes executed statements from previous sessions, so it’s similar to history | grep &lt;search_pattern&gt; in the shell.\nThis is a great option for when you’ve deleted that piece of code you were 100% sure you’d never need again and was not important enough to be committed, but you—of course—ended up wanting it back a few days later.\nHere, you see an example of using %hist -g to find a list of executed cells which contained “range(1, 10)”."
  },
  {
    "objectID": "modules/module7/slides/module7_07.html#multiple-cursors",
    "href": "modules/module7/slides/module7_07.html#multiple-cursors",
    "title": "Advanced JupyterLab tips and tricks",
    "section": "Multiple cursors",
    "text": "Multiple cursors\n\n\nHold Alt/Option + drag:\n\n\n\nHold Alt/Option + Ctrl/Command + click\n\n\n\nA cool and sometimes time-saving feature in JupyterLab is the multiple cursor feature.\nSuppose that here, you need to type 100 + in front of all of these variable definitions. Instead of typing 100 + one by one, first hold down Alt (in Windows or Linux) or Option (in Mac). Your mouse pointer changes into a +. Now, click and hold while dragging down the cursor to place multiple cursors at multiple positions, just as seen in the first recording here. When you’re happy with your selection, you can start typing, and voila!\nInstead of\n\nholding Alt/Option + drag\n\nyou can also\n\nhold Alt/Option + Ctrl/Command + click\n\nat various locations to place multiple cursors wherever you need them, and then start typing. An example of this is shown in the second recording."
  },
  {
    "objectID": "modules/module7/slides/module7_07.html#next-level-jupyterlab",
    "href": "modules/module7/slides/module7_07.html#next-level-jupyterlab",
    "title": "Advanced JupyterLab tips and tricks",
    "section": "Next-level JupyterLab",
    "text": "Next-level JupyterLab\n\nMore advanced features of JupyterLab:\n\nThe graphical debugger\nReal-time collaboration\nWorkspaces\n\n\nIn addition to what we have discussed so far, there are a few additional advanced features of JupyterLab which can be helpful when working on specific projects. Some of these features are:\n\nThe graphical debugger\nReal-time collaboration\nWorkspaces\n\nWe will not discuss these features in detail here, but we’ll briefly explain their functionality and point you to the official documentation for each feature in the next few slides."
  },
  {
    "objectID": "modules/module7/slides/module7_07.html#the-graphical-debugger",
    "href": "modules/module7/slides/module7_07.html#the-graphical-debugger",
    "title": "Advanced JupyterLab tips and tricks",
    "section": "The graphical debugger",
    "text": "The graphical debugger\nDocumentation: https://jupyterlab.readthedocs.io/en/stable/user/debugger.html\n\n\nWhen you write code, things usually do not go perfectly on the first go, and you’ll eventually need to debug your code at some point.\nWe have already seen how we can use %debug to perform post-mortem debugging and JupyterLab recently also added a useful graphical debugger. This allows for easier access to more advanced debugging techniques such as setting breakpoints, inspecting variables, and more.\nYou can find more details, including a tutorial notebook, in JupyterLab’s official documentation."
  },
  {
    "objectID": "modules/module7/slides/module7_07.html#real-time-collaboration",
    "href": "modules/module7/slides/module7_07.html#real-time-collaboration",
    "title": "Advanced JupyterLab tips and tricks",
    "section": "Real-time collaboration",
    "text": "Real-time collaboration\nDocumentation: https://jupyterlab.readthedocs.io/en/stable/user/rtc.html\n\n\nAnother interesting and potentially helpful feature of JupyterLab is that you can enable real-time collaboration between multiple clients. Every user will have their own cursor in the same notebook as shown in the screenshot here (pretty much like in a Google Doc!). They can simultaneously edit and execute cells, and all the changes will be visible to other users in real time.\nYou can read more about the real-time collaboration feature of JupyterLab in the documentation.\nNote that the real-time collaboration feature of JupyterLab is still experimental, and being actively worked on so its features and interface might change quickly."
  },
  {
    "objectID": "modules/module7/slides/module7_07.html#workspaces",
    "href": "modules/module7/slides/module7_07.html#workspaces",
    "title": "Advanced JupyterLab tips and tricks",
    "section": "Workspaces",
    "text": "Workspaces\nDocumentation: https://jupyterlab.readthedocs.io/en/stable/user/urls.html\n\n\nWhen you work in JupyterLab, you might have a couple of files, views, and other windows open. You might also have set up the layout of your JupyterLab in a particular way; for example, notebooks on the left, output views on the right, and consoles on the bottom.\nIf you shutdown and relaunch JupyterLab, you’ll see that this particular setup, including the open files and tabs and their arrangements, will get restored. This is because JupyterLab internally stores these information using the concept of a workspace.\nIn case you need different setup of open files and layouts while working on multiple or large projects, you may want to create and use several workspaces. This is easily possible with JupyterLab: you can create new workspaces or clone existing workspaces and modify them as you wish, just through the URL of your browser. In order to learn how to use workspaces, check out JupyterLab’s documentation."
  },
  {
    "objectID": "modules/module8/module8-00-module_learning_outcomes.html",
    "href": "modules/module8/module8-00-module_learning_outcomes.html",
    "title": "0. Module Learning Outcomes",
    "section": "",
    "text": "0. Module Learning Outcomes\n\nVideoSlides",
    "crumbs": [
      "**M8. Jupyter Book**",
      "0. Module Learning Outcomes"
    ]
  },
  {
    "objectID": "modules/module8/module8-02-practice_today_a_reader_tomorrow_a_leader.html",
    "href": "modules/module8/module8-02-practice_today_a_reader_tomorrow_a_leader.html",
    "title": "1.1. Exercises",
    "section": "",
    "text": "We have the following folder containing the files we’d like to include in a report created using Jupyter Book:\nclimate-change/\n├── _config.yml\n├── _toc.yml\n├── intro.md\n├── lit-review.md\n├── logo.png\n├── analysis\n|   ├── EDA.ipynb\n|   ├── feat-eng.ipynb\n|   ├── predictive-model.ipynb\n├── discussion.md\n├── references.bib\n└── requirements.txt",
    "crumbs": [
      "**M8. Jupyter Book**",
      "&nbsp;&nbsp; 1.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module8/module8-02-practice_today_a_reader_tomorrow_a_leader.html#practice-today-a-reader-tomorrow-a-leader",
    "href": "modules/module8/module8-02-practice_today_a_reader_tomorrow_a_leader.html#practice-today-a-reader-tomorrow-a-leader",
    "title": "1.1. Exercises",
    "section": "",
    "text": "We have the following folder containing the files we’d like to include in a report created using Jupyter Book:\nclimate-change/\n├── _config.yml\n├── _toc.yml\n├── intro.md\n├── lit-review.md\n├── logo.png\n├── analysis\n|   ├── EDA.ipynb\n|   ├── feat-eng.ipynb\n|   ├── predictive-model.ipynb\n├── discussion.md\n├── references.bib\n└── requirements.txt",
    "crumbs": [
      "**M8. Jupyter Book**",
      "&nbsp;&nbsp; 1.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module8/module8-04-practice_becoming_an_author.html",
    "href": "modules/module8/module8-04-practice_becoming_an_author.html",
    "title": "2.1. Exercises",
    "section": "",
    "text": "Suppose that you have inserted an image in your book using the following markdown block:\n```{figure} https://upload.wikimedia.org/wikipedia/commons/0/09/TheCheethcat.jpg\n ---\n height: 600px\n name: an-african-cheetah\n ---\n An African Cheetah\n ```\n\n\n\n\n\n\n\n\n```{math}\n:label: newton-2nd-law\n$$\\Sigma F = m \\frac{dV}{dt}$$\n```",
    "crumbs": [
      "**M8. Jupyter Book**",
      "&nbsp;&nbsp; 2.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module8/module8-04-practice_becoming_an_author.html#practice-becoming-an-author",
    "href": "modules/module8/module8-04-practice_becoming_an_author.html#practice-becoming-an-author",
    "title": "2.1. Exercises",
    "section": "",
    "text": "Suppose that you have inserted an image in your book using the following markdown block:\n```{figure} https://upload.wikimedia.org/wikipedia/commons/0/09/TheCheethcat.jpg\n ---\n height: 600px\n name: an-african-cheetah\n ---\n An African Cheetah\n ```\n\n\n\n\n\n\n\n\n```{math}\n:label: newton-2nd-law\n$$\\Sigma F = m \\frac{dV}{dt}$$\n```",
    "crumbs": [
      "**M8. Jupyter Book**",
      "&nbsp;&nbsp; 2.1. Exercises"
    ]
  },
  {
    "objectID": "modules/module8/slides/module8_00.html#module-learning-outcomes",
    "href": "modules/module8/slides/module8_00.html#module-learning-outcomes",
    "title": "Module Learning Outcomes",
    "section": "Module Learning Outcomes",
    "text": "Module Learning Outcomes\nBy the end of this module, you will be able to\n\nExplain the Jupyter Book ecosystem.\nBuild Jupyter Books via the command line.\nCreate your own content files.\nPublish your book online for free using GitHub Pages.\n\n\nIn this module, you will learn how to build books and create websites using Jupyter Book."
  },
  {
    "objectID": "modules/module8/slides/module8_03.html#create-your-file-and-add-content-to-it",
    "href": "modules/module8/slides/module8_03.html#create-your-file-and-add-content-to-it",
    "title": "Add your own content: Essentials",
    "section": "Create your file and add content to it",
    "text": "Create your file and add content to it\n\nCreate a new file called my-markdown-file.md with the following content:\n\nMarkdown syntax specific to Jupyter Book:\n\n(section-label)=\n[link text](link-target)\n\n\nIn the folder with all of your sample book contents, create a new file called my-markdown-file.md. Put the following content in it:\n\nWe’ve added two new pieces of markdown syntax, both of them are related to cross-references.\n\n(section-label)= is a label that’s attached to a section header. It refers to whatever header follows, and allows you to refer to this label later on in your text.\n[link text](link-target) syntax is how you specify a link in markdown. Here we’ve linked to another page, as well as to the label we created above.\n\nWhen you build your book, you’ll see how these links resolve in the output.\nYou can find out more about cross-referencing in Jupyter Book’s documentation linked here: https://jupyterbook.org/en/stable/content/references.html."
  },
  {
    "objectID": "modules/module8/slides/module8_03.html#add-your-file-to-your-table-of-content",
    "href": "modules/module8/slides/module8_03.html#add-your-file-to-your-table-of-content",
    "title": "Add your own content: Essentials",
    "section": "Add your file to your table of content",
    "text": "Add your file to your table of content\n\n\n\nOnce you’ve created a file and added your own content to it, you have to add it to your table of content file, that is, _toc.yml to make it available to Jupyter Book.\n\nBy doing this, you are informing Jupyter Book where the new file fits with your book’s structure."
  },
  {
    "objectID": "modules/module8/slides/module8_03.html#rebuild-your-book-after-making-changes",
    "href": "modules/module8/slides/module8_03.html#rebuild-your-book-after-making-changes",
    "title": "Add your own content: Essentials",
    "section": "Rebuild your book after making changes",
    "text": "Rebuild your book after making changes\n\nDon’t forget to rebuild your book!\n\nClean cached book files:\njupyter-book clean my-book/\nRebuild the book:\njupyter-book build my-book/\n\nIn order to see the changes you’ve made, don’t forget to rebuild your book.\n\nTo clean cached book files and make sure everything is rebuilt from scratch, first run:\njupyter-book clean my-book/\nand then run the following to rebuild the book:\njupyter-book build my-book/\nYour new page will now show up in the rebuilt book when you refresh your browser page."
  },
  {
    "objectID": "modules/module8/slides/module8_03.html#figures",
    "href": "modules/module8/slides/module8_03.html#figures",
    "title": "Add your own content: Essentials",
    "section": "Figures",
    "text": "Figures\nYou can include figures in your Jupyter Book using the following syntax:\n ```{figure} https://solarsystem.nasa.gov/system/resources/detail_files/2486_stsci-h-p1936a_1800.jpg\n:::\n\n ---\n height: 300px\n name: jupiter-figure\n:::\n\n ---\n The beautiful planet Jupiter!\n ```\n\n\n\nYou can include figures in your Jupyter Book using the syntax that you can see on the slide [1]:\n ```{figure} https://solarsystem.nasa.gov/system/resources/detail_files/2486_stsci-h-p1936a_1800.jpg\n:::\n\n ---\n height: 300px\n name: jupiter-figure\n:::\n\n ---\n The beautiful planet Jupiter!\n ```\nThe numbering of figures is automatic, so if you insert new ones before some of the existing figures, Jupyter Book will renumber the existing ones for you!\nThe reason we have name: jupiter-figure is so we can cross-reference a figure later in the text, as we will show you in the next slide.\n[1] Example adopted from UBC Jupyter Days 2020 Workshop"
  },
  {
    "objectID": "modules/module8/slides/module8_03.html#cross-referencing-figures",
    "href": "modules/module8/slides/module8_03.html#cross-referencing-figures",
    "title": "Add your own content: Essentials",
    "section": "Cross-referencing figures",
    "text": "Cross-referencing figures\n\n\nCross-referencing a figure means linking/referencing the figure from somewhere else in the document. Here for example, in order to reference the figure that we’ve named jupiter-figure, we can use {numref}`jupiter-figure` in the text.\nAfter adding a figure and referencing it in the main text, our markdown file (i.e., my-markdown-file.md) looks like in this slide. The rendered version is shown on the next page."
  },
  {
    "objectID": "modules/module8/slides/module8_03.html#cross-referencing-figures-1",
    "href": "modules/module8/slides/module8_03.html#cross-referencing-figures-1",
    "title": "Add your own content: Essentials",
    "section": "Cross-referencing figures",
    "text": "Cross-referencing figures\nThe end result will look like this if you rebuild your Jupyter Book:\n\n\nThis is what the end result will look like after you rebuild your Jupyter Book.\nYou can see how the figure we added shows up nicely in the center, has its own caption, and is numbered automatically.\nAlso note how the referenced figure looks like in the 2nd paragraph of the text (red arrow)."
  },
  {
    "objectID": "modules/module8/slides/module8_03.html#math-and-equations",
    "href": "modules/module8/slides/module8_03.html#math-and-equations",
    "title": "Add your own content: Essentials",
    "section": "Math and equations",
    "text": "Math and equations\n\nIn Jupyter Book, you can easily add:\n\nInline math equations\nMath equation blocks\nNumbered equations\n\n\n\nInline math:\n\nJupiter has a mass of: $m_{j} \\approx 1.9 \\times 10^{27} \\: \\text{kg}$\n\nWhen rendered by Jupyter Book, it looks like this:\n\n\nJupyter Book uses MathJax for typesetting math which allows you to add LaTeX-style maths to your book, including\n\ninline math equations,\nmath equation blocks, and\nnumbered equations.\n\n\n\nInline math can be defined by enclosing expressions in $s as you can see on the slide:\n\nJupiter has a mass of:  $m_{j} \\approx 1.9 \\times 10^{27} \\: \\text{kg}$\nWhen rendered by Jupyter Book, it looks like the screenshot at the bottom of this slide."
  },
  {
    "objectID": "modules/module8/slides/module8_03.html#math-and-equations-1",
    "href": "modules/module8/slides/module8_03.html#math-and-equations-1",
    "title": "Add your own content: Essentials",
    "section": "Math and equations",
    "text": "Math and equations\n\n\nMath blocks:\n\n$$\n  m_{j} \\approx 1.9 \\times 10^{27} \\: \\text{kg}\n$$\nRendered:\n\n\n\nNumbered equations:\n\n\n\n```{math}\n:label: eq_label\nm_{j} \\approx 1.9 \\times 10^{27} \\: \\text{kg}\n```\n\n\nRendered:\n\n\n\nMath blocks are used for more complex expressions and can be defined by enclosing the math in a pair of dollar signs, i.e. $$:\n\n$$\n  m_{j} \\approx 1.9 \\times 10^{27} \\: \\text{kg}\n$$\nwhich will show up in the rendered book like the top-most screenshot in this slide.\n\n\nIf you want to reference an equation in the text and have Jupyter Book automatically take care of numbering it, you can use numbered equations via the label attribute:\n\n\n\n```{math}\n:label: eq_label\nm_{j} \\approx 1.9 \\times 10^{27} \\: \\text{kg}\n```\n\n\nThis will render as the screenshot on the bottom of this slide and you will see more details about cross-referencing equations like this in the next slide."
  },
  {
    "objectID": "modules/module8/slides/module8_03.html#cross-referencing-equations",
    "href": "modules/module8/slides/module8_03.html#cross-referencing-equations",
    "title": "Add your own content: Essentials",
    "section": "Cross-referencing equations",
    "text": "Cross-referencing equations\n\nYou can refer to equation using their labels.\nUse {eq}`eq_label` for equations, just like {numref}`jupiter-figure` for images.\n\n\nHere is how we add equations to my-markdown-file.md:\nJupiter has a mass of $m_{j} \\approx 1.9 \\times 10^{27} \\: \\text{kg}$.\nLet's show this as a code block as well:\n\n$$\n  m_{j} \\approx 1.9 \\times 10^{27} \\: \\text{kg}\n$$\n\nAnother way is to have named equations so you can cross-reference them later:\n\n\n\n```{math}\n:label: eq_label\nm_{j} \\approx 1.9 \\times 10^{27} \\: \\text{kg}\n```\n\n\n\nEquation {eq}`eq_label` is an example of a named equation.\n\nIf you have created an equation with a label, you can link to it from within your text and across pages.\nYou can refer to the equation using the label that you’ve provided by using {eq}`eq_label`, just like {numref}`jupiter-figure` that we used with images.\n\nYou can see in the slide how we add equations to my-markdown-file.md:"
  },
  {
    "objectID": "modules/module8/slides/module8_03.html#cross-referencing-equations-1",
    "href": "modules/module8/slides/module8_03.html#cross-referencing-equations-1",
    "title": "Add your own content: Essentials",
    "section": "Cross-referencing equations",
    "text": "Cross-referencing equations\nOnce you add these equations to my-markdown-file.md and rebuild your Jupyter Book, your book will look like:\n\n\nOnce you add these equations to my-markdown-file.md and rebuild your Jupyter Book, your book will look like the screenshot in this slide. Note the equation numbering pointed at by the red arrow."
  },
  {
    "objectID": "modules/module8/slides/module8_07.html#github-pages",
    "href": "modules/module8/slides/module8_07.html#github-pages",
    "title": "Publish your book online",
    "section": "GitHub Pages",
    "text": "GitHub Pages\n\nhttps://pages.github.com/\n\nOnce you’ve built the HTML for your book, you can host it online.\n\nThe most convenient way to do this is with a service that supports static websites. This means that the files we created with Jupyter Book’s build command can simply be uploaded to a web server to create a web page.\nThe quickest and most convenient option for publishing your book website online is to use GitHub Pages.\n\nThere are a few steps to follow to publish your book using GitHub Pages. We’ll go over those steps in the following slides."
  },
  {
    "objectID": "modules/module8/slides/module8_07.html#create-an-online-repository-for-your-book",
    "href": "modules/module8/slides/module8_07.html#create-an-online-repository-for-your-book",
    "title": "Publish your book online",
    "section": "Create an online repository for your book",
    "text": "Create an online repository for your book\n\n\n\nFirst, login on GitHub, then go to the “create a new repository” page, which is linked here: https://github.com/new\nNext, give your online repository a name and a description. Make your repository public and do not initialize it with a README file. Your screen should look like this:\nClick “Create repository” at the end of the page.\n\nAfter this step, we can go ahead and upload the built Jupyter Book to our GitHub repo directly.\nHowever, it’s a good idea to first push the source files of our Jupyter Book to GitHub."
  },
  {
    "objectID": "modules/module8/slides/module8_07.html#push-the-source-files-to-github",
    "href": "modules/module8/slides/module8_07.html#push-the-source-files-to-github",
    "title": "Publish your book online",
    "section": "Push the source files to GitHub",
    "text": "Push the source files to GitHub\n\nClone the empty online repository to your computer:\ngit clone https://github.com/&lt;my-org&gt;/&lt;my-repository-name&gt;\n\n\n\nCopy your book files into this newly cloned repository:\ncp -r mynewbook/* myonlinebook/\n\n\n\nAdd _build/ to your .gitignore to avoid pushing build artifacts to your main branch\n\n\n\nSync your local and remote repositories:\ncd myonlinebook\ngit add ./*\ngit commit -m \"adding my first book!\"\ngit push\n\n\nLet’s now learn how to push the source files to our books online repository:\n\nFirst, clone the (currently empty) online repository to a location on your local computer. You can do this using the git clone command:\ngit clone https://github.com/&lt;my-org&gt;/&lt;my-repository-name&gt;\nCopy all of your book’s files and folders into this newly cloned repository. For example, if you created your book locally using the jupyter-book create mynewbook command, and your new repository is called myonlinebook, you can do this in the command line using cp -r as shown on the slide:\ncp -r mynewbook/* myonlinebook/\nAdd _build/ to your .gitignore to avoid pushing build artifacts to your main branch. We are going to push these files and folders to another branch later to create the website.\nNow you need to sync your local and remote (i.e., online) repositories. You can do this with the last series of commands shown on the slide:\ncd myonlinebook\ngit add ./*\ngit commit -m \"Add my first book\"\ngit push"
  },
  {
    "objectID": "modules/module8/slides/module8_07.html#publish-your-built-book-online-with-github-pages",
    "href": "modules/module8/slides/module8_07.html#publish-your-built-book-online-with-github-pages",
    "title": "Publish your book online",
    "section": "Publish your built book online with GitHub Pages",
    "text": "Publish your built book online with GitHub Pages\n\nNext, we have to host the build artifact of our book online, although we don’t want them on the main branch\n\nThe build artifacts are needed for rendering the book as a website\n\n\n\n\nThe easiest way is to use the ghp-import package\n\nghp-import is a lightweight Python package that makes it easy to push HTML content to a GitHub repository\n\n\n\nWe’ll learn how to use ghp-import in the next few slides.\n\nWe have just pushed the source files for our book into our GitHub repository This makes the source code—that is, the notebooks, markdown document, etc.—publicly accessible for everyone.\nHowever, we still aren’t hosting the book’s webpage which Jupyter Book has generated for us.\nIn order to do this, we first need to upload the HTML files generated by the build command to GitHub. These files are usually called build artifacts.\nThe build artifacts are needed for rendering the book as a website, but we don’t want to keep track of numerous build files on the main branch using Git. The build artifacts are temporary and replaceable. You can regenerate the build artifacts solely using your source files by running the build command.\nConsidering what we just discussed, we’re going to put the build artifacts on a branch that is specific to GitHub pages, which is called gh-pages by default.\nWe could upload the build artifacts manually to this site, but there is a package called ghp-import that will automate this process. ghp-import is a lightweight Python package that makes it easy to push HTML content to a GitHub repository.\nghp-import works by copying the entire content of your built book (i.e., the _build/html folder) to a branch of your repository called gh-pages (instead of main), and pushing everything to GitHub. This way you don’t create unnecessary clutter on your main branch.\nWe’ll learn how to use ghp-import in the next few slides."
  },
  {
    "objectID": "modules/module8/slides/module8_07.html#how-to-use-ghp-import-to-publish-our-book",
    "href": "modules/module8/slides/module8_07.html#how-to-use-ghp-import-to-publish-our-book",
    "title": "Publish your book online",
    "section": "How to use ghp-import to publish our book",
    "text": "How to use ghp-import to publish our book\n\nInstall ghp-import:\npip install ghp-import\n\n\n\nFrom the main branch of your book’s local root directory, call ghp-import and point it to your HTML files:\nghp-import -n -p -f _build/html\n\n\n\nNow gh-pages branch is automatically set to host your website HTML files. You can view this in the settings page of your GitHub repository:\n\n\n\n\nFirst step is to install ghp-import using the command\npip install ghp-import\n\nin your current conda environment.\n\n\nThen, from the main branch of your book’s local root directory (which contains the _build/html folder), call ghp-import and point it to your HTML files. You can do this by running the second command on the slide:\nghp-import -n -p -f _build/html\nWith ghp-import, we will always use these three flags (namely, -n, -p, and -f). It’s not very important to know what each flag does, but here is a brief explanation:\n\nThe -n flag instructs GitHub to not treat this as a “Jekyll” repository (which is another type of static webpage).\nThe -p flag is what pushes our changes to GitHub.\nThe -f flag create a force push. Since these build artifacts are re-generated each time, we just want to overwrite whatever is in the current gh-pages branch with our latest version of these files.\n\nThis is also mentioned in this warning from the ghp-import GitHub repository which tells you that: &gt; \n\n“…ghp-import will DESTROY your gh-pages branch… and assumes that the gh-pages branch is 100% derivative. You should never edit files in your gh-pages branch by hand if you’re using this script…”\n\n\n\n\n\n\n\nNow the gh-pages branch is automatically set to host your website HTML files. You can view this in the settings page of your GitHub repository as shown in this slide."
  },
  {
    "objectID": "modules/module8/slides/module8_07.html#your-book-is-now-online",
    "href": "modules/module8/slides/module8_07.html#your-book-is-now-online",
    "title": "Publish your book online",
    "section": "Your book is now online!",
    "text": "Your book is now online!\n\nTypically, your website should be viewable online after a few minutes at a URL such as: https://&lt;user&gt;.github.io/&lt;myonlinebook&gt;/\n\n\n\n\n\nTypically, your website should be viewable online after a few minutes at a URL such as: https://&lt;user&gt;.github.io/&lt;myonlinebook&gt;/\n\n\n\nIf not, check your repository settings (under Settings -&gt; Pages)."
  },
  {
    "objectID": "modules/module8/slides/module8_07.html#how-to-update-your-book",
    "href": "modules/module8/slides/module8_07.html#how-to-update-your-book",
    "title": "Publish your book online",
    "section": "How to update your book",
    "text": "How to update your book\n\nMake changes to your book’s content on the main branch of your repository\n\n\n\nRe-build your book with jupyter-book build myonlinebook/\n\n\n\nUse ghp-import -n -p -f myonlinebook/_build/html to push the changes to the gh-pages branch.\n\n\nIn order to update the content of your book:\n\nMake your desired changes to the source files on the main branch of your repository\n\n\n\nNext, re-build your book with jupyter-book build myonlinebook/\n\n\n\nAnd finally, use ghp-import -n -p -f myonlinebook/_build/html to push the changes to the gh-pages branch."
  },
  {
    "objectID": "modules/module9/module9-00-congratulations.html",
    "href": "modules/module9/module9-00-congratulations.html",
    "title": "0. Congratulations!",
    "section": "",
    "text": "0. Congratulations!\n\nVideoSlides",
    "crumbs": [
      "**Module Closing Remarks**",
      "0. Congratulations!"
    ]
  }
]